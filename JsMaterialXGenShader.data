install(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/
        DESTINATION "${MATERIALX_INSTALL_STDLIB_PATH}" MESSAGE_NEVER
        PATTERN "CMakeLists.txt" EXCLUDE)
# MaterialX Data Libraries

This folder contains the standard data libraries for MaterialX, providing declarations and graph definitions for the MaterialX nodes, and source code for all supported shader generators.

## Standard Pattern Library
- [stdlib](stdlib)
    - [stdlib_defs.mtlx](stdlib/stdlib_defs.mtlx) : Nodedef declarations.
    - [stdlib_ng.mtlx](stdlib/stdlib_ng.mtlx) : Nodegraph definitions.
    - [genglsl](stdlib/genglsl): GLSL language support.
        - lib : Shader utility files.
        - [stdlib_genglsl_impl.mtlx](stdlib/genglsl/stdlib_genglsl_impl.mtlx) : Mapping from declarations to implementations.
        - [stdlib_genglsl_cm_impl.mtlx](stdlib/genglsl/stdlib_genglsl_cm_impl.mtlx) : Minimal set of "default" color management implementations.
        - [stdlib_genglsl_unit_impl.mtlx](stdlib/genosl/stdlib_genglsl_unit_impl.mtlx) : Real world unit support implementations.
        - GLSL implementation files.
    - [genosl](stdlib/genosl): OSL language support.
        - lib: Shader utility files.
        - [stdlib_genosl_impl.mtlx](stdlib/genosl/stdlib_genosl_impl.mtlx) : Mapping from declarations to implementations.
        - [stdlib_genosl_cm_impl.mtlx](stdlib/genosl/stdlib_genosl_cm_impl.mtlx) : Minimal set of "default" color management implementations.
        - [stdlib_genosl_unit_impl.mtlx](stdlib/genosl/stdlib_genosl_unit_impl.mtlx) : Real world unit support implementations.
        -  OSL implementation files.
    - [osl](stdlib/osl): OSL reference implementations.
        - These are the original OSL reference implementations from MaterialX v1.35, and will be replaced with generated OSL code in the future.
    - [genmdl](stdlib/genmdl): MDL language support.
        - [stdlib_genmdl_impl.mtlx](stdlib/genosl/stdlib_genmdl_impl.mtlx) : Mapping from declarations to implementations.
        - [stdlib_genmdl_cm_impl.mtlx](stdlib/genosl/stdlib_genmdl_cm_impl.mtlx) : Minimal set of "default" color management implementations.
        - [stdlib_genmdl_unit_impl.mtlx](stdlib/genosl/stdlib_genmdl_unit_impl.mtlx) : Real world unit support implementations.

## Physically Based Shading Library
- [pbrlib](pbrlib)
    - [pbrlib_defs.mtlx](pbrlib/pbrlib_defs.mtlx) : Nodedef declarations.
    - [pbrlib_ng.mtlx](pbrlib/pbrlib_ng.mtlx) : Nodegraph definitions.
    - [genglsl](pbrlib/genglsl) : GLSL language support
        - lib : Shader utility files.
        - [pbrlib_genglsl_impl.mtlx](pbrlib/genglsl/pbrlib_genglsl_impl.mtlx) : Mapping from declarations to implementations.
        - GLSL implementation files.
    - [genosl](pbrlib/genosl) : OSL language support
        - lib : Utilities
        - [pbrlib_genosl_impl.mtlx](pbrlib/genosl/pbrlib_genosl_impl.mtlx) : Mapping from declarations to implementations.
        - OSL implementation files.
    - [genmdl](pbrlib/genmdl) : MDL language support
        - [pbrlib_genmdl_impl.mtlx](pbrlib/genosl/pbrlib_genmdl_impl.mtlx) : Mapping from declarations to implementations.
        - Note: MDL implementation files are in a "package" folder found under [source/MaterialXGenMdl/mdl/materialx](../source/MaterialXGenMdl/mdl/materialx)

## BxDF Graph Library
- [bxdf](bxdf)
    - [standard_surface.mtlx](bxdf/standard_surface.mtlx) : Graph definition of the [Autodesk Standard Surface](https://autodesk.github.io/standard-surface/) shading model.
    - [usd_preview_surface.mtlx](bxdf/usd_preview_surface.mtlx) : Graph definition of the [UsdPreviewSurface](https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html) shading model.
    - [lama](bxdf/lama) : Graph definitions of the [MaterialX Lama](https://rmanwiki.pixar.com/display/REN24/MaterialX+Lama) node set.

## Target Definitions
- Each target implementation requires a target definition for declaration / implementation correspondence to work.
- The [targets](targets) folder contains definition files for the following core targets:
  - GLSL : `genglsl`
  - OSL : `genosl`
  - MDL : `genmdl`
- Any additional target files should be added under this folder and loaded in as required.

### Target Support
- GLSL target support is for version 4.0 or higher.
- OSL target support is for version 1.9.10 or higher.
- MDL target support is for version 1.6.
- "Default" color management support includes OSL, GLSL, and MDL implementations for the following color spaces:
    - lin_rec709, g18_rec709, g22_rec709, rec709_display, acescg (lin_ap1), g22_ap1, srgb_texture
- Basic GLSL `lightshader` node definitions and implementations are provided for the following light types:
    - point, directional, spot
- Code generation does not currently support:
    - `ambientocclusion` node.
    - `arrayappend` node.
    - `curveadjust` node.
    - `displacementshader` and `volumeshader` nodes and associated operations (`add`, `multiply`, `mix`) for GLSL targets.
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2018 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Declarations of standard data types and nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Data Types                                                               -->
  <!-- ======================================================================== -->

  <typedef name="BSDF" doc="Bidirectional scattering distribution function" />
  <typedef name="EDF" doc="Emission distribution function" />
  <typedef name="VDF" doc="Volume distribution function" />

  <!-- ======================================================================== -->
  <!-- BSDF Nodes                                                               -->
  <!-- ======================================================================== -->

  <!--
    Node: <oren_nayar_diffuse_bsdf>
    A BSDF node for diffuse reflection.
  -->
  <nodedef name="ND_oren_nayar_diffuse_bsdf" node="oren_nayar_diffuse_bsdf" bsdf="R" nodegroup="pbr" doc="A BSDF node for diffuse reflections.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color" type="color3" value="0.18, 0.18, 0.18" />
    <input name="roughness" type="float" value="0.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <burley_diffuse_bsdf>
    A BSDF node for Burley diffuse reflection.
  -->
  <nodedef name="ND_burley_diffuse_bsdf" node="burley_diffuse_bsdf" bsdf="R" nodegroup="pbr" doc="A BSDF node for Burley diffuse reflections.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color" type="color3" value="0.18, 0.18, 0.18" />
    <input name="roughness" type="float" value="0.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <translucent_bsdf>
    A BSDF node for diffuse transmission.
  -->
  <nodedef name="ND_translucent_bsdf" node="translucent_bsdf" bsdf="R" nodegroup="pbr" doc="A BSDF node for pure diffuse transmission.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color" type="color3" value="1.0, 1.0, 1.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <dielectric_bsdf>
    A reflection/transmission BSDF node based on a microfacet model and a Fresnel curve for dielectrics.
  -->
  <nodedef name="ND_dielectric_bsdf" node="dielectric_bsdf" nodegroup="pbr" doc="A reflection/transmission BSDF node based on a microfacet model and a Fresnel curve for dielectrics.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="tint" type="color3" value="1.0, 1.0, 1.0" />
    <input name="ior" type="float" value="1.5" />
    <input name="roughness" type="vector2" value="0.05, 0.05" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="tangent" type="vector3" defaultgeomprop="Tworld" />
    <input name="distribution" type="string" value="ggx" enum="ggx" uniform="true" />
    <input name="scatter_mode" type="string" value="R" enum="R,T,RT" uniform="true" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <conductor_bsdf>
    A reflection BSDF node based on a microfacet model and a Fresnel curve for conductors/metals.
  -->
  <nodedef name="ND_conductor_bsdf" node="conductor_bsdf" bsdf="R" nodegroup="pbr" doc="A reflection BSDF node based on a microfacet model and a Fresnel curve for conductors/metals.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="ior" type="color3" value="0.271, 0.677, 1.316" colorspace="none" />
    <input name="extinction" type="color3" value="3.609, 2.625, 2.292" colorspace="none" />
    <input name="roughness" type="vector2" value="0.05, 0.05" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="tangent" type="vector3" defaultgeomprop="Tworld" />
    <input name="distribution" type="string" value="ggx" enum="ggx" uniform="true" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <generalized_schlick_bsdf>
    A reflection/transmission BSDF node based on a microfacet model and a generalized Schlick Fresnel curve.
  -->
  <nodedef name="ND_generalized_schlick_bsdf" node="generalized_schlick_bsdf" nodegroup="pbr" doc="A reflection/transmission BSDF node based on a microfacet model and a generalized Schlick Fresnel curve.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color0" type="color3" value="1.0, 1.0, 1.0" />
    <input name="color90" type="color3" value="1.0, 1.0, 1.0" />
    <input name="exponent" type="float" value="5.0" />
    <input name="roughness" type="vector2" value="0.05, 0.05" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="tangent" type="vector3" defaultgeomprop="Tworld" />
    <input name="distribution" type="string" value="ggx" enum="ggx" uniform="true" />
    <input name="scatter_mode" type="string" value="R" enum="R,T,RT" uniform="true" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <subsurface_bsdf>
    A subsurface scattering BSDF for true subsurface scattering.
  -->
  <nodedef name="ND_subsurface_bsdf" node="subsurface_bsdf" bsdf="R" nodegroup="pbr" doc="A subsurface scattering BSDF for true subsurface scattering.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color" type="color3" value="0.18, 0.18, 0.18" />
    <input name="radius" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="anisotropy" type="float" value="0.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <sheen_bsdf>
    A microfacet BSDF for the back-scattering properties of cloth-like materials.
  -->
  <nodedef name="ND_sheen_bsdf" node="sheen_bsdf" bsdf="R" nodegroup="pbr" doc="A microfacet BSDF for the back-scattering properties of cloth-like materials.">
    <input name="weight" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="color" type="color3" value="1.0, 1.0, 1.0" />
    <input name="roughness" type="float" value="0.3" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <thin_film_bsdf>
    Adds an iridescent thin film layer over a microfacet base BSDF.
  -->
  <nodedef name="ND_thin_film_bsdf" node="thin_film_bsdf" bsdf="R" nodegroup="pbr" doc="Adds an iridescent thin film layer over a microfacet base BSDF.">
    <input name="thickness" type="float" value="550" unittype="distance" unit="nanometer" />
    <input name="ior" type="float" value="1.5" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- EDF Nodes                                                                -->
  <!-- ======================================================================== -->

  <!--
    Node: <uniform_edf>
    An EDF node for uniform emission.
  -->
  <nodedef name="ND_uniform_edf" node="uniform_edf" nodegroup="pbr" doc="An EDF node for uniform emission.">
    <input name="color" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="EDF" />
  </nodedef>

  <!--
    Node: <conical_edf>
    Constructs an EDF emitting light inside a cone around the normal direction.
  -->
  <nodedef name="ND_conical_edf" node="conical_edf" nodegroup="pbr" doc="Constructs an EDF emitting light inside a cone around the normal direction.">
    <input name="color" type="color3" value="1.0, 1.0, 1.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="inner_angle" type="float" value="60.0" />
    <input name="outer_angle" type="float" value="0.0" />
    <output name="out" type="EDF" />
  </nodedef>

  <!--
    Node: <measured_edf>
    Constructs an EDF emitting light according to a measured IES light profile.
  -->
  <nodedef name="ND_measured_edf" node="measured_edf" nodegroup="pbr" doc="Constructs an EDF emitting light according to a measured IES light profile.">
    <input name="color" type="color3" value="1.0, 1.0, 1.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="file" type="filename" value="" uniform="true" />
    <output name="out" type="EDF" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- VDF Nodes                                                                -->
  <!-- ======================================================================== -->

  <!--
    Node: <absorption_vdf>
    Constructs a VDF for pure light absorption.
  -->
  <nodedef name="ND_absorption_vdf" node="absorption_vdf" nodegroup="pbr" doc="Constructs a VDF for pure light absorption.">
    <input name="absorption" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="VDF" />
  </nodedef>

  <!--
    Node: <anisotropic_vdf>
    Constructs a VDF scattering light for a participating medium, based on the
    Henyey-Greenstein phase function.
  -->
  <nodedef name="ND_anisotropic_vdf" node="anisotropic_vdf" nodegroup="pbr" doc="Constructs a VDF scattering light for a participating medium, based on the Henyey-Greenstein phase function.">
    <input name="absorption" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="scattering" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="anisotropy" type="float" value="0.0" />
    <output name="out" type="VDF" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Shader Nodes                                                             -->
  <!-- ======================================================================== -->

  <!--
    Node: <surface>
    Construct a surface shader from scattering and emission distribution functions.
  -->
  <nodedef name="ND_surface" node="surface" nodegroup="pbr" doc="A constructor node for the surfaceshader type.">
    <input name="bsdf" type="BSDF" value="" doc="Distribution function for surface scattering." />
    <input name="edf" type="EDF" value="" doc="Distribution function for surface emission." />
    <input name="opacity" type="float" value="1.0" doc="Surface cutout opacity" />
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!--
    Node: <thin_surface>
    Construct a surface shader from scattering and emission distribution functions for non-closed "thin" objects.
  -->
  <nodedef name="ND_thin_surface" node="thin_surface" nodegroup="pbr" doc="A constructor node for the surfaceshader type for non-closed 'thin' objects.">
    <input name="front_bsdf" type="BSDF" value="" doc="Distribution function for front-side surface scattering." />
    <input name="front_edf" type="EDF" value="" doc="Distribution function for front-side surface emission." />
    <input name="back_bsdf" type="BSDF" value="" doc="Distribution function for back-side surface scattering." />
    <input name="back_edf" type="EDF" value="" doc="Distribution function for back-side surface emission." />
    <input name="opacity" type="float" value="1.0" doc="Surface cutout opacity" />
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!--
    Node: <volume>
    Construct a volume shader describing a participating medium.
  -->
  <nodedef name="ND_volume" node="volume" nodegroup="pbr" doc="A constructor node for the volumeshader type.">
    <input name="vdf" type="VDF" value="" doc="Volume distribution function for the medium." />
    <input name="edf" type="EDF" value="" doc="Emission distribution function for the medium." />
    <output name="out" type="volumeshader" />
  </nodedef>

  <!--
    Node: <light>
    Construct a light shader from emission distribution functions.
  -->
  <nodedef name="ND_light" node="light" nodegroup="pbr" doc="A constructor node for the lightshader type.">
    <input name="edf" type="EDF" value="" doc="Distribution function for light emission." />
    <input name="intensity" type="float" value="1.0" doc="Multiplier for the light intensity" />
    <input name="exposure" type="float" value="0.0" doc="Exposure control for the light intensity" />
    <output name="out" type="lightshader" />
  </nodedef>

  <!--
    Node: <displacement>
    Construct a displacement shader.
  -->
  <nodedef name="ND_displacement_float" node="displacement" nodegroup="pbr" doc="A constructor node for the displacementshader type.">
    <input name="displacement" type="float" value="0.0" doc="Scalar displacement amount along the surface normal direction." />
    <input name="scale" type="float" value="1.0" doc="Scale factor for the displacement vector" />
    <output name="out" type="displacementshader" />
  </nodedef>
  <nodedef name="ND_displacement_vector3" node="displacement" nodegroup="pbr" doc="A constructor node for the displacementshader type.">
    <input name="displacement" type="vector3" value="0.0, 0.0, 0.0" doc="Vector displacement in (dPdu, dPdv, N) tangent/normal space." />
    <input name="scale" type="float" value="1.0" doc="Scale factor for the displacement vector" />
    <output name="out" type="displacementshader" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Utility Nodes                                                            -->
  <!-- ======================================================================== -->

  <!--
    Node: <layer>
  -->
  <nodedef name="ND_layer_bsdf" node="layer" nodegroup="pbr" defaultinput="top" doc="Layer two BSDF's with vertical layering.">
    <input name="top" type="BSDF" value="" />
    <input name="base" type="BSDF" value="" />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodedef name="ND_layer_vdf" node="layer" nodegroup="pbr" defaultinput="top" doc="Layer a BSDF over a VDF describing the interior media.">
    <input name="top" type="BSDF" value="" />
    <input name="base" type="VDF" value="" />
    <output name="out" type="BSDF" />
  </nodedef>

  <!--
    Node: <mix>
  -->
  <nodedef name="ND_mix_bsdf" node="mix" nodegroup="pbr" defaultinput="bg" doc="Mix two BSDF's according to an input mix amount.">
    <input name="fg" type="BSDF" value="" />
    <input name="bg" type="BSDF" value="" />
    <input name="mix" type="float" value="0.0" uimin="0.0" uimax="1.0" doc="Mixing weight, range [0, 1]." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodedef name="ND_mix_edf" node="mix" nodegroup="pbr" defaultinput="bg" doc="Mix two EDF's according to an input mix amount.">
    <input name="fg" type="EDF" value="" />
    <input name="bg" type="EDF" value="" />
    <input name="mix" type="float" value="0.0" uimin="0.0" uimax="1.0" doc="Mixing weight, range [0, 1]." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodedef name="ND_mix_vdf" node="mix" nodegroup="pbr" defaultinput="bg" doc="Mix two VDF's according to an input mix amount.">
    <input name="fg" type="VDF" value="" />
    <input name="bg" type="VDF" value="" />
    <input name="mix" type="float" value="0.0" uimin="0.0" uimax="1.0" doc="Mixing weight, range [0, 1]." />
    <output name="out" type="VDF" />
  </nodedef>

  <!--
    Node: <add>
  -->
  <nodedef name="ND_add_bsdf" node="add" nodegroup="pbr" defaultinput="bg" doc="A node for additive blending of BSDF's.">
    <input name="in1" type="BSDF" value="" doc="First BSDF." />
    <input name="in2" type="BSDF" value="" doc="Second BSDF." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodedef name="ND_add_edf" node="add" nodegroup="pbr" defaultinput="bg" doc="A node for additive blending of EDF's.">
    <input name="in1" type="EDF" value="" doc="First EDF." />
    <input name="in2" type="EDF" value="" doc="Second EDF." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodedef name="ND_add_vdf" node="add" nodegroup="pbr" defaultinput="bg" doc="A node for additive blending of VDF's.">
    <input name="in1" type="VDF" value="" doc="First VDF." />
    <input name="in2" type="VDF" value="" doc="Second VDF." />
    <output name="out" type="VDF" />
  </nodedef>

  <!--
    Node: <multiply>
  -->
  <nodedef name="ND_multiply_bsdfC" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of a BSDF with a weight.">
    <input name="in1" type="BSDF" value="" doc="The BSDF to scale." />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" doc="Scaling weight." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodedef name="ND_multiply_bsdfF" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of a BSDF with a weight.">
    <input name="in1" type="BSDF" value="" doc="The BSDF to scale." />
    <input name="in2" type="float" value="1.0" doc="Scaling weight." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodedef name="ND_multiply_edfC" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of an EDF with a weight.">
    <input name="in1" type="EDF" value="" doc="The EDF to scale." />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" doc="Scaling weight." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodedef name="ND_multiply_edfF" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of an EDF with a weight.">
    <input name="in1" type="EDF" value="" doc="The EDF to scale." />
    <input name="in2" type="float" value="1.0" doc="Scaling weight." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodedef name="ND_multiply_vdfC" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of an VDF with a weight.">
    <input name="in1" type="VDF" value="" doc="The VDF to scale." />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" doc="Scaling weight." />
    <output name="out" type="VDF" />
  </nodedef>
  <nodedef name="ND_multiply_vdfF" node="multiply" nodegroup="pbr" defaultinput="in1" doc="A node for adjusting the contribution of an VDF with a weight.">
    <input name="in1" type="VDF" value="" doc="The VDF to scale." />
    <input name="in2" type="float" value="1.0" doc="Scaling weight." />
    <output name="out" type="VDF" />
  </nodedef>

  <!--
    Node: <roughness_anisotropy>
    Calculates anisotropic surface roughness from a scalar roughness and anisotropy parameterization.
  -->
  <nodedef name="ND_roughness_anisotropy" node="roughness_anisotropy" nodegroup="pbr" doc="Calculates anisotropic surface roughness from a scalar roughness/anisotropy parameterization.">
    <input name="roughness" type="float" value="0.0" />
    <input name="anisotropy" type="float" value="0.0" />
    <output name="out" type="vector2" />
  </nodedef>

  <!--
    Node: <roughness_dual>
    Calculates anisotropic surface roughness from a dual surface roughness parameterization.
  -->
  <nodedef name="ND_roughness_dual" node="roughness_dual" nodegroup="pbr" doc="Calculates anisotropic surface roughness from a dual surface roughness parameterization.">
    <input name="roughness" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" />
  </nodedef>

  <!--
    Node: <glossiness_anisotropy>
    Calculates anisotropic surface roughness from a scalar glossiness and anisotropy parameterization.
  -->
  <nodedef name="ND_glossiness_anisotropy" node="glossiness_anisotropy" nodegroup="pbr" doc="Calculates anisotropic surface roughness from a scalar glossiness/anisotropy parameterization.">
    <input name="glossiness" type="float" value="1.0" uimin="0.0" uimax="1.0" />
    <input name="anisotropy" type="float" value="0.0" uimin="0.0" uimax="1.0" />
    <output name="out" type="vector2" />
  </nodedef>

  <!--
    Node: <blackbody>
    Returns the radiant emittance of a blackbody radiator with the given temperature.
  -->
  <nodedef name="ND_blackbody" node="blackbody" nodegroup="pbr" doc="Returns the radiant emittance of a blackbody radiator with the given temperature.">
    <input name="temperature" type="float" value="5000.0" />
    <output name="out" type="color3" />
  </nodedef>

  <!--
    Node: <artistic_ior>
    Converts the artistic parameterization reflectivity and edge_color to  complex IOR values.
  -->
  <nodedef name="ND_artistic_ior" node="artistic_ior" nodegroup="pbr" doc="Converts the artistic parameterization reflectivity and edge_color to  complex IOR values.">
    <input name="reflectivity" type="color3" value="0.944, 0.776, 0.373" colorspace="lin_rec709" />
    <input name="edge_color" type="color3" value="0.998, 0.981, 0.751" colorspace="lin_rec709" />
    <output name="ior" type="color3" />
    <output name="extinction" type="color3" />
  </nodedef>

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2018 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Graph definitions of standard nodes included in the MaterialX specification.
  -->

  <!-- <glossiness_anisotropy> -->
  <nodegraph name="IMP_glossiness_anisotropy" nodedef="ND_glossiness_anisotropy">
    <invert name="invert1" type="float">
      <input name="in" type="float" interfacename="glossiness" />
    </invert>
    <roughness_anisotropy name="roughness1" type="vector2">
      <input name="roughness" type="float" nodename="invert1" />
      <input name="anisotropy" type="float" interfacename="anisotropy" />
    </roughness_anisotropy>
    <output name="out" type="vector2" nodename="roughness1" />
  </nodegraph>

</materialx>
void mx_artistic_ior(color reflectivity, color edge_color, output vector ior, output vector extinction)
{
    // "Artist Friendly Metallic Fresnel", Ole Gulbrandsen, 2014
    // http://jcgt.org/published/0003/04/03/paper.pdf

    color r = clamp(reflectivity, 0.0, 0.99);
    color r_sqrt = sqrt(r);
    color n_min = (1.0 - r) / (1.0 + r);
    color n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);
    ior = mix(n_max, n_min, edge_color);

    color np1 = ior + 1.0;
    color nm1 = ior - 1.0;
    color k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);
    k2 = max(k2, 0.0);
    extinction = sqrt(k2);
}
void mx_displacement_vector3(vector displacement, float scale, output displacementshader result)
{
    result = displacement * scale;
}
void mx_roughness_dual(vector2 roughness, output vector2 result)
{
    result.x = clamp(roughness.x * roughness.x, M_FLOAT_EPS, 1.0);
    if (roughness.y < 0.0)
    {
        result.y = result.x;
    }
    else
    {
        result.y = clamp(roughness.y * roughness.y, M_FLOAT_EPS, 1.0);
    }
}
void mx_translucent_bsdf(float weight, color _color, vector _normal, output BSDF bsdf)
{
    // TODO: Subsurface closure is not supported by vanilla OSL.
    bsdf.response = _color * weight * translucent(_normal);
    bsdf.throughput = color(0.0);
}
void mx_oren_nayar_diffuse_bsdf(float weight, color _color, float roughness, normal N, output BSDF bsdf)
{
    bsdf.response = _color * weight * oren_nayar(N, roughness);
    bsdf.throughput = color(0.0);
}
#include "pbrlib/genosl/lib/mx_microfacet_specular.osl"

void mx_dielectric_bsdf(float weight, color tint, float ior, vector2 roughness, normal N, vector U, string distribution, string scatter_mode, output BSDF bsdf)
{
    if (scatter_mode == "T")
    {
        bsdf.response = tint * weight * microfacet(distribution, N, U, roughness.x, roughness.y, ior, 1);
        bsdf.throughput = tint * weight;
        return;
    }

    float NdotV = clamp(dot(N,-I), M_FLOAT_EPS, 1.0);
    float F0 = mx_ior_to_f0(ior);
    float F = mx_fresnel_schlick(NdotV, F0);

    // Calculate compensation for multiple scattering.
    // This should normally be done inside the closure
    // but since vanilla OSL doesen't support this we
    // add it here in shader code instead.
    vector2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    float comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    if (scatter_mode == "R")
    {
        bsdf.response = tint * weight * comp * microfacet(distribution, N, U, safeAlpha.x, safeAlpha.y, ior, 0);

        // Calculate throughput from directional albedo.
        float dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, ior) * comp;
        bsdf.throughput = 1.0 - dirAlbedo * weight;
    }
    else
    {
        bsdf.response = tint * weight * comp * microfacet(distribution, N, U, safeAlpha.x, safeAlpha.y, ior, 2);
        bsdf.throughput = color(1.0);
    }
}
#include "pbrlib/genosl/lib/mx_microfacet_specular.osl"

void mx_conductor_bsdf(float weight, color ior_n, color ior_k, vector2 roughness, normal N, vector U, string distribution, output BSDF bsdf)
{
    bsdf.throughput = color(0.0);

    if (weight < M_FLOAT_EPS)
    {
        bsdf.response = 0;
        return;
    }

    // Calculate conductor fresnel
    //
    // Fresnel should be based on microfacet normal
    // but we have no access to that from here, so just use
    // view direction and surface normal instead
    //
    float NdotV = fabs(dot(N,-I));
    color F = mx_fresnel_conductor(NdotV, ior_n, ior_k);

    // Calculate compensation for multiple scattering.
    // This should normally be done inside the closure
    // but since vanilla OSL doesen't support this we
    // add it here in shader code instead.
    vector2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    color comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    // Set ior to 0.0 to disable the internal dielectric fresnel
    bsdf.response = F * comp * weight * microfacet(distribution, N, U, safeAlpha.x, safeAlpha.y, 0.0, false);
}
void mx_burley_diffuse_bsdf(float weight, color reflectance, float roughness, normal N, output BSDF bsdf)
{
    // TODO: Implement properly.
    bsdf.response = reflectance * weight * oren_nayar(N, roughness);
    bsdf.throughput = color(0.0);
}
void mx_roughness_anisotropy(float roughness, float anisotropy, output vector2 result)
{
    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);
    if (anisotropy > 0.0)
    {
        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));
        result.x = min(roughness_sqr / aspect, 1.0);
        result.y = roughness_sqr * aspect;
    }
    else
    {
        result.x = roughness_sqr;
        result.y = roughness_sqr;
    }
}
void mx_surface(BSDF bsdf, EDF edf, float opacity, output surfaceshader result)
{
    float opacity_weight = clamp(opacity, 0.0, 1.0);
    result = (bsdf.response + edf) * opacity_weight + transparent() * (1.0 - opacity_weight);
}
void mx_displacement_float(float displacement, float scale, output displacementshader result)
{
    result = vector(displacement * scale);
}
#include "pbrlib/genosl/lib/mx_microfacet_specular.osl"

void mx_generalized_schlick_bsdf(float weight, color color0, color color90, float exponent, vector2 roughness, normal N, vector U, string distribution, string scatter_mode, output BSDF bsdf)
{
    //
    // TODO: We need handling of transmission for generalized schlick
    //
    if (weight < M_FLOAT_EPS || scatter_mode == "T")
    {
        bsdf.response = 0;
        bsdf.throughput = color(1.0);
        return;
    }

    float NdotV = fabs(dot(N,-I));
    color F = mx_fresnel_schlick(NdotV, color0, color90, exponent);
    vector2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);

    // Calculate compensation for multiple scattering.
    // This should normally be done inside the closure
    // but since vanilla OSL doesen't support this we
    // add it here in shader code instead.
    color comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    // Calculate directional albedo since we need
    // to attenuate the base layer according to this.
    color dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, color(1.0 / 3.0));
    bsdf.throughput = color(1.0 - avgDirAlbedo * weight);

    // Set ior to 0.0 to disable the internal dielectric fresnel
    bsdf.response = F * comp * weight * microfacet(distribution, N, U, safeAlpha.x, safeAlpha.y, 0.0, 0);
}
void mx_anisotropic_vdf(vector absorption, vector scattering, float anisotropy, output VDF vdf)
{
    // Not implemented in vanilla OSL
    vdf = 0; // volume_henyey_greenstein(color(absorption), color(scattering), color(0.0), anisotropy);
}
#include "pbrlib/genosl/lib/mx_microfacet_sheen.osl"

// TODO: Vanilla OSL doesn't have a proper sheen closure,
// so use 'diffuse' scaled by sheen directional albedo for now.
void mx_sheen_bsdf(float weight, color Ks, float roughness, vector N, output BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        bsdf.response = 0;
        bsdf.throughput = color(1.0);
        return;
    }

    // TODO: Normalization should not be needed. My suspicion is that
    // BSDF sampling of new outgoing direction in 'testrender' needs
    // to be fixed.
    vector V = normalize(-I);

    float NdotV = fabs(dot(N,V));
    float alpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float albedo = weight * mx_imageworks_sheen_dir_albedo(NdotV, alpha);
    bsdf.response = albedo * Ks * diffuse(N);
    bsdf.throughput = 1.0 - albedo;
}
{{color}} * emission()
void mx_subsurface_bsdf(float weight, color _color, vector radius, float anisotropy, vector _normal, output BSDF bsdf)
{
    // TODO: Subsurface closure is not supported by vanilla OSL.
    bsdf.response = _color * weight * translucent(_normal);
    bsdf.throughput = color(0.0);
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- <oren_nayar_diffuse_bsdf> -->
  <implementation name="IM_oren_nayar_diffuse_bsdf_genosl" nodedef="ND_oren_nayar_diffuse_bsdf" file="pbrlib/genosl/mx_oren_nayar_diffuse_bsdf.osl" function="mx_oren_nayar_diffuse_bsdf" target="genosl" />

  <!-- <burley_diffuse_bsdf> -->
  <implementation name="IM_burley_diffuse_bsdf_genosl" nodedef="ND_burley_diffuse_bsdf" file="pbrlib/genosl/mx_burley_diffuse_bsdf.osl" function="mx_burley_diffuse_bsdf" target="genosl" />

  <!-- <translucent_bsdf> -->
  <implementation name="IM_translucent_bsdf_genosl" nodedef="ND_translucent_bsdf" file="pbrlib/genosl/mx_translucent_bsdf.osl" function="mx_translucent_bsdf" target="genosl" />

  <!-- <dielectric_bsdf> -->
  <implementation name="IM_dielectric_bsdf_genosl" nodedef="ND_dielectric_bsdf" file="pbrlib/genosl/mx_dielectric_bsdf.osl" function="mx_dielectric_bsdf" target="genosl" />

  <!-- <conductor_bsdf> -->
  <implementation name="IM_conductor_bsdf_genosl" nodedef="ND_conductor_bsdf" file="pbrlib/genosl/mx_conductor_bsdf.osl" function="mx_conductor_bsdf" target="genosl" />

  <!-- <generalized_schlick_bsdf> -->
  <implementation name="IM_generalized_schlick_bsdf_genosl" nodedef="ND_generalized_schlick_bsdf" file="pbrlib/genosl/mx_generalized_schlick_bsdf.osl" function="mx_generalized_schlick_bsdf" target="genosl" />

  <!-- <subsurface_bsdf> -->
  <implementation name="IM_subsurface_bsdf_genosl" nodedef="ND_subsurface_bsdf" file="pbrlib/genosl/mx_subsurface_bsdf.osl" function="mx_subsurface_bsdf" target="genosl" />

  <!-- <sheen_bsdf> -->
  <implementation name="IM_sheen_bsdf_genosl" nodedef="ND_sheen_bsdf" file="pbrlib/genosl/mx_sheen_bsdf.osl" function="mx_sheen_bsdf" target="genosl" />

  <!-- <anisotropic_vdf> -->
  <implementation name="IM_anisotropic_vdf_genosl" nodedef="ND_anisotropic_vdf" file="pbrlib/genosl/mx_anisotropic_vdf.osl" function="mx_anisotropic_vdf" target="genosl" />

  <!-- <thin_film_bsdf> -->
  <implementation name="IM_thin_film_bsdf_genosl" nodedef="ND_thin_film_bsdf" target="genosl" />

  <!-- <uniform_edf> -->
  <implementation name="IM_uniform_edf_genosl" nodedef="ND_uniform_edf" file="pbrlib/genosl/mx_uniform_edf.inline" target="genosl" />

  <!-- <layer> -->
  <implementation name="IM_layer_bsdf_genosl" nodedef="ND_layer_bsdf" target="genosl" />
  <implementation name="IM_layer_vdf_genosl" nodedef="ND_layer_vdf" target="genosl" />

  <!-- <mix> -->
  <implementation name="IM_mix_bsdf_genosl" nodedef="ND_mix_bsdf" target="genosl" />
  <implementation name="IM_mix_edf_genosl" nodedef="ND_mix_edf" target="genosl" />

  <!-- <add> -->
  <implementation name="IM_add_bsdf_genosl" nodedef="ND_add_bsdf" target="genosl" />
  <implementation name="IM_add_edf_genosl" nodedef="ND_add_edf" target="genosl" />

  <!-- <multiply> -->
  <implementation name="IM_multiply_bsdfC_genosl" nodedef="ND_multiply_bsdfC" target="genosl" />
  <implementation name="IM_multiply_bsdfF_genosl" nodedef="ND_multiply_bsdfF" target="genosl" />
  <implementation name="IM_multiply_edfC_genosl" nodedef="ND_multiply_edfC" target="genosl" />
  <implementation name="IM_multiply_edfF_genosl" nodedef="ND_multiply_edfF" target="genosl" />

  <!-- <surface> -->
  <implementation name="IM_surface_genosl" nodedef="ND_surface" file="pbrlib/genosl/mx_surface.osl" function="mx_surface" target="genosl" />

  <!-- <displacement> -->
  <implementation name="IM_displacement_float_genosl" nodedef="ND_displacement_float" file="pbrlib/genosl/mx_displacement_float.osl" function="mx_displacement_float" target="genosl" />
  <implementation name="IM_displacement_vector3_genosl" nodedef="ND_displacement_vector3" file="pbrlib/genosl/mx_displacement_vector3.osl" function="mx_displacement_vector3" target="genosl" />

  <!-- <roughness_anisotropy> -->
  <implementation name="IM_roughness_anisotropy_genosl" nodedef="ND_roughness_anisotropy" file="pbrlib/genosl/mx_roughness_anisotropy.osl" function="mx_roughness_anisotropy" target="genosl" />

  <!-- <roughness_dual> -->
  <implementation name="IM_roughness_dual_genosl" nodedef="ND_roughness_dual" file="pbrlib/genosl/mx_roughness_dual.osl" function="mx_roughness_dual" target="genosl" />

  <!-- <artistic_ior> -->
  <implementation name="IM_artistic_ior_genosl" nodedef="ND_artistic_ior" file="pbrlib/genosl/mx_artistic_ior.osl" function="mx_artistic_ior" target="genosl" />

</materialx>
#include "pbrlib/genosl/lib/mx_microfacet.osl"

// Compute the average of an anisotropic alpha pair.
float mx_average_alpha(vector2 alpha)
{
    return sqrt(alpha.x * alpha.y);
}

// Convert a real-valued index of refraction to normal-incidence reflectivity.
float mx_ior_to_f0(float ior)
{
    return mx_square((ior - 1.0) / (ior + 1.0));
}

// Rational quadratic fit to Monte Carlo data for GGX directional albedo.
color mx_ggx_dir_albedo(float NdotV, float alpha, color F0, color F90)
{
    float x = NdotV;
    float y = alpha;
    float x2 = mx_square(x);
    float y2 = mx_square(y);
    vector4 r = vector4(0.1003, 0.9345, 1.0, 1.0) +
                vector4(-0.6303, -2.323, -1.765, 0.2281) * x +
                vector4(9.748, 2.229, 8.263, 15.94) * y +
                vector4(-2.038, -3.748, 11.53, -55.83) * x * y +
                vector4(29.34, 1.424, 28.96, 13.08) * x2 +
                vector4(-8.245, -0.7684, -7.507, 41.26) * y2 +
                vector4(-26.44, 1.436, -36.11, 54.9) * x2 * y +
                vector4(19.99, 0.2913, 15.86, 300.2) * x * y2 +
                vector4(-5.448, 0.6286, 33.37, -285.1) * x2 * y2;
    vector2 AB = vector2(r.x, r.y) / vector2(r.z, r.w);
    AB.x = clamp(AB.x, 0.0, 1.0);
    AB.y = clamp(AB.y, 0.0, 1.0);
    return F0 * AB.x + F90 * AB.y;
}

float mx_ggx_dir_albedo(float NdotV, float alpha, float F0, float F90)
{
    color result = mx_ggx_dir_albedo(NdotV, alpha, color(F0), color(F90));
    return result[0];
}

float mx_ggx_dir_albedo(float NdotV, float alpha, float ior)
{
    color result = mx_ggx_dir_albedo(NdotV, alpha, color(mx_ior_to_f0(ior)), color(1.0));
    return result[0];
}

// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf
// Equations 14 and 16
color mx_ggx_energy_compensation(float NdotV, float alpha, color Fss)
{
    float Ess = mx_ggx_dir_albedo(NdotV, alpha, 1.0, 1.0);
    return 1.0 + Fss * (1.0 - Ess) / Ess;
}

float mx_ggx_energy_compensation(float NdotV, float alpha, float Fss)
{
    color result = mx_ggx_energy_compensation(NdotV, alpha, color(Fss));
    return result[0];
}
#include "pbrlib/genosl/lib/mx_microfacet.osl"

// Rational curve fit approximation for the directional albedo of Imageworks sheen.
float mx_imageworks_sheen_dir_albedo_analytic(float NdotV, float roughness)
{
    float a = 5.25248 - 7.66024 * NdotV + 14.26377 * roughness;
    float b = 1.0 + 30.66449 * NdotV + 32.53420 * roughness;
    return a / b;
}

float mx_imageworks_sheen_dir_albedo(float NdotV, float roughness)
{
    float dirAlbedo = mx_imageworks_sheen_dir_albedo_analytic(NdotV, roughness);
    return clamp(dirAlbedo, 0.0, 1.0);
}
float mx_square(float x)
{
    return x*x;
}

vector2 mx_square(vector2 x)
{
    return x*x;
}

vector mx_square(vector x)
{
    return x*x;
}

vector4 mx_square(vector4 x)
{
    return x*x;
}

float mx_pow5(float x)
{
    return mx_square(mx_square(x)) * x;
}

color mx_fresnel_conductor(float cosTheta, vector n, vector k)
{
   float c2 = cosTheta*cosTheta;
   vector n2_k2 = n*n + k*k;
   vector nc2 = 2.0 * n * cosTheta;

   vector rs_a = n2_k2 + c2;
   vector rp_a = n2_k2 * c2 + 1.0;
   vector rs = (rs_a - nc2) / (rs_a + nc2);
   vector rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5 * (rs + rp);
}

// Standard Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}
color mx_fresnel_schlick(float cosTheta, color F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}

// Generalized Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0, float F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}
color mx_fresnel_schlick(float cosTheta, color F0, color F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}

// Generalized Schlick Fresnel with a variable exponent
color mx_fresnel_schlick(float cosTheta, float f0, float f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}
color mx_fresnel_schlick(float cosTheta, color f0, color f90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(f0, f90, pow(x, exponent));
}
void mx_roughness_anisotropy(float roughness, float anisotropy, out vec2 result)
{
    float roughness_sqr = clamp(roughness*roughness, M_FLOAT_EPS, 1.0);
    if (anisotropy > 0.0)
    {
        float aspect = sqrt(1.0 - clamp(anisotropy, 0.0, 0.98));
        result.x = min(roughness_sqr / aspect, 1.0);
        result.y = roughness_sqr * aspect;
    }
    else
    {
        result.x = roughness_sqr;
        result.y = roughness_sqr;
    }
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- <oren_nayar_diffuse_bsdf> -->
  <implementation name="IM_oren_nayar_diffuse_bsdf_genglsl" nodedef="ND_oren_nayar_diffuse_bsdf" file="pbrlib/genglsl/mx_oren_nayar_diffuse_bsdf.glsl" function="mx_oren_nayar_diffuse_bsdf" target="genglsl" />

  <!-- <burley_diffuse_bsdf> -->
  <implementation name="IM_burley_diffuse_bsdf_genglsl" nodedef="ND_burley_diffuse_bsdf" file="pbrlib/genglsl/mx_burley_diffuse_bsdf.glsl" function="mx_burley_diffuse_bsdf" target="genglsl" />

  <!-- <translucent_bsdf> -->
  <implementation name="IM_translucent_bsdf_genglsl" nodedef="ND_translucent_bsdf" file="pbrlib/genglsl/mx_translucent_bsdf.glsl" function="mx_translucent_bsdf" target="genglsl" />

  <!-- <dielectric_bsdf> -->
  <implementation name="IM_dielectric_bsdf_genglsl" nodedef="ND_dielectric_bsdf" file="pbrlib/genglsl/mx_dielectric_bsdf.glsl" function="mx_dielectric_bsdf" target="genglsl" />

  <!-- <conductor_bsdf> -->
  <implementation name="IM_conductor_bsdf_genglsl" nodedef="ND_conductor_bsdf" file="pbrlib/genglsl/mx_conductor_bsdf.glsl" function="mx_conductor_bsdf" target="genglsl" />

  <!-- <generalized_schlick_bsdf> -->
  <implementation name="IM_generalized_schlick_bsdf_genglsl" nodedef="ND_generalized_schlick_bsdf" file="pbrlib/genglsl/mx_generalized_schlick_bsdf.glsl" function="mx_generalized_schlick_bsdf" target="genglsl" />

  <!-- <subsurface_bsdf> -->
  <implementation name="IM_subsurface_bsdf_genglsl" nodedef="ND_subsurface_bsdf" file="pbrlib/genglsl/mx_subsurface_bsdf.glsl" function="mx_subsurface_bsdf" target="genglsl" />

  <!-- <sheen_bsdf> -->
  <implementation name="IM_sheen_bsdf_genglsl" nodedef="ND_sheen_bsdf" file="pbrlib/genglsl/mx_sheen_bsdf.glsl" function="mx_sheen_bsdf" target="genglsl" />

  <!-- <anisotropic_vdf> -->
  <implementation name="IM_anisotropic_vdf_genglsl" nodedef="ND_anisotropic_vdf" file="pbrlib/genglsl/mx_anisotropic_vdf.glsl" function="mx_anisotropic_vdf" target="genglsl" />

  <!-- <thin_film_bsdf> -->
  <implementation name="IM_thin_film_bsdf_genglsl" nodedef="ND_thin_film_bsdf" target="genglsl" />

  <!-- <layer> -->
  <implementation name="IM_layer_bsdf_genglsl" nodedef="ND_layer_bsdf" target="genglsl" />
  <implementation name="IM_layer_vdf_genglsl" nodedef="ND_layer_vdf" target="genglsl" />

  <!-- <mix> -->
  <implementation name="IM_mix_bsdf_genglsl" nodedef="ND_mix_bsdf" target="genglsl" />
  <implementation name="IM_mix_edf_genglsl" nodedef="ND_mix_edf" target="genglsl" />

  <!-- <add> -->
  <implementation name="IM_add_bsdf_genglsl" nodedef="ND_add_bsdf" target="genglsl" />
  <implementation name="IM_add_edf_genglsl" nodedef="ND_add_edf" target="genglsl" />

  <!-- <multiply> -->
  <implementation name="IM_multiply_bsdfC_genglsl" nodedef="ND_multiply_bsdfC" target="genglsl" />
  <implementation name="IM_multiply_bsdfF_genglsl" nodedef="ND_multiply_bsdfF" target="genglsl" />
  <implementation name="IM_multiply_edfC_genglsl" nodedef="ND_multiply_edfC" target="genglsl" />
  <implementation name="IM_multiply_edfF_genglsl" nodedef="ND_multiply_edfF" target="genglsl" />

  <!-- <uniform_edf> -->
  <implementation name="IM_uniform_edf_genglsl" nodedef="ND_uniform_edf" file="pbrlib/genglsl/mx_uniform_edf.glsl" function="mx_uniform_edf" target="genglsl" />

  <!-- <surface> -->
  <implementation name="IM_surface_genglsl" nodedef="ND_surface" target="genglsl" />

  <!-- <light> -->
  <implementation name="IM_light_genglsl" nodedef="ND_light" target="genglsl" />

  <!-- <roughness_anisotropy> -->
  <implementation name="IM_roughness_anisotropy_genglsl" nodedef="ND_roughness_anisotropy" file="pbrlib/genglsl/mx_roughness_anisotropy.glsl" function="mx_roughness_anisotropy" target="genglsl" />

  <!-- <roughness_dual> -->
  <implementation name="IM_roughness_dual_genglsl" nodedef="ND_roughness_dual" file="pbrlib/genglsl/mx_roughness_dual.glsl" function="mx_roughness_dual" target="genglsl" />

  <!-- <artistic_ior> -->
  <implementation name="IM_artistic_ior_genglsl" nodedef="ND_artistic_ior" file="pbrlib/genglsl/mx_artistic_ior.glsl" function="mx_artistic_ior" target="genglsl" />

</materialx>
void mx_add_edf(vec3 N, vec3 L, EDF in1, EDF in2, out EDF result)
{
    result = in1 + in2;
}
// We fake diffuse transmission by using diffuse reflection from the opposite side.
// So this BTDF is really a BRDF.
void mx_translucent_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    // Invert normal since we're transmitting light from the other side
    float NdotL = dot(L, -normal);
    if (NdotL <= 0.0 || weight < M_FLOAT_EPS)
    {
        return;
    }

    bsdf.response = color * weight * NdotL * M_PI_INV;
}

void mx_translucent_bsdf_indirect(vec3 V, float weight, vec3 color, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    // Invert normal since we're transmitting light from the other side
    vec3 Li = mx_environment_irradiance(-normal);
    bsdf.response = Li * color * weight;
}
void mx_uniform_edf(vec3 N, vec3 L, vec3 color, out EDF result)
{
    result = color;
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

void mx_generalized_schlick_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    vec3 Y = normalize(cross(N, X));
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd = mx_init_fresnel_schlick(color0, color90, exponent);
    vec3  F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * occlusion * weight / (4.0 * NdotV);
}

void mx_generalized_schlick_bsdf_transmission(vec3 V, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (scatter_mode == 1)
    {
        bsdf.response = color0 * weight;
        bsdf.throughput = bsdf.response;
        return;
    }

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd = mx_init_fresnel_schlick(color0, color90, exponent);
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    bsdf.response = (scatter_mode == 2) ? color0 * weight * bsdf.throughput : vec3(0.0);
}

void mx_generalized_schlick_bsdf_indirect(vec3 V, float weight, vec3 color0, vec3 color90, float exponent, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd = mx_init_fresnel_schlick(color0, color90, exponent);
    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, color0, color90) * comp;
    float avgDirAlbedo = dot(dirAlbedo, vec3(1.0 / 3.0));
    bsdf.throughput = vec3(1.0 - avgDirAlbedo * weight);

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);
    bsdf.response = Li * comp * weight;
}
void mx_anisotropic_vdf(vec3 absorption, vec3 scattering, float anisotropy, inout BSDF bsdf)
{
    // TODO: Add some approximation for volumetric light absorption.
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

void mx_dielectric_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    vec3 Y = normalize(cross(N, X));
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd;
    if (bsdf.thickness > 0.0)
    { 
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    }
    else
    {
         fd = mx_init_fresnel_dielectric(ior);
    }
    vec3  F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * tint * occlusion * weight / (4.0 * NdotV);
}

void mx_dielectric_bsdf_transmission(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (scatter_mode == 1)
    {
        bsdf.response = tint * weight;
        bsdf.throughput = bsdf.response;
        return;
    }

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_dielectric(ior);

    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    bsdf.response = (scatter_mode == 2) ? tint * weight * bsdf.throughput : vec3(0.0);
}

void mx_dielectric_bsdf_indirect(vec3 V, float weight, vec3 tint, float ior, vec2 roughness, vec3 N, vec3 X, int distribution, int scatter_mode, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_dielectric_airy(ior, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_dielectric(ior);

    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    float F0 = mx_ior_to_f0(ior);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 dirAlbedo = mx_ggx_dir_albedo(NdotV, avgAlpha, F0, 1.0) * comp;
    bsdf.throughput = 1.0 - dirAlbedo * weight;

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);
    bsdf.response = Li * tint * comp * weight;
}
void mx_artistic_ior(vec3 reflectivity, vec3 edge_color, out vec3 ior, out vec3 extinction)
{
    // "Artist Friendly Metallic Fresnel", Ole Gulbrandsen, 2014
    // http://jcgt.org/published/0003/04/03/paper.pdf

    vec3 r = clamp(reflectivity, 0.0, 0.99);
    vec3 r_sqrt = sqrt(r);
    vec3 n_min = (1.0 - r) / (1.0 + r);
    vec3 n_max = (1.0 + r_sqrt) / (1.0 - r_sqrt);
    ior = mix(n_max, n_min, edge_color);

    vec3 np1 = ior + 1.0;
    vec3 nm1 = ior - 1.0;
    vec3 k2 = (np1*np1 * r - nm1*nm1) / (1.0 - r);
    k2 = max(k2, 0.0);
    extinction = sqrt(k2);
}
#include "pbrlib/genglsl/lib/mx_microfacet_diffuse.glsl"

void mx_subsurface_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    vec3 sss = mx_subsurface_scattering_approx(normal, L, P, color, radius);
    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);
    float visibleOcclusion = 1.0 - NdotL * (1.0 - occlusion);
    bsdf.response = sss * visibleOcclusion * weight;
}

void mx_subsurface_bsdf_indirect(vec3 V, float weight, vec3 color, vec3 radius, float anisotropy, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    // For now, we render indirect subsurface as simple indirect diffuse.
    vec3 Li = mx_environment_irradiance(normal);
    bsdf.response = Li * color * weight;
}
#include "pbrlib/genglsl/lib/mx_microfacet_sheen.glsl"

void mx_sheen_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 N, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float NdotH = clamp(dot(N, H), M_FLOAT_EPS, 1.0);

    vec3 fr = color * mx_imageworks_sheen_brdf(NdotL, NdotV, NdotH, roughness);
    float dirAlbedo = mx_imageworks_sheen_dir_albedo(NdotV, roughness);
    bsdf.throughput = vec3(1.0 - dirAlbedo * weight);

    // We need to include NdotL from the light integral here
    // as in this case it's not cancelled out by the BRDF denominator.
    bsdf.response = fr * NdotL * occlusion * weight;
}

void mx_sheen_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 N, inout BSDF bsdf)
{
    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    float dirAlbedo = mx_imageworks_sheen_dir_albedo(NdotV, roughness);
    bsdf.throughput = vec3(1.0 - dirAlbedo * weight);

    vec3 Li = mx_environment_irradiance(N);
    bsdf.response = Li * color * dirAlbedo * weight;
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

void mx_conductor_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, vec3 N, vec3 X, int distribution, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    vec3 Y = normalize(cross(N, X));
    vec3 H = normalize(L + V);

    float NdotL = clamp(dot(N, L), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 Ht = vec3(dot(H, X), dot(H, Y), dot(H, N));

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_conductor_airy(ior_n, ior_k, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_conductor(ior_n, ior_k);

    vec3 F = mx_compute_fresnel(VdotH, fd);
    float D = mx_ggx_NDF(Ht, safeAlpha);
    float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    // Note: NdotL is cancelled out
    bsdf.response = D * F * G * comp * occlusion * weight / (4.0 * NdotV);
}

void mx_conductor_bsdf_indirect(vec3 V, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness, vec3 N, vec3 X, int distribution, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    N = mx_forward_facing_normal(N, V);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    FresnelData fd;
    if (bsdf.thickness > 0.0)
        fd = mx_init_fresnel_conductor_airy(ior_n, ior_k, bsdf.thickness, bsdf.ior);
    else
        fd = mx_init_fresnel_conductor(ior_n, ior_k);

    vec3 F = mx_compute_fresnel(NdotV, fd);

    vec2 safeAlpha = clamp(roughness, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(safeAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);

    vec3 Li = mx_environment_radiance(N, V, X, safeAlpha, distribution, fd);

    bsdf.response = Li * comp * weight;
}
void mx_roughness_dual(vec2 roughness, out vec2 result)
{
    if (roughness.y < 0.0)
    {
        roughness.y = roughness.x;
    }
    result.x = clamp(roughness.x * roughness.x, M_FLOAT_EPS, 1.0);
    result.y = clamp(roughness.y * roughness.y, M_FLOAT_EPS, 1.0);
}
#include "pbrlib/genglsl/lib/mx_microfacet_diffuse.glsl"

void mx_oren_nayar_diffuse_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);

    bsdf.response = color * occlusion * weight * NdotL * M_PI_INV;
    if (roughness > 0.0)
    {
        bsdf.response *= mx_oren_nayar_diffuse(L, V, normal, NdotL, roughness);
    }
}

void mx_oren_nayar_diffuse_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    vec3 Li = mx_environment_irradiance(normal);
    bsdf.response = Li * color * weight;
}
#include "pbrlib/genglsl/lib/mx_microfacet_diffuse.glsl"

void mx_burley_diffuse_bsdf_reflection(vec3 L, vec3 V, vec3 P, float occlusion, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    float NdotL = clamp(dot(normal, L), M_FLOAT_EPS, 1.0);

    bsdf.response = color * occlusion * weight * NdotL * M_PI_INV;
    bsdf.response *= mx_burley_diffuse(L, V, normal, NdotL, roughness);
}

void mx_burley_diffuse_bsdf_indirect(vec3 V, float weight, vec3 color, float roughness, vec3 normal, inout BSDF bsdf)
{
    bsdf.throughput = vec3(0.0);

    if (weight < M_FLOAT_EPS)
    {
        return;
    }

    normal = mx_forward_facing_normal(normal, V);

    float NdotV = clamp(dot(normal, V), M_FLOAT_EPS, 1.0);

    vec3 Li = mx_environment_irradiance(normal) *
              mx_burley_diffuse_dir_albedo(NdotV, roughness);
    bsdf.response = Li * color * weight;
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch20.html
// Section 20.4 Equation 13
float mx_latlong_compute_lod(vec3 dir, float pdf, float maxMipLevel, int envSamples)
{
    const float MIP_LEVEL_OFFSET = 1.5;
    float effectiveMaxMipLevel = maxMipLevel - MIP_LEVEL_OFFSET;
    float distortion = sqrt(1.0 - mx_square(dir.y));
    return max(effectiveMaxMipLevel - 0.5 * log2(float(envSamples) * pdf * distortion), 0.0);
}

vec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd)
{
    // Generate tangent frame.
    vec3 Y = normalize(cross(N, X));
    X = cross(Y, N);
    mat3 tangentToWorld = mat3(X, Y, N);

    // Transform the view vector to tangent space.
    V = vec3(dot(V, X), dot(V, Y), dot(V, N));

    // Compute derived properties.
    float NdotV = clamp(V.z, M_FLOAT_EPS, 1.0);
    float avgAlpha = mx_average_alpha(alpha);
    
    // Integrate outgoing radiance using filtered importance sampling.
    // http://cgg.mff.cuni.cz/~jaroslav/papers/2008-egsr-fis/2008-egsr-fis-final-embedded.pdf
    vec3 radiance = vec3(0.0);
    int envRadianceSamples = $envRadianceSamples;
    for (int i = 0; i < envRadianceSamples; i++)
    {
        vec2 Xi = mx_spherical_fibonacci(i, envRadianceSamples);

        // Compute the half vector and incoming light direction.
        vec3 H = mx_ggx_importance_sample_NDF(Xi, alpha);
        vec3 L = -reflect(V, H);
        
        // Compute dot products for this sample.
        float NdotH = clamp(H.z, M_FLOAT_EPS, 1.0);
        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);
        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);
        float LdotH = VdotH;

        // Sample the environment light from the given direction.
        vec3 Lw = tangentToWorld * L;
        float pdf = mx_ggx_PDF(H, LdotH, alpha);
        float lod = mx_latlong_compute_lod(Lw, pdf, float($envRadianceMips - 1), envRadianceSamples);
        vec3 sampleColor = mx_latlong_map_lookup(Lw, $envMatrix, lod, $envRadiance);

        // Compute the Fresnel term.
        vec3 F = mx_compute_fresnel(VdotH, fd);

        // Compute the geometric term.
        float G = mx_ggx_smith_G2(NdotL, NdotV, avgAlpha);

        // Add the radiance contribution of this sample.
        // From https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
        //   incidentLight = sampleColor * NdotL
        //   microfacetSpecular = D * F * G / (4 * NdotL * NdotV)
        //   pdf = D * NdotH / (4 * VdotH)
        //   radiance = incidentLight * microfacetSpecular / pdf
        radiance += sampleColor * F * G * VdotH / (NdotV * NdotH);
    }

    // Normalize and return the final radiance.
    radiance /= float(envRadianceSamples);
    return radiance;
}

vec3 mx_environment_irradiance(vec3 N)
{
    return mx_latlong_map_lookup(N, $envMatrix, 0.0, $envIrradiance);
}
#include "pbrlib/genglsl/lib/mx_microfacet.glsl"

// Fresnel model options.
const int FRESNEL_MODEL_DIELECTRIC = 0;
const int FRESNEL_MODEL_CONDUCTOR = 1;
const int FRESNEL_MODEL_SCHLICK = 2;
const int FRESNEL_MODEL_AIRY = 3;

// XYZ to CIE 1931 RGB color space (using neutral E illuminant)
const mat3 XYZ_TO_RGB = mat3(2.3706743, -0.5138850, 0.0052982, -0.9000405, 1.4253036, -0.0146949, -0.4706338, 0.0885814, 1.0093968);

// Parameters for Fresnel calculations.
struct FresnelData
{
    int model;

    // Physical Fresnel
    vec3 ior;
    vec3 extinction;

    // Generalized Schlick Fresnel
    vec3 F0;
    vec3 F90;
    float exponent;

    // Thin film
    float tf_thickness;
    float tf_ior;
};

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.2 Equation 13
float mx_ggx_NDF(vec3 H, vec2 alpha)
{
    vec2 He = H.xy / alpha;
    float denom = dot(He, He) + mx_square(H.z);
    return 1.0 / (M_PI * alpha.x * alpha.y * mx_square(denom));
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.1 Equation 3
float mx_ggx_PDF(vec3 H, float LdotH, vec2 alpha)
{
    float NdotH = H.z;
    return mx_ggx_NDF(H, alpha) * NdotH / (4.0 * LdotH);
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Appendix B.2 Equation 15
vec3 mx_ggx_importance_sample_NDF(vec2 Xi, vec2 alpha)
{
    float phi = 2.0 * M_PI * Xi.x;
    float tanTheta = sqrt(Xi.y / (1.0 - Xi.y));
    vec3 H = vec3(tanTheta * alpha.x * cos(phi),
                  tanTheta * alpha.y * sin(phi),
                  1.0);
    return normalize(H);
}

// http://jcgt.org/published/0007/04/01/paper.pdf
// Appendix A Listing 1
vec3 mx_ggx_importance_sample_VNDF(vec2 Xi, vec3 V, vec2 alpha)
{
    // Transform the view direction to the hemisphere configuration.
    V = normalize(vec3(V.xy * alpha, V.z));

    // Construct an orthonormal basis from the view direction.
    float len = length(V.xy);
    vec3 T1 = (len > 0.0) ? vec3(-V.y, V.x, 0.0) / len : vec3(1.0, 0.0, 0.0);
    vec3 T2 = cross(V, T1);

    // Parameterization of the projected area.
    float r = sqrt(Xi.y);
    float phi = 2.0 * M_PI * Xi.x;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + V.z);
    t2 = (1.0 - s) * sqrt(1.0 - mx_square(t1)) + s * t2;

    // Reprojection onto hemisphere.
    vec3 H = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - mx_square(t1) - mx_square(t2))) * V;

    // Transform the microfacet normal back to the ellipsoid configuration.
    H = normalize(vec3(H.xy * alpha, max(H.z, 0.0)));

    return H;
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
// Equation 34
float mx_ggx_smith_G1(float cosTheta, float alpha)
{
    float cosTheta2 = mx_square(cosTheta);
    float tanTheta2 = (1.0 - cosTheta2) / cosTheta2;
    return 2.0 / (1.0 + sqrt(1.0 + mx_square(alpha) * tanTheta2));
}

// Height-correlated Smith masking-shadowing
// http://jcgt.org/published/0003/02/03/paper.pdf
// Equations 72 and 99
float mx_ggx_smith_G2(float NdotL, float NdotV, float alpha)
{
    float alpha2 = mx_square(alpha);
    float lambdaL = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotL));
    float lambdaV = sqrt(alpha2 + (1.0 - alpha2) * mx_square(NdotV));
    return 2.0 / (lambdaL / NdotL + lambdaV / NdotV);
}

// Rational quadratic fit to Monte Carlo data for GGX directional albedo.
vec3 mx_ggx_dir_albedo_analytic(float NdotV, float alpha, vec3 F0, vec3 F90)
{
    float x = NdotV;
    float y = alpha;
    float x2 = mx_square(x);
    float y2 = mx_square(y);
    vec4 r = vec4(0.1003, 0.9345, 1.0, 1.0) +
             vec4(-0.6303, -2.323, -1.765, 0.2281) * x +
             vec4(9.748, 2.229, 8.263, 15.94) * y +
             vec4(-2.038, -3.748, 11.53, -55.83) * x * y +
             vec4(29.34, 1.424, 28.96, 13.08) * x2 +
             vec4(-8.245, -0.7684, -7.507, 41.26) * y2 +
             vec4(-26.44, 1.436, -36.11, 54.9) * x2 * y +
             vec4(19.99, 0.2913, 15.86, 300.2) * x * y2 +
             vec4(-5.448, 0.6286, 33.37, -285.1) * x2 * y2;
    vec2 AB = clamp(r.xy / r.zw, 0.0, 1.0);
    return F0 * AB.x + F90 * AB.y;
}

vec3 mx_ggx_dir_albedo_table_lookup(float NdotV, float alpha, vec3 F0, vec3 F90)
{
#if DIRECTIONAL_ALBEDO_METHOD == 1
    if (textureSize($albedoTable, 0).x > 1)
    {
        vec2 AB = texture($albedoTable, vec2(NdotV, alpha)).rg;
        return F0 * AB.x + F90 * AB.y;
    }
#endif
    return vec3(0.0);
}

// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
vec3 mx_ggx_dir_albedo_monte_carlo(float NdotV, float alpha, vec3 F0, vec3 F90)
{
    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);
    vec3 V = vec3(sqrt(1.0 - mx_square(NdotV)), 0, NdotV);

    vec2 AB = vec2(0.0);
    const int SAMPLE_COUNT = 64;
    for (int i = 0; i < SAMPLE_COUNT; i++)
    {
        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);

        // Compute the half vector and incoming light direction.
        vec3 H = mx_ggx_importance_sample_VNDF(Xi, V, vec2(alpha));
        vec3 L = -reflect(V, H);
        
        // Compute dot products for this sample.
        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);
        float VdotH = clamp(dot(V, H), M_FLOAT_EPS, 1.0);

        // Compute the Fresnel term.
        float Fc = mx_fresnel_schlick(VdotH, 0.0, 1.0);

        // Compute the per-sample geometric term.
        // https://hal.inria.fr/hal-00996995v2/document, Algorithm 2
        float G2 = mx_ggx_smith_G2(NdotL, NdotV, alpha);
        
        // Add the contribution of this sample.
        AB += vec2(G2 * (1.0 - Fc), G2 * Fc);
    }

    // Apply the global component of the geometric term and normalize.
    AB /= mx_ggx_smith_G1(NdotV, alpha) * float(SAMPLE_COUNT);

    // Return the final directional albedo.
    return F0 * AB.x + F90 * AB.y;
}

vec3 mx_ggx_dir_albedo(float NdotV, float alpha, vec3 F0, vec3 F90)
{
#if DIRECTIONAL_ALBEDO_METHOD == 0
    return mx_ggx_dir_albedo_analytic(NdotV, alpha, F0, F90);
#elif DIRECTIONAL_ALBEDO_METHOD == 1
    return mx_ggx_dir_albedo_table_lookup(NdotV, alpha, F0, F90);
#else
    return mx_ggx_dir_albedo_monte_carlo(NdotV, alpha, F0, F90);
#endif
}

float mx_ggx_dir_albedo(float NdotV, float alpha, float F0, float F90)
{
    return mx_ggx_dir_albedo(NdotV, alpha, vec3(F0), vec3(F90)).x;
}

// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf
// Equations 14 and 16
vec3 mx_ggx_energy_compensation(float NdotV, float alpha, vec3 Fss)
{
    float Ess = mx_ggx_dir_albedo(NdotV, alpha, 1.0, 1.0);
    return 1.0 + Fss * (1.0 - Ess) / Ess;
}

float mx_ggx_energy_compensation(float NdotV, float alpha, float Fss)
{
    return mx_ggx_energy_compensation(NdotV, alpha, vec3(Fss)).x;
}

// Compute the average of an anisotropic alpha pair.
float mx_average_alpha(vec2 alpha)
{
    return sqrt(alpha.x * alpha.y);
}

// Convert a real-valued index of refraction to normal-incidence reflectivity.
float mx_ior_to_f0(float ior)
{
    return mx_square((ior - 1.0) / (ior + 1.0));
}

// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/
float mx_fresnel_dielectric(float cosTheta, float ior)
{
    if (cosTheta < 0.0)
        return 1.0;

    float g =  ior*ior + cosTheta*cosTheta - 1.0;
    // Check for total internal reflection
    if (g < 0.0)
        return 1.0;

    g = sqrt(g);
    float gmc = g - cosTheta;
    float gpc = g + cosTheta;
    float x = gmc / gpc;
    float y = (gpc * cosTheta - 1.0) / (gmc * cosTheta + 1.0);
    return 0.5 * x * x * (1.0 + y * y);
}

// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/
vec3 mx_fresnel_conductor(float cosTheta, vec3 n, vec3 k)
{
    cosTheta = clamp(cosTheta, 0.0, 1.0);
    float cosTheta2 = cosTheta * cosTheta;
    float sinTheta2 = 1.0 - cosTheta2;
    vec3 n2 = n * n;
    vec3 k2 = k * k;

    vec3 t0 = n2 - k2 - sinTheta2;
    vec3 a2plusb2 = sqrt(t0 * t0 + 4.0 * n2 * k2);
    vec3 t1 = a2plusb2 + cosTheta2;
    vec3 a = sqrt(max(0.5 * (a2plusb2 + t0), 0.0));
    vec3 t2 = 2.0 * a * cosTheta;
    vec3 rs = (t1 - t2) / (t1 + t2);

    vec3 t3 = cosTheta2 * a2plusb2 + sinTheta2 * sinTheta2;
    vec3 t4 = t2 * sinTheta2;
    vec3 rp = rs * (t3 - t4) / (t3 + t4);

    return 0.5 * (rp + rs);
}

// Fresnel for dielectric/dielectric interface and polarized light.
void mx_fresnel_dielectric_polarized(float cosTheta, float n1, float n2, out vec2 F, out vec2 phi)
{
    float eta2 = mx_square(n1 / n2);
    float st2 = 1.0 - cosTheta*cosTheta;

    // Check for total internal reflection
    if(eta2*st2 > 1.0)
    {
        F = vec2(1.0);
        float s = sqrt(st2 - 1.0/eta2) / cosTheta;
        phi = 2.0 * atan(vec2(-eta2 * s, -s));
        return;
    }

    float cosTheta_t = sqrt(1.0 - eta2 * st2);
    vec2 r = vec2((n2*cosTheta - n1*cosTheta_t) / (n2*cosTheta + n1*cosTheta_t),
                  (n1*cosTheta - n2*cosTheta_t) / (n1*cosTheta + n2*cosTheta_t));
    F = mx_square(r);
    phi.x = (r.x < 0.0) ? M_PI : 0.0;
    phi.y = (r.y < 0.0) ? M_PI : 0.0;
}

// Fresnel for dielectric/conductor interface and polarized light.
// TODO: Optimize this functions and support wavelength dependent complex refraction index.
void mx_fresnel_conductor_polarized(float cosTheta, float n1, float n2, float k, out vec2 F, out vec2 phi)
{
    if (k == 0.0)
    {
        // Use dielectric formula to avoid numerical issues
        mx_fresnel_dielectric_polarized(cosTheta, n1, n2, F, phi);
        return;
    }

    float A = mx_square(n2) * (1.0 - mx_square(k)) - mx_square(n1) * (1.0 - mx_square(cosTheta));
    float B = sqrt(mx_square(A) + mx_square(2.0 * mx_square(n2) * k));
    float U = sqrt((A+B) / 2.0);
    float V = sqrt((B-A) / 2.0);

    F.y = (mx_square(n1*cosTheta - U) + mx_square(V)) / (mx_square(n1*cosTheta + U) + mx_square(V));
    phi.y = atan(2.0*n1 * V*cosTheta, mx_square(U) + mx_square(V) - mx_square(n1*cosTheta)) + M_PI;

    F.x = (mx_square(mx_square(n2) * (1.0 - mx_square(k)) * cosTheta - n1*U) + mx_square(2.0 * mx_square(n2) * k * cosTheta - n1*V)) /
            (mx_square(mx_square(n2) * (1.0 - mx_square(k)) * cosTheta + n1*U) + mx_square(2.0 * mx_square(n2) * k * cosTheta + n1*V));
    phi.x = atan(2.0 * n1 * mx_square(n2) * cosTheta * (2.0*k*U - (1.0 - mx_square(k)) * V), mx_square(mx_square(n2) * (1.0 + mx_square(k)) * cosTheta) - mx_square(n1) * (mx_square(U) + mx_square(V)));
}

// Depolarization functions for natural light
float mx_depolarize(vec2 v)
{
    return 0.5 * (v.x + v.y);
}
vec3 mx_depolarize(vec3 s, vec3 p)
{
    return 0.5 * (s + p);
}

// Evaluation XYZ sensitivity curves in Fourier space
vec3 mx_eval_sensitivity(float opd, float shift)
{
    // Use Gaussian fits, given by 3 parameters: val, pos and var
    float phase = 2.0*M_PI * opd;
    vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
    vec3 xyz = val * sqrt(2.0*M_PI * var) * cos(pos * phase + shift) * exp(- var * phase*phase);
    xyz.x   += 9.7470e-14 * sqrt(2.0*M_PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift) * exp(- 4.5282e+09 * phase*phase);
    return xyz / 1.0685e-7;
}

// A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence
// https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
vec3 mx_fresnel_airy(float cosTheta, vec3 ior, vec3 extinction, float tf_thickness, float tf_ior)
{
    // Convert nm -> m
    float d = tf_thickness * 1.0e-9;

    // Assume vacuum on the outside
    float eta1 = 1.0;
    float eta2 = tf_ior;

    // Optical path difference
    float cosTheta2 = sqrt(1.0 - mx_square(eta1/eta2) * (1.0 - mx_square(cosTheta)));
    float D = 2.0 * eta2 * d * cosTheta2;

    // First interface
    vec2 R12, phi12;
    mx_fresnel_dielectric_polarized(cosTheta, eta1, eta2, R12, phi12);
    vec2 R21  = R12;
    vec2 T121 = vec2(1.0) - R12;
    vec2 phi21 = vec2(M_PI) - phi12;

    // Second interface
    vec2 R23, phi23;
    mx_fresnel_conductor_polarized(cosTheta2, eta2, ior.x, extinction.x, R23, phi23);

    // Phase shift
    vec2 phi2 = phi21 + phi23;

    // Compound terms
    vec3 R = vec3(0.0);
    vec2 R123 = R12*R23;
    vec2 r123 = sqrt(R123);
    vec2 Rs   = mx_square(T121)*R23 / (1.0-R123);

    // Reflectance term for m=0 (DC term amplitude)
    vec2 C0 = R12 + Rs;
    vec3 S0 = mx_eval_sensitivity(0.0, 0.0);
    R += mx_depolarize(C0) * S0;

    // Reflectance term for m>0 (pairs of diracs)
    vec2 Cm = Rs - T121;
    for (int m=1; m<=3; ++m)
    {
        Cm *= r123;
        vec3 SmS = 2.0 * mx_eval_sensitivity(float(m)*D, float(m)*phi2.x);
        vec3 SmP = 2.0 * mx_eval_sensitivity(float(m)*D, float(m)*phi2.y);
        R += mx_depolarize(Cm.x*SmS, Cm.y*SmP);
    }

    // Convert back to RGB reflectance
    R = clamp(XYZ_TO_RGB * R, vec3(0.0), vec3(1.0));

    return R;
}

FresnelData mx_init_fresnel_data(int model)
{
    return FresnelData(model, vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0);
}

FresnelData mx_init_fresnel_dielectric(float ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_DIELECTRIC);
    fd.ior = vec3(ior);
    return fd;
}

FresnelData mx_init_fresnel_conductor(vec3 ior, vec3 extinction)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_CONDUCTOR);
    fd.ior = ior;
    fd.extinction = extinction;
    return fd;
}

FresnelData mx_init_fresnel_schlick(vec3 F0)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_SCHLICK);
    fd.F0 = F0;
    fd.F90 = vec3(1.0);
    fd.exponent = 5.0f;
    return fd;
}

FresnelData mx_init_fresnel_schlick(vec3 F0, vec3 F90, float exponent)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_SCHLICK);
    fd.F0 = F0;
    fd.F90 = F90;
    fd.exponent = exponent;
    return fd;
}

FresnelData mx_init_fresnel_dielectric_airy(float ior, float tf_thickness, float tf_ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_AIRY);
    fd.ior = vec3(ior);
    fd.tf_thickness = tf_thickness;
    fd.tf_ior = tf_ior;
    return fd;
}

FresnelData mx_init_fresnel_conductor_airy(vec3 ior, vec3 extinction, float tf_thickness, float tf_ior)
{
    FresnelData fd = mx_init_fresnel_data(FRESNEL_MODEL_AIRY);
    fd.ior = ior;
    fd.extinction = extinction;
    fd.tf_thickness = tf_thickness;
    fd.tf_ior = tf_ior;
    return fd;
}

vec3 mx_compute_fresnel(float cosTheta, FresnelData fd)
{
    if (fd.model == FRESNEL_MODEL_DIELECTRIC)
    {
        return vec3(mx_fresnel_dielectric(cosTheta, fd.ior.x));
    }
    else if (fd.model == FRESNEL_MODEL_CONDUCTOR)
    {
        return mx_fresnel_conductor(cosTheta, fd.ior, fd.extinction);
    }
    else if (fd.model == FRESNEL_MODEL_SCHLICK)
    {
        return mx_fresnel_schlick(cosTheta, fd.F0, fd.F90, fd.exponent);
    }
    else
    {
        return mx_fresnel_airy(cosTheta, fd.ior, fd.extinction, fd.tf_thickness, fd.tf_ior);
    }
}

vec2 mx_latlong_projection(vec3 dir)
{
    float latitude = -asin(dir.y) * M_PI_INV + 0.5;
    float longitude = atan(dir.x, -dir.z) * M_PI_INV * 0.5 + 0.5;
    return vec2(longitude, latitude);
}

vec3 mx_latlong_map_lookup(vec3 dir, mat4 transform, float lod, sampler2D envSampler)
{
    vec3 envDir = normalize((transform * vec4(dir,0.0)).xyz);
    vec2 uv = mx_latlong_projection(envDir);
    return textureLod(envSampler, uv, lod).rgb;
}
#include "pbrlib/genglsl/lib/mx_microfacet_sheen.glsl"
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

vec3 mx_generate_dir_albedo_table()
{
    vec2 uv = gl_FragCoord.xy / $albedoTableSize;
    vec2 ggxDirAlbedo = mx_ggx_dir_albedo(uv.x, uv.y, vec3(1, 0, 0), vec3(0, 1, 0)).xy;
    float sheenDirAlbedo = mx_imageworks_sheen_dir_albedo(uv.x, uv.y);
    return vec3(ggxDirAlbedo, sheenDirAlbedo);
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

vec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 roughness, int distribution, FresnelData fd)
{
    return vec3(0.0);
}

vec3 mx_environment_irradiance(vec3 N)
{
    return vec3(0.0);
}
#include "pbrlib/genglsl/lib/mx_microfacet.glsl"

// http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf
// Equation 2
float mx_imageworks_sheen_NDF(float NdotH, float roughness)
{
    float invRoughness = 1.0 / max(roughness, 0.005);
    float cos2 = NdotH * NdotH;
    float sin2 = 1.0 - cos2;
    return (2.0 + invRoughness) * pow(sin2, invRoughness * 0.5) / (2.0 * M_PI);
}

float mx_imageworks_sheen_brdf(float NdotL, float NdotV, float NdotH, float roughness)
{
    // Microfacet distribution.
    float D = mx_imageworks_sheen_NDF(NdotH, roughness);

    // Fresnel and geometry terms are ignored.
    float F = 1.0;
    float G = 1.0;

    // We use a smoother denominator, as in:
    // https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf
    return D * F * G / (4.0 * (NdotL + NdotV - NdotL*NdotV));
}

// Rational quadratic fit to Monte Carlo data for Imageworks sheen directional albedo.
float mx_imageworks_sheen_dir_albedo_analytic(float NdotV, float roughness)
{
    vec2 r = vec2(13.67300, 1.0) +
             vec2(-68.78018, 61.57746) * NdotV +
             vec2(799.08825, 442.78211) * roughness +
             vec2(-905.00061, 2597.49308) * NdotV * roughness +
             vec2(60.28956, 121.81241) * mx_square(NdotV) +
             vec2(1086.96473, 3045.55075) * mx_square(roughness);
    return r.x / r.y;
}

float mx_imageworks_sheen_dir_albedo_table_lookup(float NdotV, float roughness)
{
#if DIRECTIONAL_ALBEDO_METHOD == 1
    if (textureSize($albedoTable, 0).x > 1)
    {
        return texture($albedoTable, vec2(NdotV, roughness)).b;
    }
#endif
    return 0.0;
}

float mx_imageworks_sheen_dir_albedo_monte_carlo(float NdotV, float roughness)
{
    NdotV = clamp(NdotV, M_FLOAT_EPS, 1.0);
    vec3 V = vec3(sqrt(1.0f - mx_square(NdotV)), 0, NdotV);

    float radiance = 0.0;
    const int SAMPLE_COUNT = 64;
    for (int i = 0; i < SAMPLE_COUNT; i++)
    {
        vec2 Xi = mx_spherical_fibonacci(i, SAMPLE_COUNT);

        // Compute the incoming light direction and half vector.
        vec3 L = mx_uniform_sample_hemisphere(Xi);
        vec3 H = normalize(L + V);
        
        // Compute dot products for this sample.
        float NdotL = clamp(L.z, M_FLOAT_EPS, 1.0);
        float NdotH = clamp(H.z, M_FLOAT_EPS, 1.0);

        // Compute sheen reflectance.
        float reflectance = mx_imageworks_sheen_brdf(NdotL, NdotV, NdotH, roughness);

        // Add the radiance contribution of this sample.
        //   uniform_pdf = 1 / (2 * PI)
        //   radiance = reflectance * NdotL / uniform_pdf;
        radiance += reflectance * NdotL * 2.0 * M_PI;
    }

    // Return the final directional albedo.
    return radiance / float(SAMPLE_COUNT);
}

float mx_imageworks_sheen_dir_albedo(float NdotV, float roughness)
{
#if DIRECTIONAL_ALBEDO_METHOD == 0
    float dirAlbedo = mx_imageworks_sheen_dir_albedo_analytic(NdotV, roughness);
#elif DIRECTIONAL_ALBEDO_METHOD == 1
    float dirAlbedo = mx_imageworks_sheen_dir_albedo_table_lookup(NdotV, roughness);
#else
    float dirAlbedo = mx_imageworks_sheen_dir_albedo_monte_carlo(NdotV, roughness);
#endif
    return clamp(dirAlbedo, 0.0, 1.0);
}
#include "pbrlib/genglsl/lib/mx_microfacet.glsl"

// Based on the OSL implementation of Oren-Nayar diffuse, which is in turn
// based on https://mimosa-pudica.net/improved-oren-nayar.html.
float mx_oren_nayar_diffuse(vec3 L, vec3 V, vec3 N, float NdotL, float roughness)
{
    float LdotV = clamp(dot(L, V), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);
    float s = LdotV - NdotL * NdotV;
    float stinv = (s > 0.0f) ? s / max(NdotL, NdotV) : 0.0;

    float sigma2 = mx_square(roughness * M_PI);
    float A = 1.0 - 0.5 * (sigma2 / (sigma2 + 0.33));
    float B = 0.45 * sigma2 / (sigma2 + 0.09);

    return A + B * stinv;
}

// https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf
// Section 5.3
float mx_burley_diffuse(vec3 L, vec3 V, vec3 N, float NdotL, float roughness)
{
    vec3 H = normalize(L + V);
    float LdotH = clamp(dot(L, H), M_FLOAT_EPS, 1.0);
    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    float F90 = 0.5 + (2.0 * roughness * mx_square(LdotH));
    float refL = mx_fresnel_schlick(NdotL, 1.0, F90);
    float refV = mx_fresnel_schlick(NdotV, 1.0, F90);
    return refL * refV;
}

// Compute the directional albedo component of Burley diffuse for the given
// view angle and roughness.  Curve fit provided by Stephen Hill.
float mx_burley_diffuse_dir_albedo(float NdotV, float roughness)
{
    float x = NdotV;
    float fit0 = 0.97619 - 0.488095 * mx_pow5(1.0 - x);
    float fit1 = 1.55754 + (-2.02221 + (2.56283 - 1.06244 * x) * x) * x;
    return mix(fit0, fit1, roughness);
}

// Evaluate the Burley diffusion profile for the given distance and diffusion shape.
// Based on https://graphics.pixar.com/library/ApproxBSSRDF/
vec3 mx_burley_diffusion_profile(float dist, vec3 shape)
{
    vec3 num1 = exp(-shape * dist);
    vec3 num2 = exp(-shape * dist / 3.0);
    float denom = max(dist, M_FLOAT_EPS);
    return (num1 + num2) / denom;
}

// Integrate the Burley diffusion profile over a sphere of the given radius.
// Inspired by Eric Penner's presentation in http://advances.realtimerendering.com/s2011/
vec3 mx_integrate_burley_diffusion(vec3 N, vec3 L, float radius, vec3 mfp)
{
    float theta = acos(dot(N, L));

    // Estimate the Burley diffusion shape from mean free path.
    vec3 shape = vec3(1.0) / max(mfp, 0.1);

    // Integrate the profile over the sphere.
    vec3 sumD = vec3(0.0);
    vec3 sumR = vec3(0.0);
    const int SAMPLE_COUNT = 32;
    const float SAMPLE_WIDTH = (2.0 * M_PI) / float(SAMPLE_COUNT);
    for (int i = 0; i < SAMPLE_COUNT; i++)
    {
        float x = -M_PI + (float(i) + 0.5) * SAMPLE_WIDTH;
        float dist = radius * abs(2.0 * sin(x * 0.5));
        vec3 R = mx_burley_diffusion_profile(dist, shape);
        sumD += R * max(cos(theta + x), 0.0);
        sumR += R;
    }

    return sumD / sumR;
}

vec3 mx_subsurface_scattering_approx(vec3 N, vec3 L, vec3 P, vec3 albedo, vec3 mfp)
{
    float curvature = length(fwidth(N)) / length(fwidth(P));
    float radius = 1.0 / max(curvature, 0.01);
    return albedo * mx_integrate_burley_diffusion(N, L, radius, mfp) / vec3(M_PI);
}
#define M_PI 3.1415926535897932
#define M_PI_INV (1.0 / M_PI)

float mx_pow5(float x)
{
    return mx_square(mx_square(x)) * x;
}

// Standard Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return F0 + (1.0 - F0) * x5;
}

// Generalized Schlick Fresnel
float mx_fresnel_schlick(float cosTheta, float F0, float F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    float x5 = mx_pow5(x);
    return mix(F0, F90, x5);
}

// Generalized Schlick Fresnel with a variable exponent
float mx_fresnel_schlick(float cosTheta, float F0, float F90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(F0, F90, pow(x, exponent));
}
vec3 mx_fresnel_schlick(float cosTheta, vec3 F0, vec3 F90, float exponent)
{
    float x = clamp(1.0 - cosTheta, 0.0, 1.0);
    return mix(F0, F90, pow(x, exponent));
}

// Enforce that the given normal is forward-facing from the specified view direction.
vec3 mx_forward_facing_normal(vec3 N, vec3 V)
{
    return (dot(N, V) < 0.0) ? -N : N;
}

// https://www.graphics.rwth-aachen.de/publication/2/jgt.pdf
float mx_golden_ratio_sequence(int i)
{
    const float GOLDEN_RATIO = 1.6180339887498948;
    return fract((float(i) + 1.0) * GOLDEN_RATIO);
}

// https://people.irisa.fr/Ricardo.Marques/articles/2013/SF_CGF.pdf
vec2 mx_spherical_fibonacci(int i, int numSamples)
{
    return vec2((float(i) + 0.5) / float(numSamples), mx_golden_ratio_sequence(i));
}

// Generate a uniform-weighted sample in the unit hemisphere.
vec3 mx_uniform_sample_hemisphere(vec2 Xi)
{
    float phi = 2.0 * M_PI * Xi.x;
    float cosTheta = 1.0 - Xi.y;
    float sinTheta = sqrt(1.0 - mx_square(cosTheta));
    return vec3(cos(phi) * sinTheta,
                sin(phi) * sinTheta,
                cosTheta);
}
#include "pbrlib/genglsl/lib/mx_microfacet_specular.glsl"

float mx_latlong_compute_lod(float alpha)
{
    // Select a mip level based on input alpha.
    float lodBias = alpha < 0.25 ? sqrt(alpha) : 0.5*alpha + 0.375;
    return lodBias * float($envRadianceMips);
}

vec3 mx_environment_radiance(vec3 N, vec3 V, vec3 X, vec2 alpha, int distribution, FresnelData fd)
{
    N = mx_forward_facing_normal(N, V);
    vec3 L = reflect(-V, N);

    float NdotV = clamp(dot(N, V), M_FLOAT_EPS, 1.0);

    float avgAlpha = mx_average_alpha(alpha);
    vec3 F = mx_compute_fresnel(NdotV, fd);
    float G = mx_ggx_smith_G2(NdotV, NdotV, avgAlpha);
    vec3 comp = mx_ggx_energy_compensation(NdotV, avgAlpha, F);
    vec3 Li = mx_latlong_map_lookup(L, $envMatrix, mx_latlong_compute_lod(avgAlpha), $envRadiance);

    return Li * F * G * comp;
}

vec3 mx_environment_irradiance(vec3 N)
{
    return mx_latlong_map_lookup(N, $envMatrix, 0.0, $envIrradiance);
}
// https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps
float mx_variance_shadow_occlusion(vec2 moments, float fragmentDepth)
{
    const float MIN_VARIANCE = 0.00001;

    // One-tailed inequality valid if fragmentDepth > moments.x.
    float p = (fragmentDepth <= moments.x) ? 1.0 : 0.0;

    // Compute variance.
    float variance = moments.y - mx_square(moments.x);
    variance = max(variance, MIN_VARIANCE);

    // Compute probabilistic upper bound.
    float d = fragmentDepth - moments.x;
    float pMax = variance / (variance + mx_square(d));
    return max(p, pMax);
}

vec2 mx_compute_depth_moments()
{
    float depth = gl_FragCoord.z;
    return vec2(depth, mx_square(depth));
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- <oren_nayar_diffuse_bsdf> -->
  <implementation name="IM_oren_nayar_diffuse_bsdf_genmdl" nodedef="ND_oren_nayar_diffuse_bsdf" sourcecode="mx::pbrlib::mx_oren_nayar_diffuse_bsdf(mxp_weight:{{weight}}, mxp_color:{{color}}, mxp_roughness:{{roughness}}, mxp_normal:{{normal}})" target="genmdl" />

  <!-- <burley_diffuse_bsdf> -->
  <implementation name="IM_burley_diffuse_bsdf_genmdl" nodedef="ND_burley_diffuse_bsdf" sourcecode="mx::pbrlib::mx_burley_diffuse_bsdf(mxp_weight:{{weight}}, mxp_color:{{color}}, mxp_roughness:{{roughness}}, mxp_normal:{{normal}})" target="genmdl" />

  <!-- <translucent_bsdf> -->
  <implementation name="IM_translucent_bsdf_genmdl" nodedef="ND_translucent_bsdf" sourcecode="mx::pbrlib::mx_translucent_bsdf(mxp_weight:{{weight}}, mxp_color:{{color}}, mxp_normal:{{normal}})" target="genmdl" />

  <!-- <dielectric_bsdf> -->
  <implementation name="IM_dielectric_bsdf_genmdl" nodedef="ND_dielectric_bsdf" sourcecode="mx::pbrlib::mx_dielectric_bsdf(mxp_weight:{{weight}}, mxp_tint:{{tint}}, mxp_ior:{{ior}}, mxp_roughness:{{roughness}}, mxp_normal:{{normal}}, mxp_tangent:{{tangent}}, mxp_scatter_mode:{{scatter_mode}}, mxp_base:{{base}})" target="genmdl" />

  <!-- <conductor_bsdf> -->
  <implementation name="IM_conductor_bsdf_genmdl" nodedef="ND_conductor_bsdf" sourcecode="mx::pbrlib::mx_conductor_bsdf(mxp_weight:{{weight}}, mxp_ior:{{ior}}, mxp_extinction:{{extinction}}, mxp_roughness:{{roughness}}, mxp_normal:{{normal}}, mxp_tangent:{{tangent}})" target="genmdl" />

  <!-- <generalized_schlick_bsdf> -->
  <implementation name="IM_generalized_schlick_bsdf_genmdl" nodedef="ND_generalized_schlick_bsdf" sourcecode="mx::pbrlib::mx_generalized_schlick_bsdf(mxp_weight:{{weight}}, mxp_color0:{{color0}}, mxp_color90:{{color90}}, mxp_exponent:{{exponent}},mxp_roughness:{{roughness}}, mxp_normal:{{normal}}, mxp_tangent:{{tangent}}, mxp_scatter_mode:{{scatter_mode}}, mxp_base:{{base}})" target="genmdl" />

  <!-- <subsurface_bsdf> -->
  <implementation name="IM_subsurface_bsdf_genmdl" nodedef="ND_subsurface_bsdf" sourcecode="mx::pbrlib::mx_subsurface_bsdf(mxp_weight:{{weight}}, mxp_color:{{color}}, mxp_radius:{{radius}}, mxp_anisotropy:{{anisotropy}}, mxp_normal:{{normal}})" target="genmdl" />

  <!-- <sheen_bsdf> -->
  <implementation name="IM_sheen_bsdf_genmdl" nodedef="ND_sheen_bsdf" sourcecode="mx::pbrlib::mx_sheen_bsdf(mxp_weight:{{weight}}, mxp_color:{{color}}, mxp_roughness:{{roughness}}, mxp_normal:{{normal}}, mxp_base:{{base}})" target="genmdl" />

  <!-- <thin_film_bsdf> -->
  <implementation name="IM_thin_film_bsdf_genmdl" nodedef="ND_thin_film_bsdf" sourcecode="mx::pbrlib::mx_thin_film_bsdf(mxp_thickness:{{thickness}}, mxp_ior:{{ior}}, mxp_base:{{base}})" target="genmdl" />

  <!-- <uniform_edf> -->
  <implementation name="IM_uniform_edf_genmdl" nodedef="ND_uniform_edf" sourcecode="mx::pbrlib::mx_uniform_edf(mxp_color:{{color}})" target="genmdl" />

  <!-- <conical_edf> -->
  <implementation name="IM_conical_edf_genmdl" nodedef="ND_conical_edf" sourcecode="mx::pbrlib::mx_conical_edf(mxp_color:{{color}}, mxp_normal:{{normal}}, mxp_inner_angle:{{inner_angle}}, mxp_outer_angle:{{outer_angle}})" target="genmdl" />

  <!-- <measured_edf> -->
  <implementation name="IM_measured_edf_genmdl" nodedef="ND_measured_edf" sourcecode="mx::pbrlib::mx_measured_edf(mxp_color:{{color}}, mxp_normal:{{normal}}, mxp_file:{{file}}" target="genmdl" />

  <!-- <absorption_vdf> -->
  <implementation name="IM_absorption_vdf_genmdl" nodedef="ND_absorption_vdf" sourcecode="mx::pbrlib::mx_absorption_vdf(mxp_absorption:{{absorption}})" target="genmdl" />

  <!-- <anisotropic_vdf> -->
  <implementation name="IM_anisotropic_vdf_genmdl" nodedef="ND_anisotropic_vdf" sourcecode="mx::pbrlib::mx_anisotropic_vdf(mxp_absorption:{{absorption}}, mxp_scattering:{{scattering}}, mxp_anisotropy:{{anisotropy}})" target="genmdl" />

  <!-- <surface> -->
  <implementation name="IM_surface_genmdl" nodedef="ND_surface" target="genmdl" />

  <!-- <thin_surface> -->
  <implementation name="IM_thin_surface_genmdl" nodedef="ND_thin_surface" sourcecode="mx::pbrlib::mx_thin_surface(mxp_front_bsdf:{{front_bsdf}}, mxp_front_edf:{{front_edf}}, mxp_back_bsdf:{{back_bsdf}}, mxp_back_edf:{{back_edf}}, mxp_opacity:{{opacity}})" target="genmdl" />

  <!-- <volume> -->
  <implementation name="IM_volume_genmdl" nodedef="ND_volume" sourcecode="mx::pbrlib::mx_volume(mxp_vdf:{{vdf}}, mxp_edf:{{edf}})" target="genmdl" />

  <!-- <light> -->
  <implementation name="IM_light_genmdl" nodedef="ND_light" sourcecode="mx::pbrlib::mx_light(mxp_edf:{{edf}}, mxp_intensity:{{intensity}}, mxp_exposure:{{exposure}})" target="genmdl" />

  <!-- <displacement> -->
  <implementation name="IM_displacement_float_genmdl" nodedef="ND_displacement_float" sourcecode="mx::pbrlib::mx_displacement_float(mxp_displacement:{{displacement}}, mxp_scale:{{scale}})" target="genmdl" />
  <implementation name="IM_displacement_vector3_genmdl" nodedef="ND_displacement_vector3" sourcecode="mx::pbrlib::mx_displacement_vector3(mxp_displacement:{{displacement}}, mxp_scale:{{scale}})" target="genmdl" />

  <!-- <layer> -->
  <implementation name="IM_layer_bsdf_genmdl" nodedef="ND_layer_bsdf" target="genmdl" />
  <implementation name="IM_layer_vdf_genmdl" nodedef="ND_layer_vdf" target="genmdl" />

  <!-- <mix> -->
  <implementation name="IM_mix_bsdf_genmdl" nodedef="ND_mix_bsdf" sourcecode="mx::pbrlib::mx_mix_bsdf(mxp_fg:{{fg}}, mxp_bg:{{bg}}, mxp_mix:{{mix}})" target="genmdl" />
  <implementation name="IM_mix_edf_genmdl" nodedef="ND_mix_edf" sourcecode="mx::pbrlib::mx_mix_edf(mxp_fg:{{fg}}, mxp_bg:{{bg}}, mxp_mix:{{mix}})" target="genmdl" />
  <implementation name="IM_mix_vdf_genmdl" nodedef="ND_mix_vdf" sourcecode="mx::pbrlib::mx_mix_vdf(mxp_fg:{{fg}}, mxp_bg:{{bg}}, mxp_mix:{{mix}})" target="genmdl" />

  <!-- <add> -->
  <implementation name="IM_add_bsdf_genmdl" nodedef="ND_add_bsdf" sourcecode="{{in1}}" target="genmdl" /> <!-- TODO: Implement properly -->
  <implementation name="IM_add_edf_genmdl" nodedef="ND_add_edf" sourcecode="{{in2}}" target="genmdl" /> <!-- TODO: Implement properly -->

  <!-- <multiply> -->
  <implementation name="IM_multiply_bsdfC_genmdl" nodedef="ND_multiply_bsdfC" sourcecode="mx::pbrlib::mx_multiply_bsdf_color3(mxp_in1:{{in1}}, mxp_in2:{{in2}})" target="genmdl" />
  <implementation name="IM_multiply_bsdfF_genmdl" nodedef="ND_multiply_bsdfF" sourcecode="mx::pbrlib::mx_multiply_bsdf_float(mxp_in1:{{in1}}, mxp_in2:{{in2}})" target="genmdl" />
  <implementation name="IM_multiply_edfC_genmdl" nodedef="ND_multiply_edfC" sourcecode="{{in1}}" target="genmdl" /> <!-- TODO: Implement properly -->
  <implementation name="IM_multiply_edfF_genmdl" nodedef="ND_multiply_edfF" sourcecode="{{in1}}" target="genmdl" /> <!-- TODO: Implement properly -->

  <!-- <roughness_anisotropy> -->
  <implementation name="IM_roughness_anisotropy_genmdl" nodedef="ND_roughness_anisotropy" sourcecode="mx::pbrlib::mx_roughness_anisotropy(mxp_roughness:{{roughness}}, mxp_anisotropy:{{anisotropy}})" target="genmdl" />

  <!-- <roughness_dual> -->
  <implementation name="IM_roughness_dual_genmdl" nodedef="ND_roughness_dual" sourcecode="mx::pbrlib::mx_roughness_dual(mxp_roughness:{{roughness}})" target="genmdl" />

  <!-- <artistic_ior> -->
  <implementation name="IM_artistic_ior_genmdl" nodedef="ND_artistic_ior" sourcecode="mx::pbrlib::mx_artistic_ior(mxp_reflectivity:{{reflectivity}}, mxp_edge_color:{{edge_color}})" target="genmdl" />

  <!-- <blackbody> -->
  <implementation name="IM_blackbody_genmdl" nodedef="ND_blackbody" sourcecode="mx::pbrlib::mx_blackbody(mxp_temperature:{{temperature}})" target="genmdl" />

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2018 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Nodegraph implementations for Supplemental Nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Supplemental Texture nodes                                               -->
  <!-- ======================================================================== -->

  <!--
    <tiledimage>
  -->
  <nodegraph name="NG_tiledimage_float" nodedef="ND_tiledimage_float">
    <multiply name="N_mult_float" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_float" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_float" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_float" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_float" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_float" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_float" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_float" type="float">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="float" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_float" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="float" nodename="N_img_float" />
  </nodegraph>
  <nodegraph name="NG_tiledimage_color3" nodedef="ND_tiledimage_color3">
    <multiply name="N_mult_color3" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_color3" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_color3" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_color3" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_color3" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_color3" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_color3" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_color3" type="color3">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="color3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_color3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="color3" nodename="N_img_color3" />
  </nodegraph>
  <nodegraph name="NG_tiledimage_color4" nodedef="ND_tiledimage_color4">
    <multiply name="N_mult_color4" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_color4" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_color4" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_color4" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_color4" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_color4" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_color4" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_color4" type="color4">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="color4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_color4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="color4" nodename="N_img_color4" />
  </nodegraph>
  <nodegraph name="NG_tiledimage_vector2" nodedef="ND_tiledimage_vector2">
    <multiply name="N_mult_vector2" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_vector2" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_vector2" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_vector2" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_vector2" type="vector2">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="vector2" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_vector2" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="vector2" nodename="N_img_vector2" />
  </nodegraph>
  <nodegraph name="NG_tiledimage_vector3" nodedef="ND_tiledimage_vector3">
    <multiply name="N_mult_vector3" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_vector3" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_vector3" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_vector3" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_vector3" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_vector3" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_vector3" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_vector3" type="vector3">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="vector3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_vector3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="vector3" nodename="N_img_vector3" />
  </nodegraph>
  <nodegraph name="NG_tiledimage_vector4" nodedef="ND_tiledimage_vector4">
    <multiply name="N_mult_vector4" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="uvtiling" />
    </multiply>
    <subtract name="N_sub_vector4" type="vector2">
      <input name="in1" type="vector2" nodename="N_mult_vector4" />
      <input name="in2" type="vector2" interfacename="uvoffset" />
    </subtract>
    <divide name="N_divtilesize_vector4" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_vector4" />
      <input name="in2" type="vector2" interfacename="realworldimagesize" />
    </divide>
    <multiply name="N_multtilesize_vector4" type="vector2">
      <input name="in1" type="vector2" nodename="N_divtilesize_vector4" />
      <input name="in2" type="vector2" interfacename="realworldtilesize" />
    </multiply>
    <image name="N_img_vector4" type="vector4">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="vector4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_multtilesize_vector4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <output name="out" type="vector4" nodename="N_img_vector4" />
  </nodegraph>

  <!--
    <triplanarprojection>
    Samples data from three images, or layers within multi-layer images, and projects a tiled
    representation of the images along each of the three respective coordinate axes, computing
    a weighted blend of the three samples using the geometric normal.
  -->
  <nodegraph name="NG_triplanarprojection_float" nodedef="ND_triplanarprojection_float">
    <extract name="N_extX_float" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_float" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_float" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_float" type="vector2">
      <input name="in1" type="float" nodename="N_extY_float" />
      <input name="in2" type="float" nodename="N_extZ_float" />
    </combine2>
    <combine2 name="N_vecXZ_float" type="vector2">
      <input name="in1" type="float" nodename="N_extX_float" />
      <input name="in2" type="float" nodename="N_extZ_float" />
    </combine2>
    <combine2 name="N_vecXY_float" type="vector2">
      <input name="in1" type="float" nodename="N_extX_float" />
      <input name="in2" type="float" nodename="N_extY_float" />
    </combine2>
    <image name="N_imgX_float" type="float">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="float" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_float" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_float" type="float">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="float" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_float" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_float" type="float">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="float" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_float" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_float" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_float" type="float">
      <input name="in1" type="vector3" nodename="N_norm_float" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_float" type="float">
      <input name="in1" type="vector3" nodename="N_norm_float" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_float" type="float">
      <input name="in1" type="vector3" nodename="N_norm_float" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_float" type="float">
      <input name="in" type="float" nodename="N_dotX_float" />
    </absval>
    <absval name="N_blendY_float" type="float">
      <input name="in" type="float" nodename="N_dotY_float" />
    </absval>
    <absval name="N_blendZ_float" type="float">
      <input name="in" type="float" nodename="N_dotZ_float" />
    </absval>
    <multiply name="N_nX_float" type="float">
      <input name="in1" type="float" nodename="N_imgX_float" />
      <input name="in2" type="float" nodename="N_blendX_float" />
    </multiply>
    <multiply name="N_nY_float" type="float">
      <input name="in1" type="float" nodename="N_imgY_float" />
      <input name="in2" type="float" nodename="N_blendY_float" />
    </multiply>
    <multiply name="N_nZ_float" type="float">
      <input name="in1" type="float" nodename="N_imgZ_float" />
      <input name="in2" type="float" nodename="N_blendZ_float" />
    </multiply>
    <add name="N_add1_float" type="float">
      <input name="in1" type="float" nodename="N_nX_float" />
      <input name="in2" type="float" nodename="N_nY_float" />
    </add>
    <add name="N_add2_float" type="float">
      <input name="in1" type="float" nodename="N_add1_float" />
      <input name="in2" type="float" nodename="N_nZ_float" />
    </add>
    <output name="out" type="float" nodename="N_add2_float" />
  </nodegraph>
  <nodegraph name="NG_triplanarprojection_color3" nodedef="ND_triplanarprojection_color3">
    <extract name="N_extX_color3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_color3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_color3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_color3" type="vector2">
      <input name="in1" type="float" nodename="N_extY_color3" />
      <input name="in2" type="float" nodename="N_extZ_color3" />
    </combine2>
    <combine2 name="N_vecXZ_color3" type="vector2">
      <input name="in1" type="float" nodename="N_extX_color3" />
      <input name="in2" type="float" nodename="N_extZ_color3" />
    </combine2>
    <combine2 name="N_vecXY_color3" type="vector2">
      <input name="in1" type="float" nodename="N_extX_color3" />
      <input name="in2" type="float" nodename="N_extY_color3" />
    </combine2>
    <image name="N_imgX_color3" type="color3">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="color3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_color3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_color3" type="color3">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="color3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_color3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_color3" type="color3">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="color3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_color3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_color3" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_color3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color3" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_color3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color3" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_color3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color3" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_color3" type="float">
      <input name="in" type="float" nodename="N_dotX_color3" />
    </absval>
    <absval name="N_blendY_color3" type="float">
      <input name="in" type="float" nodename="N_dotY_color3" />
    </absval>
    <absval name="N_blendZ_color3" type="float">
      <input name="in" type="float" nodename="N_dotZ_color3" />
    </absval>
    <multiply name="N_nX_color3" type="color3">
      <input name="in1" type="color3" nodename="N_imgX_color3" />
      <input name="in2" type="float" nodename="N_blendX_color3" />
    </multiply>
    <multiply name="N_nY_color3" type="color3">
      <input name="in1" type="color3" nodename="N_imgY_color3" />
      <input name="in2" type="float" nodename="N_blendY_color3" />
    </multiply>
    <multiply name="N_nZ_color3" type="color3">
      <input name="in1" type="color3" nodename="N_imgZ_color3" />
      <input name="in2" type="float" nodename="N_blendZ_color3" />
    </multiply>
    <add name="N_add1_color3" type="color3">
      <input name="in1" type="color3" nodename="N_nX_color3" />
      <input name="in2" type="color3" nodename="N_nY_color3" />
    </add>
    <add name="N_add2_color3" type="color3">
      <input name="in1" type="color3" nodename="N_add1_color3" />
      <input name="in2" type="color3" nodename="N_nZ_color3" />
    </add>
    <output name="out" type="color3" nodename="N_add2_color3" />
  </nodegraph>
  <nodegraph name="NG_triplanarprojection_color4" nodedef="ND_triplanarprojection_color4">
    <extract name="N_extX_color4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_color4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_color4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_color4" type="vector2">
      <input name="in1" type="float" nodename="N_extY_color4" />
      <input name="in2" type="float" nodename="N_extZ_color4" />
    </combine2>
    <combine2 name="N_vecXZ_color4" type="vector2">
      <input name="in1" type="float" nodename="N_extX_color4" />
      <input name="in2" type="float" nodename="N_extZ_color4" />
    </combine2>
    <combine2 name="N_vecXY_color4" type="vector2">
      <input name="in1" type="float" nodename="N_extX_color4" />
      <input name="in2" type="float" nodename="N_extY_color4" />
    </combine2>
    <image name="N_imgX_color4" type="color4">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="color4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_color4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_color4" type="color4">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="color4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_color4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_color4" type="color4">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="color4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_color4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_color4" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_color4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color4" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_color4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color4" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_color4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_color4" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_color4" type="float">
      <input name="in" type="float" nodename="N_dotX_color4" />
    </absval>
    <absval name="N_blendY_color4" type="float">
      <input name="in" type="float" nodename="N_dotY_color4" />
    </absval>
    <absval name="N_blendZ_color4" type="float">
      <input name="in" type="float" nodename="N_dotZ_color4" />
    </absval>
    <multiply name="N_nX_color4" type="color4">
      <input name="in1" type="color4" nodename="N_imgX_color4" />
      <input name="in2" type="float" nodename="N_blendX_color4" />
    </multiply>
    <multiply name="N_nY_color4" type="color4">
      <input name="in1" type="color4" nodename="N_imgY_color4" />
      <input name="in2" type="float" nodename="N_blendY_color4" />
    </multiply>
    <multiply name="N_nZ_color4" type="color4">
      <input name="in1" type="color4" nodename="N_imgZ_color4" />
      <input name="in2" type="float" nodename="N_blendZ_color4" />
    </multiply>
    <add name="N_add1_color4" type="color4">
      <input name="in1" type="color4" nodename="N_nX_color4" />
      <input name="in2" type="color4" nodename="N_nY_color4" />
    </add>
    <add name="N_add2_color4" type="color4">
      <input name="in1" type="color4" nodename="N_add1_color4" />
      <input name="in2" type="color4" nodename="N_nZ_color4" />
    </add>
    <output name="out" type="color4" nodename="N_add2_color4" />
  </nodegraph>
  <nodegraph name="NG_triplanarprojection_vector2" nodedef="ND_triplanarprojection_vector2">
    <extract name="N_extX_vector2" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_vector2" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_vector2" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_vector2" type="vector2">
      <input name="in1" type="float" nodename="N_extY_vector2" />
      <input name="in2" type="float" nodename="N_extZ_vector2" />
    </combine2>
    <combine2 name="N_vecXZ_vector2" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector2" />
      <input name="in2" type="float" nodename="N_extZ_vector2" />
    </combine2>
    <combine2 name="N_vecXY_vector2" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector2" />
      <input name="in2" type="float" nodename="N_extY_vector2" />
    </combine2>
    <image name="N_imgX_vector2" type="vector2">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="vector2" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_vector2" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_vector2" type="vector2">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="vector2" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_vector2" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_vector2" type="vector2">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="vector2" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_vector2" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_vector2" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_vector2" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector2" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_vector2" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector2" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_vector2" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector2" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_vector2" type="float">
      <input name="in" type="float" nodename="N_dotX_vector2" />
    </absval>
    <absval name="N_blendY_vector2" type="float">
      <input name="in" type="float" nodename="N_dotY_vector2" />
    </absval>
    <absval name="N_blendZ_vector2" type="float">
      <input name="in" type="float" nodename="N_dotZ_vector2" />
    </absval>
    <multiply name="N_nX_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_imgX_vector2" />
      <input name="in2" type="float" nodename="N_blendX_vector2" />
    </multiply>
    <multiply name="N_nY_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_imgY_vector2" />
      <input name="in2" type="float" nodename="N_blendY_vector2" />
    </multiply>
    <multiply name="N_nZ_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_imgZ_vector2" />
      <input name="in2" type="float" nodename="N_blendZ_vector2" />
    </multiply>
    <add name="N_add1_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_nX_vector2" />
      <input name="in2" type="vector2" nodename="N_nY_vector2" />
    </add>
    <add name="N_add2_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_add1_vector2" />
      <input name="in2" type="vector2" nodename="N_nZ_vector2" />
    </add>
    <output name="out" type="vector2" nodename="N_add2_vector2" />
  </nodegraph>
  <nodegraph name="NG_triplanarprojection_vector3" nodedef="ND_triplanarprojection_vector3">
    <extract name="N_extX_vector3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_vector3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_vector3" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_vector3" type="vector2">
      <input name="in1" type="float" nodename="N_extY_vector3" />
      <input name="in2" type="float" nodename="N_extZ_vector3" />
    </combine2>
    <combine2 name="N_vecXZ_vector3" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector3" />
      <input name="in2" type="float" nodename="N_extZ_vector3" />
    </combine2>
    <combine2 name="N_vecXY_vector3" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector3" />
      <input name="in2" type="float" nodename="N_extY_vector3" />
    </combine2>
    <image name="N_imgX_vector3" type="vector3">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="vector3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_vector3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_vector3" type="vector3">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="vector3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_vector3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_vector3" type="vector3">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="vector3" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_vector3" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_vector3" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_vector3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector3" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_vector3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector3" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_vector3" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector3" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_vector3" type="float">
      <input name="in" type="float" nodename="N_dotX_vector3" />
    </absval>
    <absval name="N_blendY_vector3" type="float">
      <input name="in" type="float" nodename="N_dotY_vector3" />
    </absval>
    <absval name="N_blendZ_vector3" type="float">
      <input name="in" type="float" nodename="N_dotZ_vector3" />
    </absval>
    <multiply name="N_nX_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_imgX_vector3" />
      <input name="in2" type="float" nodename="N_blendX_vector3" />
    </multiply>
    <multiply name="N_nY_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_imgY_vector3" />
      <input name="in2" type="float" nodename="N_blendY_vector3" />
    </multiply>
    <multiply name="N_nZ_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_imgZ_vector3" />
      <input name="in2" type="float" nodename="N_blendZ_vector3" />
    </multiply>
    <add name="N_add1_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_nX_vector3" />
      <input name="in2" type="vector3" nodename="N_nY_vector3" />
    </add>
    <add name="N_add2_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_add1_vector3" />
      <input name="in2" type="vector3" nodename="N_nZ_vector3" />
    </add>
    <output name="out" type="vector3" nodename="N_add2_vector3" />
  </nodegraph>
  <nodegraph name="NG_triplanarprojection_vector4" nodedef="ND_triplanarprojection_vector4">
    <extract name="N_extX_vector4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_extY_vector4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="1" />
    </extract>
    <extract name="N_extZ_vector4" type="float">
      <input name="in" type="vector3" interfacename="position" />
      <input name="index" type="integer" value="2" />
    </extract>
    <combine2 name="N_vecYZ_vector4" type="vector2">
      <input name="in1" type="float" nodename="N_extY_vector4" />
      <input name="in2" type="float" nodename="N_extZ_vector4" />
    </combine2>
    <combine2 name="N_vecXZ_vector4" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector4" />
      <input name="in2" type="float" nodename="N_extZ_vector4" />
    </combine2>
    <combine2 name="N_vecXY_vector4" type="vector2">
      <input name="in1" type="float" nodename="N_extX_vector4" />
      <input name="in2" type="float" nodename="N_extY_vector4" />
    </combine2>
    <image name="N_imgX_vector4" type="vector4">
      <input name="file" type="filename" interfacename="filex" />
      <input name="layer" type="string" interfacename="layerx" />
      <input name="default" type="vector4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecYZ_vector4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgY_vector4" type="vector4">
      <input name="file" type="filename" interfacename="filey" />
      <input name="layer" type="string" interfacename="layery" />
      <input name="default" type="vector4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXZ_vector4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <image name="N_imgZ_vector4" type="vector4">
      <input name="file" type="filename" interfacename="filez" />
      <input name="layer" type="string" interfacename="layerz" />
      <input name="default" type="vector4" interfacename="default" />
      <input name="texcoord" type="vector2" nodename="N_vecXY_vector4" />
      <input name="uaddressmode" type="string" value="periodic" />
      <input name="vaddressmode" type="string" value="periodic" />
      <input name="filtertype" type="string" interfacename="filtertype" />
      <input name="framerange" type="string" interfacename="framerange" />
      <input name="frameoffset" type="integer" interfacename="frameoffset" />
      <input name="frameendaction" type="string" interfacename="frameendaction" />
    </image>
    <normalize name="N_norm_vector4" type="vector3">
      <input name="in" type="vector3" interfacename="normal" />
    </normalize>
    <dotproduct name="N_dotX_vector4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector4" />
      <input name="in2" type="vector3" value="1.0, 0.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotY_vector4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector4" />
      <input name="in2" type="vector3" value="0.0, 1.0, 0.0" />
    </dotproduct>
    <dotproduct name="N_dotZ_vector4" type="float">
      <input name="in1" type="vector3" nodename="N_norm_vector4" />
      <input name="in2" type="vector3" value="0.0, 0.0, 1.0" />
    </dotproduct>
    <absval name="N_blendX_vector4" type="float">
      <input name="in" type="float" nodename="N_dotX_vector4" />
    </absval>
    <absval name="N_blendY_vector4" type="float">
      <input name="in" type="float" nodename="N_dotY_vector4" />
    </absval>
    <absval name="N_blendZ_vector4" type="float">
      <input name="in" type="float" nodename="N_dotZ_vector4" />
    </absval>
    <multiply name="N_nX_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_imgX_vector4" />
      <input name="in2" type="float" nodename="N_blendX_vector4" />
    </multiply>
    <multiply name="N_nY_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_imgY_vector4" />
      <input name="in2" type="float" nodename="N_blendY_vector4" />
    </multiply>
    <multiply name="N_nZ_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_imgZ_vector4" />
      <input name="in2" type="float" nodename="N_blendZ_vector4" />
    </multiply>
    <add name="N_add1_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_nX_vector4" />
      <input name="in2" type="vector4" nodename="N_nY_vector4" />
    </add>
    <add name="N_add2_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_add1_vector4" />
      <input name="in2" type="vector4" nodename="N_nZ_vector4" />
    </add>
    <output name="out" type="vector4" nodename="N_add2_vector4" />
  </nodegraph>

  <!-- ======================================================================== -->
  <!-- Procedural nodes                                                         -->
  <!-- ======================================================================== -->

  <!--
    <ramp4>
    A 4-corner bilinear value ramp.
  -->
  <nodegraph name="NG_ramp4_float" nodedef="ND_ramp4_float">
    <clamp name="N_txclamp_float" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_float" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_float" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_float" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_float" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_float" type="float">
      <input name="bg" type="float" interfacename="valuetl" />
      <input name="fg" type="float" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_float" />
    </mix>
    <mix name="N_mixbot_float" type="float">
      <input name="bg" type="float" interfacename="valuebl" />
      <input name="fg" type="float" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_float" />
    </mix>
    <mix name="N_mix_float" type="float">
      <input name="bg" type="float" nodename="N_mixtop_float" />
      <input name="fg" type="float" nodename="N_mixbot_float" />
      <input name="mix" type="float" nodename="N_t_float" />
    </mix>
    <output name="out" type="float" nodename="N_mix_float" />
  </nodegraph>
  <nodegraph name="NG_ramp4_color3" nodedef="ND_ramp4_color3">
    <clamp name="N_txclamp_color3" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_color3" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_color3" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_color3" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_color3" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_color3" type="color3">
      <input name="bg" type="color3" interfacename="valuetl" />
      <input name="fg" type="color3" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_color3" />
    </mix>
    <mix name="N_mixbot_color3" type="color3">
      <input name="bg" type="color3" interfacename="valuebl" />
      <input name="fg" type="color3" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_color3" />
    </mix>
    <mix name="N_mix_color3" type="color3">
      <input name="bg" type="color3" nodename="N_mixtop_color3" />
      <input name="fg" type="color3" nodename="N_mixbot_color3" />
      <input name="mix" type="float" nodename="N_t_color3" />
    </mix>
    <output name="out" type="color3" nodename="N_mix_color3" />
  </nodegraph>
  <nodegraph name="NG_ramp4_color4" nodedef="ND_ramp4_color4">
    <clamp name="N_txclamp_color4" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_color4" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_color4" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_color4" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_color4" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_color4" type="color4">
      <input name="bg" type="color4" interfacename="valuetl" />
      <input name="fg" type="color4" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_color4" />
    </mix>
    <mix name="N_mixbot_color4" type="color4">
      <input name="bg" type="color4" interfacename="valuebl" />
      <input name="fg" type="color4" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_color4" />
    </mix>
    <mix name="N_mix_color4" type="color4">
      <input name="bg" type="color4" nodename="N_mixtop_color4" />
      <input name="fg" type="color4" nodename="N_mixbot_color4" />
      <input name="mix" type="float" nodename="N_t_color4" />
    </mix>
    <output name="out" type="color4" nodename="N_mix_color4" />
  </nodegraph>
  <nodegraph name="NG_ramp4_vector2" nodedef="ND_ramp4_vector2">
    <clamp name="N_txclamp_vector2" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_vector2" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector2" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_vector2" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector2" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_vector2" type="vector2">
      <input name="bg" type="vector2" interfacename="valuetl" />
      <input name="fg" type="vector2" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_vector2" />
    </mix>
    <mix name="N_mixbot_vector2" type="vector2">
      <input name="bg" type="vector2" interfacename="valuebl" />
      <input name="fg" type="vector2" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_vector2" />
    </mix>
    <mix name="N_mix_vector2" type="vector2">
      <input name="bg" type="vector2" nodename="N_mixtop_vector2" />
      <input name="fg" type="vector2" nodename="N_mixbot_vector2" />
      <input name="mix" type="float" nodename="N_t_vector2" />
    </mix>
    <output name="out" type="vector2" nodename="N_mix_vector2" />
  </nodegraph>
  <nodegraph name="NG_ramp4_vector3" nodedef="ND_ramp4_vector3">
    <clamp name="N_txclamp_vector3" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_vector3" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector3" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_vector3" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector3" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_vector3" type="vector3">
      <input name="bg" type="vector3" interfacename="valuetl" />
      <input name="fg" type="vector3" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_vector3" />
    </mix>
    <mix name="N_mixbot_vector3" type="vector3">
      <input name="bg" type="vector3" interfacename="valuebl" />
      <input name="fg" type="vector3" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_vector3" />
    </mix>
    <mix name="N_mix_vector3" type="vector3">
      <input name="bg" type="vector3" nodename="N_mixtop_vector3" />
      <input name="fg" type="vector3" nodename="N_mixbot_vector3" />
      <input name="mix" type="float" nodename="N_t_vector3" />
    </mix>
    <output name="out" type="vector3" nodename="N_mix_vector3" />
  </nodegraph>
  <nodegraph name="NG_ramp4_vector4" nodedef="ND_ramp4_vector4">
    <clamp name="N_txclamp_vector4" type="vector2">
      <input name="in" type="vector2" interfacename="texcoord" />
    </clamp>
    <extract name="N_s_vector4" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector4" />
      <input name="index" type="integer" value="0" />
    </extract>
    <extract name="N_t_vector4" type="float">
      <input name="in" type="vector2" nodename="N_txclamp_vector4" />
      <input name="index" type="integer" value="1" />
    </extract>
    <mix name="N_mixtop_vector4" type="vector4">
      <input name="bg" type="vector4" interfacename="valuetl" />
      <input name="fg" type="vector4" interfacename="valuetr" />
      <input name="mix" type="float" nodename="N_s_vector4" />
    </mix>
    <mix name="N_mixbot_vector4" type="vector4">
      <input name="bg" type="vector4" interfacename="valuebl" />
      <input name="fg" type="vector4" interfacename="valuebr" />
      <input name="mix" type="float" nodename="N_s_vector4" />
    </mix>
    <mix name="N_mix_vector4" type="vector4">
      <input name="bg" type="vector4" nodename="N_mixtop_vector4" />
      <input name="fg" type="vector4" nodename="N_mixbot_vector4" />
      <input name="mix" type="float" nodename="N_t_vector4" />
    </mix>
    <output name="out" type="vector4" nodename="N_mix_vector4" />
  </nodegraph>

  <!-- ======================================================================== -->
  <!-- Geometric nodes                                                          -->
  <!-- ======================================================================== -->

  <!-- ======================================================================== -->
  <!-- Global nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- ======================================================================== -->
  <!-- Application nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- ======================================================================== -->
  <!-- Math nodes                                                               -->
  <!-- ======================================================================== -->

  <!--
    Node: <place2d>
    Transform incoming UV texture coordinates for 2D texture placement.
  -->
  <nodegraph name="NG_place2d_vector2" nodedef="ND_place2d_vector2">
    <subtract name="N_subpivot" type="vector2">
      <input name="in1" type="vector2" interfacename="texcoord" />
      <input name="in2" type="vector2" interfacename="pivot" />
    </subtract>
    <divide name="N_applyscale" type="vector2">
      <input name="in1" type="vector2" nodename="N_subpivot" />
      <input name="in2" type="vector2" interfacename="scale" />
    </divide>
    <rotate2d name="N_applyrot" type="vector2">
      <input name="in" type="vector2" nodename="N_applyscale" />
      <input name="amount" type="float" interfacename="rotate" />
    </rotate2d>
    <subtract name="N_applyoffset" type="vector2">
      <input name="in1" type="vector2" nodename="N_applyrot" />
      <input name="in2" type="vector2" interfacename="offset" />
    </subtract>
    <add name="N_addpivot" type="vector2">
      <input name="in1" type="vector2" nodename="N_applyoffset" />
      <input name="in2" type="vector2" interfacename="pivot" />
    </add>
    <output name="out" type="vector2" nodename="N_addpivot" />
  </nodegraph>

  <!-- ======================================================================== -->
  <!-- Adjustment nodes                                                         -->
  <!-- ======================================================================== -->

  <!--
    Node: <contrast>
    Increase or decrease contrast of a float/color value using a linear slope multiplier.
  -->
  <nodegraph name="NG_contrast_float" nodedef="ND_contrast_float">
    <subtract name="N_sub_float" type="float">
      <input name="in1" type="float" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_float" type="float">
      <input name="in1" type="float" nodename="N_sub_float" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_float" type="float">
      <input name="in1" type="float" nodename="N_mul_float" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="float" nodename="N_add_float" />
  </nodegraph>
  <nodegraph name="NG_contrast_color3" nodedef="ND_contrast_color3">
    <subtract name="N_sub_color3" type="color3">
      <input name="in1" type="color3" interfacename="in" />
      <input name="in2" type="color3" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_color3" type="color3">
      <input name="in1" type="color3" nodename="N_sub_color3" />
      <input name="in2" type="color3" interfacename="amount" />
    </multiply>
    <add name="N_add_color3" type="color3">
      <input name="in1" type="color3" nodename="N_mul_color3" />
      <input name="in2" type="color3" interfacename="pivot" />
    </add>
    <output name="out" type="color3" nodename="N_add_color3" />
  </nodegraph>
  <nodegraph name="NG_contrast_color4" nodedef="ND_contrast_color4">
    <subtract name="N_sub_color4" type="color4">
      <input name="in1" type="color4" interfacename="in" />
      <input name="in2" type="color4" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_color4" type="color4">
      <input name="in1" type="color4" nodename="N_sub_color4" />
      <input name="in2" type="color4" interfacename="amount" />
    </multiply>
    <add name="N_add_color4" type="color4">
      <input name="in1" type="color4" nodename="N_mul_color4" />
      <input name="in2" type="color4" interfacename="pivot" />
    </add>
    <output name="out" type="color4" nodename="N_add_color4" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector2" nodedef="ND_contrast_vector2">
    <subtract name="N_sub_vector2" type="vector2">
      <input name="in1" type="vector2" interfacename="in" />
      <input name="in2" type="vector2" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_vector2" />
      <input name="in2" type="vector2" interfacename="amount" />
    </multiply>
    <add name="N_add_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_mul_vector2" />
      <input name="in2" type="vector2" interfacename="pivot" />
    </add>
    <output name="out" type="vector2" nodename="N_add_vector2" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector3" nodedef="ND_contrast_vector3">
    <subtract name="N_sub_vector3" type="vector3">
      <input name="in1" type="vector3" interfacename="in" />
      <input name="in2" type="vector3" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_sub_vector3" />
      <input name="in2" type="vector3" interfacename="amount" />
    </multiply>
    <add name="N_add_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_mul_vector3" />
      <input name="in2" type="vector3" interfacename="pivot" />
    </add>
    <output name="out" type="vector3" nodename="N_add_vector3" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector4" nodedef="ND_contrast_vector4">
    <subtract name="N_sub_vector4" type="vector4">
      <input name="in1" type="vector4" interfacename="in" />
      <input name="in2" type="vector4" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_sub_vector4" />
      <input name="in2" type="vector4" interfacename="amount" />
    </multiply>
    <add name="N_add_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_mul_vector4" />
      <input name="in2" type="vector4" interfacename="pivot" />
    </add>
    <output name="out" type="vector4" nodename="N_add_vector4" />
  </nodegraph>
  <nodegraph name="NG_contrast_color3FA" nodedef="ND_contrast_color3FA">
    <subtract name="N_sub_color3FA" type="color3">
      <input name="in1" type="color3" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_color3FA" type="color3">
      <input name="in1" type="color3" nodename="N_sub_color3FA" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_color3FA" type="color3">
      <input name="in1" type="color3" nodename="N_mul_color3FA" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="color3" nodename="N_add_color3FA" />
  </nodegraph>
  <nodegraph name="NG_contrast_color4FA" nodedef="ND_contrast_color4FA">
    <subtract name="N_sub_color4FA" type="color4">
      <input name="in1" type="color4" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_color4FA" type="color4">
      <input name="in1" type="color4" nodename="N_sub_color4FA" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_color4FA" type="color4">
      <input name="in1" type="color4" nodename="N_mul_color4FA" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="color4" nodename="N_add_color4FA" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector2FA" nodedef="ND_contrast_vector2FA">
    <subtract name="N_sub_vector2FA" type="vector2">
      <input name="in1" type="vector2" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector2FA" type="vector2">
      <input name="in1" type="vector2" nodename="N_sub_vector2FA" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_vector2FA" type="vector2">
      <input name="in1" type="vector2" nodename="N_mul_vector2FA" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="vector2" nodename="N_add_vector2FA" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector3FA" nodedef="ND_contrast_vector3FA">
    <subtract name="N_sub_vector3FA" type="vector3">
      <input name="in1" type="vector3" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector3FA" type="vector3">
      <input name="in1" type="vector3" nodename="N_sub_vector3FA" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_vector3FA" type="vector3">
      <input name="in1" type="vector3" nodename="N_mul_vector3FA" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="vector3" nodename="N_add_vector3FA" />
  </nodegraph>
  <nodegraph name="NG_contrast_vector4FA" nodedef="ND_contrast_vector4FA">
    <subtract name="N_sub_vector4FA" type="vector4">
      <input name="in1" type="vector4" interfacename="in" />
      <input name="in2" type="float" interfacename="pivot" />
    </subtract>
    <multiply name="N_mul_vector4FA" type="vector4">
      <input name="in1" type="vector4" nodename="N_sub_vector4FA" />
      <input name="in2" type="float" interfacename="amount" />
    </multiply>
    <add name="N_add_vector4FA" type="vector4">
      <input name="in1" type="vector4" nodename="N_mul_vector4FA" />
      <input name="in2" type="float" interfacename="pivot" />
    </add>
    <output name="out" type="vector4" nodename="N_add_vector4FA" />
  </nodegraph>

  <!--
    Node: <range>
    Remap a value from one range of float/color/vector values to another, optionally
    applying a gamma correction in the middle, and optionally clamping output values.
  -->
  <nodegraph name="NG_range_float" nodedef="ND_range_float">
    <remap name="N_remap1_float" type="float">
      <input name="in" type="float" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_float" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_float" type="float">
      <input name="in" type="float" nodename="N_remap1_float" />
    </absval>
    <power name="N_pow_float" type="float">
      <input name="in1" type="float" nodename="N_abs_float" />
      <input name="in2" type="float" nodename="N_recip_float" />
    </power>
    <sign name="N_sign_float" type="float">
      <input name="in" type="float" nodename="N_remap1_float" />
    </sign>
    <multiply name="N_gamma_float" type="float">
      <input name="in1" type="float" nodename="N_pow_float" />
      <input name="in2" type="float" nodename="N_sign_float" />
    </multiply>
    <remap name="N_remap2_float" type="float">
      <input name="in" type="float" nodename="N_gamma_float" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_float" type="float">
      <input name="in" type="float" nodename="N_remap2_float" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_float" type="float">
      <input name="in1" type="float" nodename="N_clamp_float" />
      <input name="in2" type="float" nodename="N_remap2_float" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="float" nodename="N_switch_float" />
  </nodegraph>
  <nodegraph name="NG_range_color3" nodedef="ND_range_color3">
    <remap name="N_remap1_color3" type="color3">
      <input name="in" type="color3" interfacename="in" />
      <input name="inlow" type="color3" interfacename="inlow" />
      <input name="inhigh" type="color3" interfacename="inhigh" />
      <input name="outlow" type="color3" value="0.0, 0.0, 0.0" />
      <input name="outhigh" type="color3" value="1.0, 1.0, 1.0" />
    </remap>
    <divide name="N_recip_color3" type="color3">
      <input name="in1" type="color3" value="1.0, 1.0, 1.0" />
      <input name="in2" type="color3" interfacename="gamma" />
    </divide>
    <absval name="N_abs_color3" type="color3">
      <input name="in" type="color3" nodename="N_remap1_color3" />
    </absval>
    <power name="N_pow_color3" type="color3">
      <input name="in1" type="color3" nodename="N_abs_color3" />
      <input name="in2" type="color3" nodename="N_recip_color3" />
    </power>
    <sign name="N_sign_color3" type="color3">
      <input name="in" type="color3" nodename="N_remap1_color3" />
    </sign>
    <multiply name="N_gamma_color3" type="color3">
      <input name="in1" type="color3" nodename="N_pow_color3" />
      <input name="in2" type="color3" nodename="N_sign_color3" />
    </multiply>
    <remap name="N_remap2_color3" type="color3">
      <input name="in" type="color3" nodename="N_gamma_color3" />
      <input name="inlow" type="color3" value="0.0, 0.0, 0.0" />
      <input name="inhigh" type="color3" value="1.0, 1.0, 1.0" />
      <input name="outlow" type="color3" interfacename="outlow" />
      <input name="outhigh" type="color3" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_color3" type="color3">
      <input name="in" type="color3" nodename="N_remap2_color3" />
      <input name="low" type="color3" interfacename="outlow" />
      <input name="high" type="color3" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_color3" type="color3">
      <input name="in1" type="color3" nodename="N_clamp_color3" />
      <input name="in2" type="color3" nodename="N_remap2_color3" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="color3" nodename="N_switch_color3" />
  </nodegraph>
  <nodegraph name="NG_range_color4" nodedef="ND_range_color4">
    <remap name="N_remap1_color4" type="color4">
      <input name="in" type="color4" interfacename="in" />
      <input name="inlow" type="color4" interfacename="inlow" />
      <input name="inhigh" type="color4" interfacename="inhigh" />
      <input name="outlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
      <input name="outhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    </remap>
    <divide name="N_recip_color4" type="color4">
      <input name="in1" type="color4" value="1.0, 1.0, 1.0, 1.0" />
      <input name="in2" type="color4" interfacename="gamma" />
    </divide>
    <absval name="N_abs_color4" type="color4">
      <input name="in" type="color4" nodename="N_remap1_color4" />
    </absval>
    <power name="N_pow_color4" type="color4">
      <input name="in1" type="color4" nodename="N_abs_color4" />
      <input name="in2" type="color4" nodename="N_recip_color4" />
    </power>
    <sign name="N_sign_color4" type="color4">
      <input name="in" type="color4" nodename="N_remap1_color4" />
    </sign>
    <multiply name="N_gamma_color4" type="color4">
      <input name="in1" type="color4" nodename="N_pow_color4" />
      <input name="in2" type="color4" nodename="N_sign_color4" />
    </multiply>
    <remap name="N_remap2_color4" type="color4">
      <input name="in" type="color4" nodename="N_gamma_color4" />
      <input name="inlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
      <input name="inhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
      <input name="outlow" type="color4" interfacename="outlow" />
      <input name="outhigh" type="color4" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_color4" type="color4">
      <input name="in" type="color4" nodename="N_remap2_color4" />
      <input name="low" type="color4" interfacename="outlow" />
      <input name="high" type="color4" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_color4" type="color4">
      <input name="in1" type="color4" nodename="N_clamp_color4" />
      <input name="in2" type="color4" nodename="N_remap2_color4" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <input name="value1" type="boolean" interfacename="doclamp" />
    <output name="out" type="color4" nodename="N_switch_color4" />
  </nodegraph>
  <nodegraph name="NG_range_vector2" nodedef="ND_range_vector2">
    <remap name="N_remap1_vector2" type="vector2">
      <input name="in" type="vector2" interfacename="in" />
      <input name="inlow" type="vector2" interfacename="inlow" />
      <input name="inhigh" type="vector2" interfacename="inhigh" />
      <input name="outlow" type="vector2" value="0.0, 0.0" />
      <input name="outhigh" type="vector2" value="1.0, 1.0" />
    </remap>
    <divide name="N_recip_vector2" type="vector2">
      <input name="in1" type="vector2" value="1.0, 1.0" />
      <input name="in2" type="vector2" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector2" type="vector2">
      <input name="in" type="vector2" nodename="N_remap1_vector2" />
    </absval>
    <power name="N_pow_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_abs_vector2" />
      <input name="in2" type="vector2" nodename="N_recip_vector2" />
    </power>
    <sign name="N_sign_vector2" type="vector2">
      <input name="in" type="vector2" nodename="N_remap1_vector2" />
    </sign>
    <multiply name="N_gamma_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_pow_vector2" />
      <input name="in2" type="vector2" nodename="N_sign_vector2" />
    </multiply>
    <remap name="N_remap2_vector2" type="vector2">
      <input name="in" type="vector2" nodename="N_gamma_vector2" />
      <input name="inlow" type="vector2" value="0.0, 0.0" />
      <input name="inhigh" type="vector2" value="1.0, 1.0" />
      <input name="outlow" type="vector2" interfacename="outlow" />
      <input name="outhigh" type="vector2" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector2" type="vector2">
      <input name="in" type="vector2" nodename="N_remap2_vector2" />
      <input name="low" type="vector2" interfacename="outlow" />
      <input name="high" type="vector2" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector2" type="vector2">
      <input name="in1" type="vector2" nodename="N_clamp_vector2" />
      <input name="in2" type="vector2" nodename="N_remap2_vector2" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector2" nodename="N_switch_vector2" />
  </nodegraph>
  <nodegraph name="NG_range_vector3" nodedef="ND_range_vector3">
    <remap name="N_remap1_vector3" type="vector3">
      <input name="in" type="vector3" interfacename="in" />
      <input name="inlow" type="vector3" interfacename="inlow" />
      <input name="inhigh" type="vector3" interfacename="inhigh" />
      <input name="outlow" type="vector3" value="0.0, 0.0, 0.0" />
      <input name="outhigh" type="vector3" value="1.0, 1.0, 1.0" />
    </remap>
    <divide name="N_recip_vector3" type="vector3">
      <input name="in1" type="vector3" value="1.0, 1.0, 1.0" />
      <input name="in2" type="vector3" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector3" type="vector3">
      <input name="in" type="vector3" nodename="N_remap1_vector3" />
    </absval>
    <power name="N_pow_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_abs_vector3" />
      <input name="in2" type="vector3" nodename="N_recip_vector3" />
    </power>
    <sign name="N_sign_vector3" type="vector3">
      <input name="in" type="vector3" nodename="N_remap1_vector3" />
    </sign>
    <multiply name="N_gamma_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_pow_vector3" />
      <input name="in2" type="vector3" nodename="N_sign_vector3" />
    </multiply>
    <remap name="N_remap2_vector3" type="vector3">
      <input name="in" type="vector3" nodename="N_gamma_vector3" />
      <input name="inlow" type="vector3" value="0.0, 0.0, 0.0" />
      <input name="inhigh" type="vector3" value="1.0, 1.0, 1.0" />
      <input name="outlow" type="vector3" interfacename="outlow" />
      <input name="outhigh" type="vector3" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector3" type="vector3">
      <input name="in" type="vector3" nodename="N_remap2_vector3" />
      <input name="low" type="vector3" interfacename="outlow" />
      <input name="high" type="vector3" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector3" type="vector3">
      <input name="in1" type="vector3" nodename="N_clamp_vector3" />
      <input name="in2" type="vector3" nodename="N_remap2_vector3" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector3" nodename="N_switch_vector3" />
  </nodegraph>
  <nodegraph name="NG_range_vector4" nodedef="ND_range_vector4">
    <remap name="N_remap1_vector4" type="vector4">
      <input name="in" type="vector4" interfacename="in" />
      <input name="inlow" type="vector4" interfacename="inlow" />
      <input name="inhigh" type="vector4" interfacename="inhigh" />
      <input name="outlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
      <input name="outhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    </remap>
    <divide name="N_recip_vector4" type="vector4">
      <input name="in1" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
      <input name="in2" type="vector4" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector4" type="vector4">
      <input name="in" type="vector4" nodename="N_remap1_vector4" />
    </absval>
    <power name="N_pow_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_abs_vector4" />
      <input name="in2" type="vector4" nodename="N_recip_vector4" />
    </power>
    <sign name="N_sign_vector4" type="vector4">
      <input name="in" type="vector4" nodename="N_remap1_vector4" />
    </sign>
    <multiply name="N_gamma_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_pow_vector4" />
      <input name="in2" type="vector4" nodename="N_sign_vector4" />
    </multiply>
    <remap name="N_remap2_vector4" type="vector4">
      <input name="in" type="vector4" nodename="N_gamma_vector4" />
      <input name="inlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
      <input name="inhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
      <input name="outlow" type="vector4" interfacename="outlow" />
      <input name="outhigh" type="vector4" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector4" type="vector4">
      <input name="in" type="vector4" nodename="N_remap2_vector4" />
      <input name="low" type="vector4" interfacename="outlow" />
      <input name="high" type="vector4" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector4" type="vector4">
      <input name="in1" type="vector4" nodename="N_clamp_vector4" />
      <input name="in2" type="vector4" nodename="N_remap2_vector4" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector4" nodename="N_switch_vector4" />
  </nodegraph>
  <nodegraph name="NG_range_color3FA" nodedef="ND_range_color3FA">
    <remap name="N_remap1_color3FA" type="color3">
      <input name="in" type="color3" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_color3FA" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_color3FA" type="color3">
      <input name="in" type="color3" nodename="N_remap1_color3FA" />
    </absval>
    <power name="N_pow_color3FA" type="color3">
      <input name="in1" type="color3" nodename="N_abs_color3FA" />
      <input name="in2" type="float" nodename="N_recip_color3FA" />
    </power>
    <sign name="N_sign_color3FA" type="color3">
      <input name="in" type="color3" nodename="N_remap1_color3FA" />
    </sign>
    <multiply name="N_gamma_color3FA" type="color3">
      <input name="in1" type="color3" nodename="N_pow_color3FA" />
      <input name="in2" type="color3" nodename="N_sign_color3FA" />
    </multiply>
    <remap name="N_remap2_color3FA" type="color3">
      <input name="in" type="color3" nodename="N_gamma_color3FA" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_color3FA" type="color3">
      <input name="in" type="color3" nodename="N_remap2_color3FA" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_color3FA" type="color3">
      <input name="in1" type="color3" nodename="N_clamp_color3FA" />
      <input name="in2" type="color3" nodename="N_remap2_color3FA" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="color3" nodename="N_switch_color3FA" />
  </nodegraph>
  <nodegraph name="NG_range_color4FA" nodedef="ND_range_color4FA">
    <remap name="N_remap1_color4FA" type="color4">
      <input name="in" type="color4" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_color4FA" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_color4FA" type="color4">
      <input name="in" type="color4" nodename="N_remap1_color4FA" />
    </absval>
    <power name="N_pow_color4FA" type="color4">
      <input name="in1" type="color4" nodename="N_abs_color4FA" />
      <input name="in2" type="float" nodename="N_recip_color4FA" />
    </power>
    <sign name="N_sign_color4FA" type="color4">
      <input name="in" type="color4" nodename="N_remap1_color4FA" />
    </sign>
    <multiply name="N_gamma_color4FA" type="color4">
      <input name="in1" type="color4" nodename="N_pow_color4FA" />
      <input name="in2" type="color4" nodename="N_sign_color4FA" />
    </multiply>
    <remap name="N_remap2_color4FA" type="color4">
      <input name="in" type="color4" nodename="N_gamma_color4FA" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_color4FA" type="color4">
      <input name="in" type="color4" nodename="N_remap2_color4FA" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_color4FA" type="color4">
      <input name="in1" type="color4" nodename="N_clamp_color4FA" />
      <input name="in2" type="color4" nodename="N_remap2_color4FA" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="color4" nodename="N_switch_color4FA" />
  </nodegraph>
  <nodegraph name="NG_range_vector2FA" nodedef="ND_range_vector2FA">
    <remap name="N_remap1_vector2FA" type="vector2">
      <input name="in" type="vector2" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_vector2FA" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector2FA" type="vector2">
      <input name="in" type="vector2" nodename="N_remap1_vector2FA" />
    </absval>
    <power name="N_pow_vector2FA" type="vector2">
      <input name="in1" type="vector2" nodename="N_abs_vector2FA" />
      <input name="in2" type="float" nodename="N_recip_vector2FA" />
    </power>
    <sign name="N_sign_vector2FA" type="vector2">
      <input name="in" type="vector2" nodename="N_remap1_vector2FA" />
    </sign>
    <multiply name="N_gamma_vector2FA" type="vector2">
      <input name="in1" type="vector2" nodename="N_pow_vector2FA" />
      <input name="in2" type="vector2" nodename="N_sign_vector2FA" />
    </multiply>
    <remap name="N_remap2_vector2FA" type="vector2">
      <input name="in" type="vector2" nodename="N_gamma_vector2FA" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector2FA" type="vector2">
      <input name="in" type="vector2" nodename="N_remap2_vector2FA" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector2FA" type="vector2">
      <input name="in1" type="vector2" nodename="N_clamp_vector2FA" />
      <input name="in2" type="vector2" nodename="N_remap2_vector2FA" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector2" nodename="N_switch_vector2FA" />
  </nodegraph>
  <nodegraph name="NG_range_vector3FA" nodedef="ND_range_vector3FA">
    <remap name="N_remap1_vector3FA" type="vector3">
      <input name="in" type="vector3" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_vector3FA" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector3FA" type="vector3">
      <input name="in" type="vector3" nodename="N_remap1_vector3FA" />
    </absval>
    <power name="N_pow_vector3FA" type="vector3">
      <input name="in1" type="vector3" nodename="N_abs_vector3FA" />
      <input name="in2" type="float" nodename="N_recip_vector3FA" />
    </power>
    <sign name="N_sign_vector3FA" type="vector3">
      <input name="in" type="vector3" nodename="N_remap1_vector3FA" />
    </sign>
    <multiply name="N_gamma_vector3FA" type="vector3">
      <input name="in1" type="vector3" nodename="N_pow_vector3FA" />
      <input name="in2" type="vector3" nodename="N_sign_vector3FA" />
    </multiply>
    <remap name="N_remap2_vector3FA" type="vector3">
      <input name="in" type="vector3" nodename="N_gamma_vector3FA" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector3FA" type="vector3">
      <input name="in" type="vector3" nodename="N_remap2_vector3FA" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector3FA" type="vector3">
      <input name="in1" type="vector3" nodename="N_clamp_vector3FA" />
      <input name="in2" type="vector3" nodename="N_remap2_vector3FA" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector3" nodename="N_switch_vector3FA" />
  </nodegraph>
  <nodegraph name="NG_range_vector4FA" nodedef="ND_range_vector4FA">
    <remap name="N_remap1_vector4FA" type="vector4">
      <input name="in" type="vector4" interfacename="in" />
      <input name="inlow" type="float" interfacename="inlow" />
      <input name="inhigh" type="float" interfacename="inhigh" />
      <input name="outlow" type="float" value="0.0" />
      <input name="outhigh" type="float" value="1.0" />
    </remap>
    <divide name="N_recip_vector4FA" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="gamma" />
    </divide>
    <absval name="N_abs_vector4FA" type="vector4">
      <input name="in" type="vector4" nodename="N_remap1_vector4FA" />
    </absval>
    <power name="N_pow_vector4FA" type="vector4">
      <input name="in1" type="vector4" nodename="N_abs_vector4FA" />
      <input name="in2" type="float" nodename="N_recip_vector4FA" />
    </power>
    <sign name="N_sign_vector4FA" type="vector4">
      <input name="in" type="vector4" nodename="N_remap1_vector4FA" />
    </sign>
    <multiply name="N_gamma_vector4FA" type="vector4">
      <input name="in1" type="vector4" nodename="N_pow_vector4FA" />
      <input name="in2" type="vector4" nodename="N_sign_vector4FA" />
    </multiply>
    <remap name="N_remap2_vector4FA" type="vector4">
      <input name="in" type="vector4" nodename="N_gamma_vector4FA" />
      <input name="inlow" type="float" value="0.0" />
      <input name="inhigh" type="float" value="1.0" />
      <input name="outlow" type="float" interfacename="outlow" />
      <input name="outhigh" type="float" interfacename="outhigh" />
    </remap>
    <clamp name="N_clamp_vector4FA" type="vector4">
      <input name="in" type="vector4" nodename="N_remap2_vector4FA" />
      <input name="low" type="float" interfacename="outlow" />
      <input name="high" type="float" interfacename="outhigh" />
    </clamp>
    <ifequal name="N_switch_vector4FA" type="vector4">
      <input name="in1" type="vector4" nodename="N_clamp_vector4FA" />
      <input name="in2" type="vector4" nodename="N_remap2_vector4FA" />
      <input name="value1" type="boolean" interfacename="doclamp" />
      <input name="value2" type="boolean" value="true" />
    </ifequal>
    <output name="out" type="vector4" nodename="N_switch_vector4FA" />
  </nodegraph>

  <!--
    Node: <hsvadjust>
    Adjust the hue, saturation and value of an RGB color by converting the input color
    to HSV, adding amount.x to the hue, multiplying the saturation by amount.y,
    multiplying the value by amount.z, then converting back to RGB.
  -->
  <nodegraph name="NG_hsvadjust_color3" nodedef="ND_hsvadjust_color3">
    <rgbtohsv name="N_inhsv_color3" type="color3">
      <input name="in" type="color3" interfacename="in" />
    </rgbtohsv>
    <convert name="N_camount_color3" type="color3">
      <input name="in" type="vector3" interfacename="amount" />
    </convert>
    <multiply name="N_hchans_color3" type="color3">
      <input name="in1" type="color3" nodename="N_camount_color3" />
      <input name="in2" type="color3" value="1.0, 0.0, 0.0" />
    </multiply>
    <multiply name="N_tmp1_color3" type="color3">
      <input name="in1" type="color3" nodename="N_camount_color3" />
      <input name="in2" type="color3" value="0.0, 1.0, 1.0" />
    </multiply>
    <add name="N_svchans_color3" type="color3">
      <input name="in1" type="color3" nodename="N_tmp1_color3" />
      <input name="in2" type="color3" value="1.0, 0.0, 0.0" />
    </add>
    <add name="N_tmp2_color3" type="color3">
      <input name="in1" type="color3" nodename="N_inhsv_color3" />
      <input name="in2" type="color3" nodename="N_hchans_color3" />
    </add>
    <multiply name="N_tmp3_color3" type="color3">
      <input name="in1" type="color3" nodename="N_tmp2_color3" />
      <input name="in2" type="color3" nodename="N_svchans_color3" />
    </multiply>
    <hsvtorgb name="N_torgb_color3" type="color3">
      <input name="in" type="color3" nodename="N_tmp3_color3" />
    </hsvtorgb>
    <output name="out" type="color3" nodename="N_torgb_color3" />
  </nodegraph>
  <nodegraph name="NG_hsvadjust_color4" nodedef="ND_hsvadjust_color4">
    <rgbtohsv name="N_inhsv_color4" type="color4">
      <input name="in" type="color4" interfacename="in" />
    </rgbtohsv>
    <convert name="N_camt_color3" type="color3">
      <input name="in" type="vector3" interfacename="amount" />
    </convert>
    <convert name="N_camount_color4" type="color4">
      <input name="in" type="color3" nodename="N_camt_color3" />
    </convert>
    <multiply name="N_hchans_color4" type="color4">
      <input name="in1" type="color4" nodename="N_camount_color4" />
      <input name="in2" type="color4" value="1.0, 0.0, 0.0, 0.0" />
    </multiply>
    <multiply name="N_tmp1_color4" type="color4">
      <input name="in1" type="color4" nodename="N_camount_color4" />
      <input name="in2" type="color4" value="0.0, 1.0, 1.0, 0.0" />
    </multiply>
    <add name="N_svchans_color4" type="color4">
      <input name="in1" type="color4" nodename="N_tmp1_color4" />
      <input name="in2" type="color4" value="1.0, 0.0, 0.0, 1.0" />
    </add>
    <add name="N_tmp2_color4" type="color4">
      <input name="in1" type="color4" nodename="N_inhsv_color4" />
      <input name="in2" type="color4" nodename="N_hchans_color4" />
    </add>
    <multiply name="N_tmp3_color4" type="color4">
      <input name="in1" type="color4" nodename="N_tmp2_color4" />
      <input name="in2" type="color4" nodename="N_svchans_color4" />
    </multiply>
    <hsvtorgb name="N_torgb_color4" type="color4">
      <input name="in" type="color4" nodename="N_tmp3_color4" />
    </hsvtorgb>
    <output name="out" type="color4" nodename="N_torgb_color4" />
  </nodegraph>

  <!--
    Node: <saturate>
    Adjust the saturation of a color using a linear interpolation between the incoming
    color and the grayscale luminance of the input computed using the provided luma
    coefficients; the alpha channel will be unchanged if present.
  -->
  <nodegraph name="NG_saturate_color3" nodedef="ND_saturate_color3">
    <luminance name="N_gray_color3" type="color3">
      <input name="in" type="color3" interfacename="in" />
      <input name="lumacoeffs" type="color3" interfacename="lumacoeffs" />
    </luminance>
    <mix name="N_mix_color3" type="color3">
      <input name="bg" type="color3" nodename="N_gray_color3" />
      <input name="fg" type="color3" interfacename="in" />
      <input name="mix" type="float" interfacename="amount" />
    </mix>
    <output name="out" type="color3" nodename="N_mix_color3" />
  </nodegraph>
  <nodegraph name="NG_saturate_color4" nodedef="ND_saturate_color4">
    <luminance name="N_gray_color4" type="color4">
      <input name="in" type="color4" interfacename="in" />
      <input name="lumacoeffs" type="color3" interfacename="lumacoeffs" />
    </luminance>
    <mix name="N_mix_color4" type="color4">
      <input name="bg" type="color4" nodename="N_gray_color4" />
      <input name="fg" type="color4" interfacename="in" />
      <input name="mix" type="float" interfacename="amount" />
    </mix>
    <output name="out" type="color4" nodename="N_mix_color4" />
  </nodegraph>

  <!-- ======================================================================== -->
  <!-- Compositing nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- ======================================================================== -->
  <!-- Conditional nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- ======================================================================== -->
  <!-- Channel nodes                                                            -->
  <!-- ======================================================================== -->

  <!--
    Node: <extract>
    Extract a single channel from a colorN or vectorN stream, outputting a float.
  -->
  <nodegraph name="NG_extract_vector2" nodedef="ND_extract_vector2">
    <swizzle name="N_x_vector2" type="float">
      <input name="in" type="vector2" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector2" type="float">
      <input name="in" type="vector2" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <switch name="N_sw_vector2" type="float">
      <input name="in1" type="float" nodename="N_x_vector2" />
      <input name="in2" type="float" nodename="N_y_vector2" />
      <input name="which" type="integer" interfacename="index" />
    </switch>
    <output name="out" type="float" nodename="N_sw_vector2" />
  </nodegraph>
  <nodegraph name="NG_extract_color3" nodedef="ND_extract_color3">
    <swizzle name="N_r_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="r" />
    </swizzle>
    <swizzle name="N_g_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="g" />
    </swizzle>
    <swizzle name="N_b_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="b" />
    </swizzle>
    <switch name="N_sw_color3" type="float">
      <input name="in1" type="float" nodename="N_r_color3" />
      <input name="in2" type="float" nodename="N_g_color3" />
      <input name="in3" type="float" nodename="N_b_color3" />
      <input name="which" type="integer" interfacename="index" />
    </switch>
    <output name="out" type="float" nodename="N_sw_color3" />
  </nodegraph>
  <nodegraph name="NG_extract_vector3" nodedef="ND_extract_vector3">
    <swizzle name="N_x_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <swizzle name="N_z_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="z" />
    </swizzle>
    <switch name="N_sw_vector3" type="float">
      <input name="in1" type="float" nodename="N_x_vector3" />
      <input name="in2" type="float" nodename="N_y_vector3" />
      <input name="in3" type="float" nodename="N_z_vector3" />
      <input name="which" type="integer" interfacename="index" />
    </switch>
    <output name="out" type="float" nodename="N_sw_vector3" />
  </nodegraph>
  <nodegraph name="NG_extract_color4" nodedef="ND_extract_color4">
    <swizzle name="N_r_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="r" />
    </swizzle>
    <swizzle name="N_g_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="g" />
    </swizzle>
    <swizzle name="N_b_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="b" />
    </swizzle>
    <swizzle name="N_a_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="a" />
    </swizzle>
    <switch name="N_sw_color4" type="float">
      <input name="in1" type="float" nodename="N_r_color4" />
      <input name="in2" type="float" nodename="N_g_color4" />
      <input name="in3" type="float" nodename="N_b_color4" />
      <input name="in4" type="float" nodename="N_a_color4" />
      <input name="which" type="integer" interfacename="index" />
    </switch>
    <output name="out" type="float" nodename="N_sw_color4" />
  </nodegraph>
  <nodegraph name="NG_extract_vector4" nodedef="ND_extract_vector4">
    <swizzle name="N_x_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <swizzle name="N_z_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="z" />
    </swizzle>
    <swizzle name="N_w_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="w" />
    </swizzle>
    <switch name="N_sw_vector4" type="float">
      <input name="in1" type="float" nodename="N_x_vector4" />
      <input name="in2" type="float" nodename="N_y_vector4" />
      <input name="in3" type="float" nodename="N_z_vector4" />
      <input name="in4" type="float" nodename="N_w_vector4" />
      <input name="which" type="integer" interfacename="index" />
    </switch>
    <output name="out" type="float" nodename="N_sw_vector4" />
  </nodegraph>

  <!--
    Nodes: <separate2>, <separate3>, <separate4>
    Output each of the channels of a color/vector stream as a separate float output.
  -->
  <nodegraph name="NG_separate2_vector2" nodedef="ND_separate2_vector2">
    <swizzle name="N_x_vector2" type="float">
      <input name="in" type="vector2" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector2" type="float">
      <input name="in" type="vector2" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <output name="outx" type="float" nodename="N_x_vector2" />
    <output name="outy" type="float" nodename="N_y_vector2" />
  </nodegraph>
  <nodegraph name="NG_separate3_color3" nodedef="ND_separate3_color3">
    <swizzle name="N_r_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="r" />
    </swizzle>
    <swizzle name="N_g_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="g" />
    </swizzle>
    <swizzle name="N_b_color3" type="float">
      <input name="in" type="color3" interfacename="in" />
      <input name="channels" type="string" value="b" />
    </swizzle>
    <output name="outr" type="float" nodename="N_r_color3" />
    <output name="outg" type="float" nodename="N_g_color3" />
    <output name="outb" type="float" nodename="N_b_color3" />
  </nodegraph>
  <nodegraph name="NG_separate3_vector3" nodedef="ND_separate3_vector3">
    <swizzle name="N_x_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <swizzle name="N_z_vector3" type="float">
      <input name="in" type="vector3" interfacename="in" />
      <input name="channels" type="string" value="z" />
    </swizzle>
    <output name="outx" type="float" nodename="N_x_vector3" />
    <output name="outy" type="float" nodename="N_y_vector3" />
    <output name="outz" type="float" nodename="N_z_vector3" />
  </nodegraph>
  <nodegraph name="NG_separate4_color4" nodedef="ND_separate4_color4">
    <swizzle name="N_r_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="r" />
    </swizzle>
    <swizzle name="N_g_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="g" />
    </swizzle>
    <swizzle name="N_b_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="b" />
    </swizzle>
    <swizzle name="N_a_color4" type="float">
      <input name="in" type="color4" interfacename="in" />
      <input name="channels" type="string" value="a" />
    </swizzle>
    <output name="outr" type="float" nodename="N_r_color4" />
    <output name="outg" type="float" nodename="N_g_color4" />
    <output name="outb" type="float" nodename="N_b_color4" />
    <output name="outa" type="float" nodename="N_a_color4" />
  </nodegraph>
  <nodegraph name="NG_separate4_vector4" nodedef="ND_separate4_vector4">
    <swizzle name="N_x_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="x" />
    </swizzle>
    <swizzle name="N_y_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="y" />
    </swizzle>
    <swizzle name="N_z_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="z" />
    </swizzle>
    <swizzle name="N_w_vector4" type="float">
      <input name="in" type="vector4" interfacename="in" />
      <input name="channels" type="string" value="w" />
    </swizzle>
    <output name="outx" type="float" nodename="N_x_vector4" />
    <output name="outy" type="float" nodename="N_y_vector4" />
    <output name="outz" type="float" nodename="N_z_vector4" />
    <output name="outw" type="float" nodename="N_w_vector4" />
  </nodegraph>

  <!-- ======================================================================== -->
  <!-- Convolution nodes                                                        -->
  <!-- ======================================================================== -->

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2019 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Declarations of standard data types and nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Data types                                                               -->
  <!-- ======================================================================== -->

  <typedef name="boolean" />
  <typedef name="integer" />
  <typedef name="float" />
  <typedef name="color3" semantic="color" />
  <typedef name="color4" semantic="color" />
  <typedef name="vector2" />
  <typedef name="vector3" />
  <typedef name="vector4" />
  <typedef name="matrix33" />
  <typedef name="matrix44" />
  <typedef name="string" />
  <typedef name="filename" />
  <typedef name="geomname" />
  <typedef name="surfaceshader" semantic="shader" context="surface" />
  <typedef name="displacementshader" semantic="shader" context="displacement" />
  <typedef name="volumeshader" semantic="shader" context="volume" />
  <typedef name="lightshader" semantic="shader" context="light" />
  <typedef name="material" semantic="material" />
  <typedef name="none" />

  <typedef name="integerarray" />
  <typedef name="floatarray" />
  <typedef name="color3array" semantic="color" />
  <typedef name="color4array" semantic="color" />
  <typedef name="vector2array" />
  <typedef name="vector3array" />
  <typedef name="vector4array" />
  <typedef name="stringarray" />
  <typedef name="geomnamearray" />

  <!-- ======================================================================== -->
  <!-- Units and unit types                                                     -->
  <!-- ======================================================================== -->

  <unittypedef name="distance" />
  <unitdef name="UD_stdlib_distance" unittype="distance">
    <unit name="nanometer" scale="0.000000001" />
    <unit name="micron" scale="0.000001" />
    <unit name="millimeter" scale="0.001" />
    <unit name="centimeter" scale="0.01" />
    <unit name="inch" scale="0.0254" />
    <unit name="foot" scale="0.3048" />
    <unit name="yard" scale="0.9144" />
    <unit name="meter" scale="1.0" />
    <unit name="kilometer" scale="1000.0" />
    <unit name="mile" scale="1609.344" />
  </unitdef>

  <unittypedef name="angle" />
  <unitdef name="UD_stdlib_angle" unittype="angle">
    <unit name="degree" scale="1.0" />
    <unit name="radian" scale="57.295779513" />
  </unitdef>

  <!-- ======================================================================== -->
  <!-- Geometric Properties                                                     -->
  <!-- ======================================================================== -->

  <geompropdef name="Pobject" type="vector3" geomprop="position" space="object" />
  <geompropdef name="Nobject" type="vector3" geomprop="normal" space="object" />
  <geompropdef name="Tobject" type="vector3" geomprop="tangent" space="object" index="0" />
  <geompropdef name="Bobject" type="vector3" geomprop="bitangent" space="object" index="0" />
  <geompropdef name="Pworld" type="vector3" geomprop="position" space="world" />
  <geompropdef name="Nworld" type="vector3" geomprop="normal" space="world" />
  <geompropdef name="Tworld" type="vector3" geomprop="tangent" space="world" index="0" />
  <geompropdef name="Bworld" type="vector3" geomprop="bitangent" space="world" index="0" />
  <geompropdef name="UV0" type="vector2" geomprop="texcoord" index="0" />

  <!-- ======================================================================== -->
  <!-- Materials                                                                -->
  <!-- ======================================================================== -->

  <!-- Surface material -->
  <nodedef name="ND_surfacematerial" node="surfacematerial" nodegroup="material">
    <input name="surfaceshader" type="surfaceshader" value="" />
    <input name="displacementshader" type="displacementshader" value="" />
    <output name="out" type="material" />
  </nodedef>

  <!-- Volume material -->
  <nodedef name="ND_volumematerial" node="volumematerial" nodegroup="material">
    <input name="volumeshader" type="volumeshader" value="" />
    <output name="out" type="material" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Shader nodes                                                             -->
  <!-- ======================================================================== -->

  <!--
    Node: <surface>
    An unlit surface shader node. Represents a surface that can emit and transmit light, 
    but does not receive illumination from light sources or other surfaces.
  -->
  <nodedef name="ND_surface_unlit" node="surface" nodegroup="shader" doc="Construct a surface shader from emission and transmission values.">
    <input name="emission" type="float" value="0.0" doc="Surface emission amount." />
    <input name="emission_color" type="color3" value="1,1,1" doc="Surface emission color." />
    <input name="transmission" type="float" value="0.0" doc="Surface transmission amount." />
    <input name="transmission_color" type="color3" value="1,1,1" doc="Surface transmission color." />
    <input name="opacity" type="float" value="1.0" doc="Surface cutout opacity." />
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Texture nodes                                                            -->
  <!-- ======================================================================== -->

  <!--
    Node: <image>
    Samples data from a single image, or from a layer within a multi-layer image.
  -->
  <nodedef name="ND_image_float" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="float" value="0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_image_color3" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="color3" value="0.0, 0.0, 0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_image_color4" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="color4" value="0.0, 0.0, 0.0, 0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_image_vector2" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="vector2" value="0.0, 0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_image_vector3" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="vector3" value="0.0, 0.0, 0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_image_vector4" node="image" nodegroup="texture2d">
    <input name="file" type="filename" value="" uiname="Filename" uniform="true" />
    <input name="layer" type="string" value="" uiname="Layer" uniform="true" />
    <input name="default" type="vector4" value="0.0, 0.0, 0.0, 0.0" uiname="Default Color" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" uiname="Texture Coordinates" />
    <input name="uaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode U" uniform="true" />
    <input name="vaddressmode" type="string" value="periodic" enum="constant,clamp,periodic,mirror" uiname="Address Mode V" uniform="true" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uiname="Filter Type" uniform="true" />
    <input name="framerange" type="string" value="" uiname="Frame Range" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uiname="Frame Offset" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uiname="Frame End Action" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <tiledimage> Supplemental Node
    Samples data from a single image, with provisions for tiling and offsetting the image
    across uv space.
  -->
  <nodedef name="ND_tiledimage_float" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_tiledimage_color3" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="color3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_tiledimage_color4" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_tiledimage_vector2" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="vector2" value="0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_tiledimage_vector3" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_tiledimage_vector4" node="tiledimage" nodegroup="texture2d">
    <input name="file" type="filename" value="" uniform="true" />
    <input name="default" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="uvtiling" type="vector2" value="1.0, 1.0" />
    <input name="uvoffset" type="vector2" value="0.0, 0.0" />
    <input name="realworldimagesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="realworldtilesize" type="vector2" value="1.0, 1.0" unittype="distance" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <triplanarprojection> Supplemental Node
    Samples data from three images, or layers within multi-layer images, and projects a tiled
    representation of the images along each of the three respective coordinate axes, computing
    a weighted blend of the three samples using the geometric normal.
  -->
  <nodedef name="ND_triplanarprojection_float" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_triplanarprojection_color3" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="color3" value="0.0, 0.0, 0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_triplanarprojection_color4" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_triplanarprojection_vector2" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="vector2" value="0.0, 0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_triplanarprojection_vector3" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_triplanarprojection_vector4" node="triplanarprojection" nodegroup="texture3d">
    <input name="filex" type="filename" value="" uniform="true" />
    <input name="filey" type="filename" value="" uniform="true" />
    <input name="filez" type="filename" value="" uniform="true" />
    <input name="layerx" type="string" value="" uniform="true" />
    <input name="layery" type="string" value="" uniform="true" />
    <input name="layerz" type="string" value="" uniform="true" />
    <input name="default" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="normal" type="vector3" defaultgeomprop="Nobject" />
    <input name="filtertype" type="string" value="linear" enum="closest,linear,cubic" uniform="true" />
    <input name="framerange" type="string" value="" uniform="true" />
    <input name="frameoffset" type="integer" value="0" uniform="true" />
    <input name="frameendaction" type="string" value="constant" enum="constant,clamp,periodic,mirror" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Procedural nodes                                                         -->
  <!-- ======================================================================== -->

  <!--
    Node: <constant>
    A constant value. When exposed as a public parameter, this is a way to create a
    value that can be accessed in multiple places in the opgraph.
  -->
  <nodedef name="ND_constant_float" node="constant" nodegroup="procedural">
    <input name="value" type="float" value="0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_constant_color3" node="constant" nodegroup="procedural">
    <input name="value" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_constant_color4" node="constant" nodegroup="procedural">
    <input name="value" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_constant_vector2" node="constant" nodegroup="procedural">
    <input name="value" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_constant_vector3" node="constant" nodegroup="procedural">
    <input name="value" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_constant_vector4" node="constant" nodegroup="procedural">
    <input name="value" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_constant_boolean" node="constant" nodegroup="procedural">
    <input name="value" type="boolean" value="false" />
    <output name="out" type="boolean" default="false" />
  </nodedef>
  <nodedef name="ND_constant_integer" node="constant" nodegroup="procedural">
    <input name="value" type="integer" value="0" />
    <output name="out" type="integer" default="0" />
  </nodedef>
  <nodedef name="ND_constant_matrix33" node="constant" nodegroup="procedural">
    <input name="value" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="matrix33" default="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
  </nodedef>
  <nodedef name="ND_constant_matrix44" node="constant" nodegroup="procedural">
    <input name="value" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="matrix44" default="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
  </nodedef>
  <nodedef name="ND_constant_string" node="constant" nodegroup="procedural">
    <input name="value" type="string" value="" uniform="true" />
    <output name="out" type="string" default="" />
  </nodedef>
  <nodedef name="ND_constant_filename" node="constant" nodegroup="procedural">
    <input name="value" type="filename" value="" uniform="true" />
    <output name="out" type="filename" default="" />
  </nodedef>

  <!--
    Node: <ramplr>
    A left-to-right bilinear value ramp.
  -->
  <nodedef name="ND_ramplr_float" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="float" value="0.0" />
    <input name="valuer" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_ramplr_color3" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="color3" value="0.0, 0.0, 0.0" />
    <input name="valuer" type="color3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramplr_color4" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuer" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramplr_vector2" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="vector2" value="0.0, 0.0" />
    <input name="valuer" type="vector2" value="0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramplr_vector3" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="valuer" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramplr_vector4" node="ramplr" nodegroup="procedural2d">
    <input name="valuel" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuer" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <ramptb>
    A top-to-bottom bilinear value ramp.
  -->
  <nodedef name="ND_ramptb_float" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="float" value="0.0" />
    <input name="valueb" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_ramptb_color3" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="color3" value="0.0, 0.0, 0.0" />
    <input name="valueb" type="color3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramptb_color4" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valueb" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramptb_vector2" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="vector2" value="0.0, 0.0" />
    <input name="valueb" type="vector2" value="0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramptb_vector3" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="valueb" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramptb_vector4" node="ramptb" nodegroup="procedural2d">
    <input name="valuet" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valueb" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <ramp4> Supplemental Node
    A 4-corner bilinear value ramp.
  -->
  <nodedef name="ND_ramp4_float" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="float" value="0.0" />
    <input name="valuetr" type="float" value="0.0" />
    <input name="valuebl" type="float" value="0.0" />
    <input name="valuebr" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_ramp4_color3" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="color3" value="0.0, 0.0, 0.0" />
    <input name="valuetr" type="color3" value="0.0, 0.0, 0.0" />
    <input name="valuebl" type="color3" value="0.0, 0.0, 0.0" />
    <input name="valuebr" type="color3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramp4_color4" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuetr" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuebl" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuebr" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramp4_vector2" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="vector2" value="0.0, 0.0" />
    <input name="valuetr" type="vector2" value="0.0, 0.0" />
    <input name="valuebl" type="vector2" value="0.0, 0.0" />
    <input name="valuebr" type="vector2" value="0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramp4_vector3" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="valuetr" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="valuebl" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="valuebr" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_ramp4_vector4" node="ramp4" nodegroup="procedural2d">
    <input name="valuetl" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuetr" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuebl" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="valuebr" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <splitlr>
    A left-right split matte, split at a specified u value.
  -->
  <nodedef name="ND_splitlr_float" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="float" value="0.0" uiname="Left" />
    <input name="valuer" type="float" value="0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_splitlr_color3" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="color3" value="0.0, 0.0, 0.0" uiname="Left" />
    <input name="valuer" type="color3" value="0.0, 0.0, 0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splitlr_color4" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="color4" value="0.0, 0.0, 0.0, 0.0" uiname="Left" />
    <input name="valuer" type="color4" value="0.0, 0.0, 0.0, 0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splitlr_vector2" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="vector2" value="0.0, 0.0" uiname="Left" />
    <input name="valuer" type="vector2" value="0.0, 0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splitlr_vector3" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="vector3" value="0.0, 0.0, 0.0" uiname="Left" />
    <input name="valuer" type="vector3" value="0.0, 0.0, 0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splitlr_vector4" node="splitlr" nodegroup="procedural2d">
    <input name="valuel" type="vector4" value="0.0, 0.0, 0.0, 0.0" uiname="Left" />
    <input name="valuer" type="vector4" value="0.0, 0.0, 0.0, 0.0" uiname="Right" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!--
    Node: <splittb>
    A top-bottom split matte, split at a specified v value.
  -->
  <nodedef name="ND_splittb_float" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="float" value="0.0" uiname="Top" />
    <input name="valueb" type="float" value="0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_splittb_color3" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="color3" value="0.0, 0.0, 0.0" uiname="Top" />
    <input name="valueb" type="color3" value="0.0, 0.0, 0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splittb_color4" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="color4" value="0.0, 0.0, 0.0, 0.0" uiname="Top" />
    <input name="valueb" type="color4" value="0.0, 0.0, 0.0, 0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splittb_vector2" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="vector2" value="0.0, 0.0" uiname="Top" />
    <input name="valueb" type="vector2" value="0.0, 0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splittb_vector3" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="vector3" value="0.0, 0.0, 0.0" uiname="Top" />
    <input name="valueb" type="vector3" value="0.0, 0.0, 0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_splittb_vector4" node="splittb" nodegroup="procedural2d">
    <input name="valuet" type="vector4" value="0.0, 0.0, 0.0, 0.0" uiname="Top" />
    <input name="valueb" type="vector4" value="0.0, 0.0, 0.0, 0.0" uiname="Bottom" />
    <input name="center" type="float" value="0.5" uiname="Center" uimin="0.0" uimax="1.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <noise2d>
    2D Perlin noise in 1, 2, 3 or 4 channels.
  -->
  <nodedef name="ND_noise2d_float" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_color3" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_color4" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector2" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="vector2" value="1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector3" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector4" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_color3FA" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_color4FA" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector2FA" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector3FA" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise2d_vector4FA" node="noise2d" nodegroup="procedural2d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <noise3d>
    3D Perlin noise in 1, 2, 3 or 4 channels.
  -->
  <nodedef name="ND_noise3d_float" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_color3" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_color4" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector2" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector2" value="1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector3" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector4" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_color3FA" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_color4FA" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector2FA" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector3FA" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_noise3d_vector4FA" node="noise3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.0" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <fractal3d>
    3D Fractal noise in 1, 2, 3 or 4 channels.
  -->
  <nodedef name="ND_fractal3d_float" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_color3" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_color4" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector2" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector2" value="1.0, 1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector3" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector4" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_color3FA" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_color4FA" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector2FA" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector3FA" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_fractal3d_vector4FA" node="fractal3d" nodegroup="procedural3d">
    <input name="amplitude" type="float" value="1.0" />
    <input name="octaves" type="integer" value="3" />
    <input name="lacunarity" type="float" value="2.0" />
    <input name="diminish" type="float" value="0.5" />
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <cellnoise2d>
    2D cellular noise in 1 channel.
  -->
  <nodedef name="ND_cellnoise2d_float" node="cellnoise2d" nodegroup="procedural2d">
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <cellnoise3d>
    3D cellular noise in 1 channel.
  -->
  <nodedef name="ND_cellnoise3d_float" node="cellnoise3d" nodegroup="procedural3d">
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <worleynoise2d>
    2D Worley (voronoi) noise in 1, 2 or 3 channels.
  -->
  <nodedef name="ND_worleynoise2d_float" node="worleynoise2d" nodegroup="procedural2d">
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_worleynoise2d_vector2" node="worleynoise2d" nodegroup="procedural2d">
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_worleynoise2d_vector3" node="worleynoise2d" nodegroup="procedural2d">
    <input name="texcoord" type="vector2" defaultgeomprop="UV0" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <worleynoise3d>
    3D Worley (voronoi) noise in 1, 2 or 3 channels.
  -->
  <nodedef name="ND_worleynoise3d_float" node="worleynoise3d" nodegroup="procedural3d">
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_worleynoise3d_vector2" node="worleynoise3d" nodegroup="procedural3d">
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_worleynoise3d_vector3" node="worleynoise3d" nodegroup="procedural3d">
    <input name="position" type="vector3" defaultgeomprop="Pobject" />
    <input name="jitter" type="float" value="1.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Geometric nodes                                                          -->
  <!-- ======================================================================== -->

  <!--
    Node: <position>
    The geometric position associated with the currently processed data,
    as defined in a specific coordinate space.
  -->
  <nodedef name="ND_position_vector3" node="position" nodegroup="geometric">
    <input name="space" type="string" value="object" enum="model,object,world" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <normal>
    The geometric normal associated with the currently processed data,
    as defined in a specific coordinate space.
  -->
  <nodedef name="ND_normal_vector3" node="normal" nodegroup="geometric">
    <input name="space" type="string" value="object" enum="model,object,world" uniform="true" />
    <output name="out" type="vector3" default="0.0, 1.0, 0.0" />
  </nodedef>

  <!--
    Node: <tangent>
    The geometric tangent vector associated with the currently processed data,
    as defined in a specific coordinate space.
  -->
  <nodedef name="ND_tangent_vector3" node="tangent" nodegroup="geometric">
    <input name="space" type="string" value="object" enum="model,object,world" uniform="true" />
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="vector3" default="1.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <bitangent>
    The geometric bitangent vector associated with the currently processed data,
    as defined in a specific coordinate space.
  -->
  <nodedef name="ND_bitangent_vector3" node="bitangent" nodegroup="geometric">
    <input name="space" type="string" value="object" enum="model,object,world" uniform="true" />
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 1.0" />
  </nodedef>

  <!--
    Node: <texcoord>
    The full 2D or 3D texture coordinates associated with the currently processed data.
  -->
  <nodedef name="ND_texcoord_vector2" node="texcoord" nodegroup="geometric">
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_texcoord_vector3" node="texcoord" nodegroup="geometric">
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <geomcolor>
    The color associated with the current geometry at the current position, generally
    bound via per-vertex color values.
  -->
  <nodedef name="ND_geomcolor_float" node="geomcolor" nodegroup="geometric">
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_geomcolor_color3" node="geomcolor" nodegroup="geometric">
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_geomcolor_color4" node="geomcolor" nodegroup="geometric">
    <input name="index" type="integer" value="0" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <geompropvalue>
    The value of the specified geometric property for the current geometry.
  -->
  <nodedef name="ND_geompropvalue_integer" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="integer" value="0" uniform="true" />
    <output name="out" type="integer" default="0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_boolean" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="boolean" value="false" />
    <output name="out" type="boolean" default="false" />
  </nodedef>
  <nodedef name="ND_geompropvalue_string" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="string" value="" uniform="true" />
    <output name="out" type="string" default="" />
  </nodedef>
  <nodedef name="ND_geompropvalue_float" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="float" value="0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_color3" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_color4" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_vector2" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_vector3" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_geompropvalue_vector4" node="geompropvalue" nodegroup="geometric">
    <input name="geomprop" type="string" value="" uniform="true" />
    <input name="default" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Global nodes                                                             -->
  <!-- ======================================================================== -->

  <!--
    Node: <ambientocclusion>
    Computes the ambient occlusion (0-1 float) at the current surface point.  Larger
    values represent greater accessibility to ambient light, 0 means "fully occluded".
  -->
  <nodedef name="ND_ambientocclusion_float" node="ambientocclusion" nodegroup="global">
    <input name="coneangle" type="float" value="90.0" unittype="angle" unit="degree" />
    <input name="maxdistance" type="float" value="1e38" />
    <output name="out" type="float" default="1.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Application nodes                                                        -->
  <!-- ======================================================================== -->

  <!--
    Node: <frame>
    The current frame number as defined by the host environment.
  -->
  <nodedef name="ND_frame_float" node="frame" nodegroup="application">
    <output name="out" type="float" default="1.0" />
  </nodedef>

  <!--
    Node: <time>
    The current time in seconds as defined by the host environment.
    (Default values is 1/24.0)
  -->
  <nodedef name="ND_time_float" node="time" nodegroup="application">
    <input name="fps" type="float" value="24.0" />
    <output name="out" type="float" default="0.041666667" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Math nodes                                                               -->
  <!-- ======================================================================== -->

  <!--
    Node: <add>
    Add "in2" value/stream to the incoming float/color/vector/matrix.
  -->
  <nodedef name="ND_add_float" node="add" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_color3" node="add" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_color4" node="add" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector2" node="add" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector3" node="add" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector4" node="add" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_matrix33" node="add" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="matrix33" value="0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_matrix44" node="add" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="matrix44" value="0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_surfaceshader" node="add" nodegroup="math">
    <input name="in1" type="surfaceshader" value="" />
    <input name="in2" type="surfaceshader" value="" />
    <output name="out" type="surfaceshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_displacementshader" node="add" nodegroup="math">
    <input name="in1" type="displacementshader" value="" />
    <input name="in2" type="displacementshader" value="" />
    <output name="out" type="displacementshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_volumeshader" node="add" nodegroup="math">
    <input name="in1" type="volumeshader" value="" />
    <input name="in2" type="volumeshader" value="" />
    <output name="out" type="volumeshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_color3FA" node="add" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_color4FA" node="add" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector2FA" node="add" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector3FA" node="add" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_vector4FA" node="add" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_matrix33FA" node="add" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_add_matrix44FA" node="add" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <subtract>
    Subtract "in2" value/stream from the incoming float/color/vector/matrix.
  -->
  <nodedef name="ND_subtract_float" node="subtract" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_color3" node="subtract" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_color4" node="subtract" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector2" node="subtract" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector3" node="subtract" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector4" node="subtract" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_matrix33" node="subtract" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="matrix33" value="0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_matrix44" node="subtract" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="matrix44" value="0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0, 0.0,0.0,0.0,0.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_color3FA" node="subtract" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_color4FA" node="subtract" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector2FA" node="subtract" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector3FA" node="subtract" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_vector4FA" node="subtract" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_matrix33FA" node="subtract" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_subtract_matrix44FA" node="subtract" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <multiply>
    Multiply the incoming float/color/vector by the "in2" value/stream, or multiply
    two matrices.
  -->
  <nodedef name="ND_multiply_float" node="multiply" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_color3" node="multiply" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_color4" node="multiply" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector2" node="multiply" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector3" node="multiply" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector4" node="multiply" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_matrix33" node="multiply" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_matrix44" node="multiply" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_color3FA" node="multiply" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_color4FA" node="multiply" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector2FA" node="multiply" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector3FA" node="multiply" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_vector4FA" node="multiply" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_surfaceshaderF" node="multiply" nodegroup="math">
    <input name="in1" type="surfaceshader" value="" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="surfaceshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_displacementshaderF" node="multiply" nodegroup="math">
    <input name="in1" type="displacementshader" value="" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="displacementshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_volumeshaderF" node="multiply" nodegroup="math">
    <input name="in1" type="volumeshader" value="" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="volumeshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_surfaceshaderC" node="multiply" nodegroup="math">
    <input name="in1" type="surfaceshader" value="" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="surfaceshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_volumeshaderC" node="multiply" nodegroup="math">
    <input name="in1" type="volumeshader" value="" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="volumeshader" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_multiply_displacementshaderV" node="multiply" nodegroup="math">
    <input name="in1" type="displacementshader" value="" />
    <input name="in2" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="displacementshader" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <divide>
    Divide an incoming float/color/vector by the "in2" value/stream; dividing a channel
    value by 0 results in floating-point "NaN".  Or, multiply one matrix by the
    inverse of a second matrix.
  -->
  <nodedef name="ND_divide_float" node="divide" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_color3" node="divide" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_color4" node="divide" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector2" node="divide" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector3" node="divide" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector4" node="divide" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_matrix33" node="divide" nodegroup="math">
    <input name="in1" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="in2" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="matrix33" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_matrix44" node="divide" nodegroup="math">
    <input name="in1" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="in2" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="matrix44" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_color3FA" node="divide" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_color4FA" node="divide" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector2FA" node="divide" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector3FA" node="divide" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_divide_vector4FA" node="divide" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <modulo>
    The remaining fraction after dividing one float/color/vector by another and
    subtracting the integer portion. The modula "in2" value cannot be 0.
  -->
  <nodedef name="ND_modulo_float" node="modulo" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_color3" node="modulo" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_color4" node="modulo" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector2" node="modulo" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector3" node="modulo" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector4" node="modulo" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_color3FA" node="modulo" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_color4FA" node="modulo" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector2FA" node="modulo" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector3FA" node="modulo" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_modulo_vector4FA" node="modulo" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <invert>
    Subtract the incoming float/color/vector from "amount" in all channels,
    outputting: amount - in.
  -->
  <nodedef name="ND_invert_float" node="invert" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_color3" node="invert" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_color4" node="invert" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector2" node="invert" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="amount" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector3" node="invert" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector4" node="invert" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_color3FA" node="invert" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_color4FA" node="invert" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector2FA" node="invert" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector3FA" node="invert" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invert_vector4FA" node="invert" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <absval>
    The per-channel absolute value of the incoming float/color/vector.
  -->
  <nodedef name="ND_absval_float" node="absval" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_absval_color3" node="absval" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_absval_color4" node="absval" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_absval_vector2" node="absval" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_absval_vector3" node="absval" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_absval_vector4" node="absval" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <floor>
    Find the nearest integer less than or equal to the parameter.
  -->
  <nodedef name="ND_floor_float" node="floor" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_floor_color3" node="floor" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_floor_color4" node="floor" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_floor_vector2" node="floor" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_floor_vector3" node="floor" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_floor_vector4" node="floor" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <ceil>
    Find the nearest integer greater than or equal to the parameter.
  -->
  <nodedef name="ND_ceil_float" node="ceil" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ceil_color3" node="ceil" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ceil_color4" node="ceil" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ceil_vector2" node="ceil" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ceil_vector3" node="ceil" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ceil_vector4" node="ceil" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <power>
    Raise incoming float/color/vector values to the "in2" power.
  -->
  <nodedef name="ND_power_float" node="power" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_color3" node="power" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_color4" node="power" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector2" node="power" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector3" node="power" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector4" node="power" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_color3FA" node="power" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_color4FA" node="power" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector2FA" node="power" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector3FA" node="power" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_power_vector4FA" node="power" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Nodes: <sin>, <cos>, <tan>, <asin>, <acos>, <atan2>
    Standard trigonometric functions; angles are given in radians.
  -->
  <nodedef name="ND_sin_float" node="sin" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_cos_float" node="cos" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_tan_float" node="tan" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_asin_float" node="asin" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_acos_float" node="acos" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_atan2_float" node="atan2" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_sin_vector2" node="sin" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_cos_vector2" node="cos" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_tan_vector2" node="tan" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_asin_vector2" node="asin" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_acos_vector2" node="acos" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_atan2_vector2" node="atan2" nodegroup="math">
    <input name="in1" type="vector2" value="1.0, 1.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_sin_vector3" node="sin" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_cos_vector3" node="cos" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_tan_vector3" node="tan" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_asin_vector3" node="asin" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_acos_vector3" node="acos" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_atan2_vector3" node="atan2" nodegroup="math">
    <input name="in1" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_sin_vector4" node="sin" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_cos_vector4" node="cos" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_tan_vector4" node="tan" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_asin_vector4" node="asin" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_acos_vector4" node="acos" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_atan2_vector4" node="atan2" nodegroup="math">
    <input name="in1" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Nodes: <sqrt>, <ln>, <exp>
    Standard math functions.
  -->
  <nodedef name="ND_sqrt_float" node="sqrt" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ln_float" node="ln" nodegroup="math">
    <input name="in" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_exp_float" node="exp" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sqrt_vector2" node="sqrt" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ln_vector2" node="ln" nodegroup="math">
    <input name="in" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_exp_vector2" node="exp" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sqrt_vector3" node="sqrt" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ln_vector3" node="ln" nodegroup="math">
    <input name="in" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_exp_vector3" node="exp" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sqrt_vector4" node="sqrt" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_ln_vector4" node="ln" nodegroup="math">
    <input name="in" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_exp_vector4" node="exp" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <sign>
    Sign of eachinput channel: -1, 0 or +1
  -->
  <nodedef name="ND_sign_float" node="sign" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sign_color3" node="sign" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sign_color4" node="sign" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sign_vector2" node="sign" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sign_vector3" node="sign" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_sign_vector4" node="sign" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <clamp>
    Clamp incoming value to a specified range of values.
  -->
  <nodedef name="ND_clamp_float" node="clamp" nodegroup="math">
    <input name="in" type="float" value="0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_color3" node="clamp" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="low" type="color3" value="0.0, 0.0, 0.0" />
    <input name="high" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_color4" node="clamp" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="high" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector2" node="clamp" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="low" type="vector2" value="0.0, 0.0" />
    <input name="high" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector3" node="clamp" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="low" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="high" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector4" node="clamp" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="high" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_color3FA" node="clamp" nodegroup="math">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_color4FA" node="clamp" nodegroup="math">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector2FA" node="clamp" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector3FA" node="clamp" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_clamp_vector4FA" node="clamp" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <min>
    Select the minimum among incoming values.
  -->
  <nodedef name="ND_min_float" node="min" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_color3" node="min" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_color4" node="min" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector2" node="min" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector3" node="min" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector4" node="min" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_color3FA" node="min" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_color4FA" node="min" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector2FA" node="min" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector3FA" node="min" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_min_vector4FA" node="min" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <max>
    Select the maximum among incoming values.
  -->
  <nodedef name="ND_max_float" node="max" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_color3" node="max" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_color4" node="max" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector2" node="max" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector3" node="max" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector4" node="max" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_color3FA" node="max" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_color4FA" node="max" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector2FA" node="max" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector3FA" node="max" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_max_vector4FA" node="max" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <normalize>
    Outputs the normalized vector from the incoming vector stream.
  -->
  <nodedef name="ND_normalize_vector2" node="normalize" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_normalize_vector3" node="normalize" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_normalize_vector4" node="normalize" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <magnitude>
    Outputs the float magnitude (vector length) of the incoming vector stream.
  -->
  <nodedef name="ND_magnitude_vector2" node="magnitude" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_magnitude_vector3" node="magnitude" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_magnitude_vector4" node="magnitude" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <dotproduct>
    Perform a dot product of two 2-4 channel vectors
  -->
  <nodedef name="ND_dotproduct_vector2" node="dotproduct" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_dotproduct_vector3" node="dotproduct" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_dotproduct_vector4" node="dotproduct" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <crossproduct>
    Perform a cross product of two vectors
  -->
  <nodedef name="ND_crossproduct_vector3" node="crossproduct" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <transformpoint>
    Transform a vector3 coordinate from one named space to another.
  -->
  <nodedef name="ND_transformpoint_vector3" node="transformpoint" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="fromspace" type="string" value="" uniform="true" />
    <input name="tospace" type="string" value="" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>

  <!--
    Node: <transformvector>
    Transform a vector from one named space to another.
  -->
  <nodedef name="ND_transformvector_vector3" node="transformvector" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="fromspace" type="string" value="" uniform="true" />
    <input name="tospace" type="string" value="" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <!--
    Node: <transformnormal>
    Transform a normal vector from one named space to another.
  -->
  <nodedef name="ND_transformnormal_vector3" node="transformnormal" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 1.0" />
    <input name="fromspace" type="string" value="" uniform="true" />
    <input name="tospace" type="string" value="" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>

  <!--
    Node: <transformmatrix>
    Transform a vector by a matrix.
  -->
  <nodedef name="ND_transformmatrix_vector2M3" node="transformmatrix" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="mat" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_transformmatrix_vector3" node="transformmatrix" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="mat" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_transformmatrix_vector3M4" node="transformmatrix" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="mat" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_transformmatrix_vector4" node="transformmatrix" nodegroup="math">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mat" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <normalmap>
    Transform a normal vector from object or tangent space into "world" space.
  -->
  <nodedef name="ND_normalmap" node="normalmap" nodegroup="math">
    <input name="in" type="vector3" value="0.5, 0.5, 1.0" />
    <input name="space" type="string" value="tangent" enum="tangent, object" uniform="true" />
    <input name="scale" type="float" value="1.0" />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" />
    <input name="tangent" type="vector3" defaultgeomprop="Tworld" />
    <output name="out" type="vector3" defaultinput="normal" />
  </nodedef>

  <!--
    Node: <transpose>
    Output the transpose of the incoming matrix.
  -->
  <nodedef name="ND_transpose_matrix33" node="transpose" nodegroup="math">
    <input name="in" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="matrix33" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_transpose_matrix44" node="transpose" nodegroup="math">
    <input name="in" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="matrix44" defaultinput="in" />
  </nodedef>

  <!--
    Node: <determinant>
    Output the determinant of the incoming matrix.
  -->
  <nodedef name="ND_determinant_matrix33" node="determinant" nodegroup="math">
    <input name="in" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="float" default="1.0" />
  </nodedef>
  <nodedef name="ND_determinant_matrix44" node="determinant" nodegroup="math">
    <input name="in" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="float" default="1.0" />
  </nodedef>

  <!--
    Node: <invertmatrix>
    Invert an incoming matrix.
  -->
  <nodedef name="ND_invertmatrix_matrix33" node="invertmatrix" nodegroup="math">
    <input name="in" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <output name="out" type="matrix33" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_invertmatrix_matrix44" node="invertmatrix" nodegroup="math">
    <input name="in" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <output name="out" type="matrix44" defaultinput="in" />
  </nodedef>

  <!--
    Node: <rotate2d>
    Rotate a vector2 value about the origin.
  -->
  <nodedef name="ND_rotate2d_vector2" node="rotate2d" nodegroup="math">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="amount" type="float" value="0.0" unittype="angle" unit="degree" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>

  <!--
    Node: <rotate3d>
    Rotate a vector3 value about a specified unit axis vector
  -->
  <nodedef name="ND_rotate3d_vector3" node="rotate3d" nodegroup="math">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="0.0" unittype="angle" unit="degree" />
    <input name="axis" type="vector3" value="0.0, 1.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>

  <!--
    Node: <place2d> Supplemental Node
    Transform incoming UV texture coordinates for 2D texture placement.
  -->
  <nodedef name="ND_place2d_vector2" node="place2d" nodegroup="math">
    <input name="texcoord" type="vector2" value="0.0, 0.0" />
    <input name="pivot" type="vector2" value="0.0,0.0" />
    <input name="scale" type="vector2" value="1.0,1.0" />
    <input name="rotate" type="float" value="0.0" unittype="angle" unit="degree" />
    <input name="offset" type="vector2" value="0.0,0.0" />
    <output name="out" type="vector2" defaultinput="texcoord" />
  </nodedef>

  <!--
    Node: <arrayappend>
    Creates a two-element array from two base types, or appends a base-type value to an array of
    the same type.
  -->
  <nodedef name="ND_arrayappend_integer_integerarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="integer" value="0" />
    <input name="in2" type="integer" value="0" />
    <output name="out" type="integerarray" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_integerarray_integerarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="integerarray" value="" />
    <input name="in2" type="integer" value="0" />
    <output name="out" type="integerarray" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_float_floatarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="floatarray" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_floatarray_floatarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="floatarray" value="" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="floatarray" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_color3_color3array" node="arrayappend" nodegroup="math">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3array" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_color3array_color3array" node="arrayappend" nodegroup="math">
    <input name="in1" type="color3array" value="" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3array" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_color4_color4array" node="arrayappend" nodegroup="math">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4array" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_color4array_color4array" node="arrayappend" nodegroup="math">
    <input name="in1" type="color4array" value="" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4array" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector2_vector2array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2array" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector2array_vector2array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector2array" value="" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2array" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector3_vector3array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3array" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector3array_vector3array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector3array" value="" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3array" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector4_vector4array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4array" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_vector4array_vector4array" node="arrayappend" nodegroup="math">
    <input name="in1" type="vector4array" value="" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4array" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_arrayappend_string_stringarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="string" value="" />
    <input name="in2" type="string" value="" />
    <output name="out" type="stringarray" default="[]" />
  </nodedef>
  <nodedef name="ND_arrayappend_stringarray_stringarray" node="arrayappend" nodegroup="math">
    <input name="in1" type="stringarray" value="" />
    <input name="in2" type="string" value="" />
    <output name="out" type="stringarray" defaultinput="in1" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Adjustment nodes                                                         -->
  <!-- ======================================================================== -->

  <!--
    Node: <remap>
    Remap a value from one range of float/color/vector values to another.
  -->
  <nodedef name="ND_remap_float" node="remap" nodegroup="adjustment">
    <input name="in" type="float" value="0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_color3" node="remap" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inhigh" type="color3" value="1.0, 1.0, 1.0" />
    <input name="outlow" type="color3" value="0.0, 0.0, 0.0" />
    <input name="outhigh" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_color4" node="remap" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="outlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="outhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector2" node="remap" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="inlow" type="vector2" value="0.0, 0.0" />
    <input name="inhigh" type="vector2" value="1.0, 1.0" />
    <input name="outlow" type="vector2" value="0.0, 0.0" />
    <input name="outhigh" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector3" node="remap" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inhigh" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="outlow" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="outhigh" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector4" node="remap" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="outlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="outhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_color3FA" node="remap" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_color4FA" node="remap" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector2FA" node="remap" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector3FA" node="remap" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_remap_vector4FA" node="remap" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <smoothstep>
    Outputs a smooth (hermite-interpolated) remapping of input values from low-high
    to output 0-1.
  -->
  <nodedef name="ND_smoothstep_float" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="float" value="0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_color3" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="low" type="color3" value="0.0, 0.0, 0.0" />
    <input name="high" type="color3" value="1.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_color4" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="high" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector2" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="low" type="vector2" value="0.0, 0.0" />
    <input name="high" type="vector2" value="1.0, 1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector3" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="low" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="high" type="vector3" value="1.0, 1.0, 1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector4" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="high" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_color3FA" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_color4FA" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector2FA" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector3FA" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_smoothstep_vector4FA" node="smoothstep" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="low" type="float" value="0.0" />
    <input name="high" type="float" value="1.0" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <curveadjust>
    Outputs a smooth remapping of input values using the centripetal Catmull-Rom
    cubic spline curve defined by specified knot values, using an inverse spline
    lookup on input knot values and a forward spline through output knot values.
    All channels of the input will be remapped using the same curve.
  -->
  <nodedef name="ND_curveadjust_float" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="float" value="0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_curveadjust_color3" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_curveadjust_color4" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_curveadjust_vector2" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_curveadjust_vector3" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_curveadjust_vector4" node="curveadjust" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="knots" type="vector2array" value="" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <luminance>
    Output a grayscale image containing the luminance of the incoming RGB color in all color channels;
    the alpha channel is left unchanged if present.
  -->
  <nodedef name="ND_luminance_color3" node="luminance" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="lumacoeffs" type="color3" value="0.2722287, 0.6740818, 0.0536895" enum="acescg, rec709, rec2020, rec2100" enumvalues="0.2722287,0.6740818,0.0536895, 0.2126,0.7152,0.0722, 0.2627,0.6780,0.0593, 0.2627,0.6780,0.0593" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_luminance_color4" node="luminance" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="lumacoeffs" type="color3" value="0.2722287, 0.6740818, 0.0536895" enum="acescg, rec709, rec2020, rec2100" enumvalues="0.2722287,0.6740818,0.0536895, 0.2126,0.7152,0.0722, 0.2627,0.6780,0.0593, 0.2627,0.6780,0.0593" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Nodes: <rgbtohsv> and <hsvtorgb>
    Convert an incoming color between RGB and HSV space, with H and S ranging from 0-1.
  -->
  <nodedef name="ND_rgbtohsv_color3" node="rgbtohsv" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_rgbtohsv_color4" node="rgbtohsv" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_hsvtorgb_color3" node="hsvtorgb" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_hsvtorgb_color4" node="hsvtorgb" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <contrast> Supplemental Node
    Increase or decrease contrast of a float/color value using a linear slope multiplier.
  -->
  <nodedef name="ND_contrast_float" node="contrast" nodegroup="adjustment">
    <input name="in" type="float" value="0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_color3" node="contrast" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="color3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="color3" value="0.5, 0.5, 0.5" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_color4" node="contrast" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="color4" value="0.5, 0.5, 0.5, 0.5" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector2" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="amount" type="vector2" value="1.0, 1.0" />
    <input name="pivot" type="vector2" value="0.5, 0.5" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector3" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="pivot" type="vector3" value="0.5, 0.5, 0.5" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector4" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="pivot" type="vector4" value="0.5, 0.5, 0.5, 0.5" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_color3FA" node="contrast" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_color4FA" node="contrast" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector2FA" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector3FA" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_contrast_vector4FA" node="contrast" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="pivot" type="float" value="0.5" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <range> Supplemental Node
    Remap a value from one range of float/color/vector values to another, optionally
    applying a gamma correction in the middle, and optionally clamping output values.
  -->
  <nodedef name="ND_range_float" node="range" nodegroup="adjustment">
    <input name="in" type="float" value="0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_color3" node="range" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inhigh" type="color3" value="1.0, 1.0, 1.0" />
    <input name="gamma" type="color3" value="1.0, 1.0, 1.0" />
    <input name="outlow" type="color3" value="0.0, 0.0, 0.0" />
    <input name="outhigh" type="color3" value="1.0, 1.0, 1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_color4" node="range" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="gamma" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="outlow" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="outhigh" type="color4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector2" node="range" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="inlow" type="vector2" value="0.0, 0.0" />
    <input name="inhigh" type="vector2" value="1.0, 1.0" />
    <input name="gamma" type="vector2" value="1.0, 1.0" />
    <input name="outlow" type="vector2" value="0.0, 0.0" />
    <input name="outhigh" type="vector2" value="1.0, 1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector3" node="range" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inhigh" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="gamma" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="outlow" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="outhigh" type="vector3" value="1.0, 1.0, 1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector4" node="range" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="gamma" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="outlow" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="outhigh" type="vector4" value="1.0, 1.0, 1.0, 1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_color3FA" node="range" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_color4FA" node="range" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector2FA" node="range" nodegroup="adjustment">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector3FA" node="range" nodegroup="adjustment">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_range_vector4FA" node="range" nodegroup="adjustment">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="inlow" type="float" value="0.0" />
    <input name="inhigh" type="float" value="1.0" />
    <input name="gamma" type="float" value="1.0" />
    <input name="outlow" type="float" value="0.0" />
    <input name="outhigh" type="float" value="1.0" />
    <input name="doclamp" type="boolean" value="false" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <hsvadjust> Supplemental Node
    Adjust the hue, saturation and value of an RGB color by converting the input color
    to HSV, adding amount.x to the hue, multiplying the saturation by amount.y,
    multiplying the value by amount.z, then converting back to RGB.
  -->
  <nodedef name="ND_hsvadjust_color3" node="hsvadjust" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="vector3" value="0.0, 1.0, 1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_hsvadjust_color4" node="hsvadjust" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="vector3" value="0.0, 1.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <saturate> Supplemental Node
    Adjust the saturation of a color using a linear interpolation between the incoming
    color and the grayscale luminance of the input computed using the provided luma
    coefficients; the alpha channel will be unchanged if present.
  -->
  <nodedef name="ND_saturate_color3" node="saturate" nodegroup="adjustment">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="lumacoeffs" type="color3" value="0.2722287, 0.6740818, 0.0536895" enum="acescg, rec709, rec2020, rec2100" enumvalues="0.2722287,0.6740818,0.0536895, 0.2126,0.7152,0.0722, 0.2627,0.6780,0.0593, 0.2627,0.6780,0.0593" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_saturate_color4" node="saturate" nodegroup="adjustment">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="amount" type="float" value="1.0" />
    <input name="lumacoeffs" type="color3" value="0.2722287, 0.6740818, 0.0536895" enum="acescg, rec709, rec2020, rec2100" enumvalues="0.2722287,0.6740818,0.0536895, 0.2126,0.7152,0.0722, 0.2627,0.6780,0.0593, 0.2627,0.6780,0.0593" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Compositing nodes                                                        -->
  <!-- ======================================================================== -->

  <!--
    Node: <premult>
    Multiply the R or RGB channels of the input by the Alpha channel of the input.
  -->
  <nodedef name="ND_premult_color4" node="premult" nodegroup="compositing">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <unpremult>
    Divide the R or RGB channels of the input by the Alpha channel of the input.
    If the Alpha value is zero, it is passed through unchanged.
  -->
  <nodedef name="ND_unpremult_color4" node="unpremult" nodegroup="compositing">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <plus>
    Add two 1-4 channel inputs, with optional mixing between the bg input and the result.
  -->
  <nodedef name="ND_plus_float" node="plus" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_plus_color3" node="plus" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_plus_color4" node="plus" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <minus>
    Subtract two 1-4 channel inputs, with optional mixing between the bg input and the result.
  -->
  <nodedef name="ND_minus_float" node="minus" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_minus_color3" node="minus" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_minus_color4" node="minus" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <difference>
    Absolute-value difference of two 1-4 channel inputs, with optional mixing between
    the bg input and the result.
  -->
  <nodedef name="ND_difference_float" node="difference" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_difference_color3" node="difference" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_difference_color4" node="difference" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <burn>
    Take two 1-4 channel inputs and apply the same operator to all channels: 1-(1-B)/F
  -->
  <nodedef name="ND_burn_float" node="burn" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_burn_color3" node="burn" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_burn_color4" node="burn" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <dodge>
    Take two 1-4 channel inputs and apply the same operator to all channels: B/(1-F)
  -->
  <nodedef name="ND_dodge_float" node="dodge" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_dodge_color3" node="dodge" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_dodge_color4" node="dodge" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <screen>
    Take two 1-4 channel inputs and apply the same operator to all channels: 1-(1-F)*(1-B)
  -->
  <nodedef name="ND_screen_float" node="screen" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_screen_color3" node="screen" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_screen_color4" node="screen" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <overlay>
    Take two 1-4 channel inputs and apply the same operator to all channels:
      2FB if F<0.5;
      1-(1-F)(1-B) if F>=0.5
  -->
  <nodedef name="ND_overlay_float" node="overlay" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_overlay_color3" node="overlay" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_overlay_color4" node="overlay" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <disjointover>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs:
      F+B         if f+b<=1
      F+B(1-f)/b  if f+b>1
      alpha: min(f+b,1)
  -->
  <nodedef name="ND_disjointover_color4" node="disjointover" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <in>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs: Fb  (alpha: fb)
  -->
  <nodedef name="ND_in_color4" node="in" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <mask>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs: Bf  (alpha: bf)
  -->
  <nodedef name="ND_mask_color4" node="mask" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <matte>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs: Ff+B(1-f)  (alpha: f+b(1-f))
  -->
  <nodedef name="ND_matte_color4" node="matte" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <out>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs: F(1-b)  (alpha: f(1-b))
  -->
  <nodedef name="ND_out_color4" node="out" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <over>
    Take two color4 inputs and use the built-in alpha
    channel(s) to control the compositing of the fg and bg inputs: F+B(1-f)  (alpha: f+b(1-f))
  -->
  <nodedef name="ND_over_color4" node="over" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>

  <!--
    Node: <inside>
    Take one 1-4 channel input "in" plus a separate float "mask" input and apply the same
    operator to all channels: in * mask
  -->
  <nodedef name="ND_inside_float" node="inside" nodegroup="compositing">
    <input name="in" type="float" value="0.0" />
    <input name="mask" type="float" value="1.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_inside_color3" node="inside" nodegroup="compositing">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mask" type="float" value="1.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_inside_color4" node="inside" nodegroup="compositing">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mask" type="float" value="1.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <outside>
    Take one 1-4 channel input "in" plus a separate float "mask" input and apply the same
    operator to all channels: in * (1-mask)
  -->
  <nodedef name="ND_outside_float" node="outside" nodegroup="compositing">
    <input name="in" type="float" value="0.0" />
    <input name="mask" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_outside_color3" node="outside" nodegroup="compositing">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mask" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_outside_color4" node="outside" nodegroup="compositing">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mask" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <mix>
    Mix two inputs according to an input mix amount.
  -->
  <nodedef name="ND_mix_float" node="mix" nodegroup="compositing">
    <input name="fg" type="float" value="0.0" />
    <input name="bg" type="float" value="0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_color3" node="mix" nodegroup="compositing">
    <input name="fg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="color3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_color4" node="mix" nodegroup="compositing">
    <input name="fg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_vector2" node="mix" nodegroup="compositing">
    <input name="fg" type="vector2" value="0.0, 0.0" />
    <input name="bg" type="vector2" value="0.0, 0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_vector3" node="mix" nodegroup="compositing">
    <input name="fg" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="bg" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_vector4" node="mix" nodegroup="compositing">
    <input name="fg" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="bg" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_surfaceshader" node="mix" nodegroup="compositing">
    <input name="fg" type="surfaceshader" value="" />
    <input name="bg" type="surfaceshader" value="" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="surfaceshader" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_displacementshader" node="mix" nodegroup="compositing">
    <input name="fg" type="displacementshader" value="" />
    <input name="bg" type="displacementshader" value="" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="displacementshader" defaultinput="bg" />
  </nodedef>
  <nodedef name="ND_mix_volumeshader" node="mix" nodegroup="compositing">
    <input name="fg" type="volumeshader" value="" />
    <input name="bg" type="volumeshader" value="" />
    <input name="mix" type="float" value="0.0" />
    <output name="out" type="volumeshader" defaultinput="bg" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Conditional nodes                                                        -->
  <!-- ======================================================================== -->

  <!--
    Node: <ifgreater>
    Output the value of in1 if value1>value2, or the value of in2 if value1<=value2.
  -->
  <nodedef name="ND_ifgreater_float" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_color3" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_color4" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector2" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector3" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector4" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_floatI" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_color3I" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_color4I" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector2I" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector3I" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreater_vector4I" node="ifgreater" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <ifgreatereq>
    Output the value of in1 if value1>=value2, or the value of in2 if value1<value2.
  -->
  <nodedef name="ND_ifgreatereq_float" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_color3" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_color4" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector2" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector3" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector4" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="float" value="1.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_floatI" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_color3I" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_color4I" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector2I" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector3I" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifgreatereq_vector4I" node="ifgreatereq" nodegroup="conditional">
    <input name="value1" type="integer" value="1" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <ifequal>
    Output the value of in1 if value1==value2, or the value of in2 if value1!=value2.
  -->
  <nodedef name="ND_ifequal_float" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color3" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color4" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector2" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector3" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector4" node="ifequal" nodegroup="conditional">
    <input name="value1" type="float" value="0.0" />
    <input name="value2" type="float" value="0.0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_floatI" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color3I" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color4I" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector2I" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector3I" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector4I" node="ifequal" nodegroup="conditional">
    <input name="value1" type="integer" value="0" />
    <input name="value2" type="integer" value="0" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_floatB" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color3B" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_color4B" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector2B" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector3B" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_ifequal_vector4B" node="ifequal" nodegroup="conditional">
    <input name="value1" type="boolean" value="false" />
    <input name="value2" type="boolean" value="false" />
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!--
    Node: <switch>
    Pass on the value of one of five input streams, according to the value of a selector parameter.
  -->
  <nodedef name="ND_switch_float" node="switch" nodegroup="conditional">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <input name="in4" type="float" value="0.0" />
    <input name="in5" type="float" value="0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_color3" node="switch" nodegroup="conditional">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in3" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in4" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in5" type="color3" value="0.0, 0.0, 0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_color4" node="switch" nodegroup="conditional">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in3" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in4" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in5" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector2" node="switch" nodegroup="conditional">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <input name="in3" type="vector2" value="0.0, 0.0" />
    <input name="in4" type="vector2" value="0.0, 0.0" />
    <input name="in5" type="vector2" value="0.0, 0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector3" node="switch" nodegroup="conditional">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in3" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in4" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in5" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector4" node="switch" nodegroup="conditional">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in3" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in4" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in5" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="which" type="float" value="0.0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_floatI" node="switch" nodegroup="conditional">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <input name="in4" type="float" value="0.0" />
    <input name="in5" type="float" value="0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="float" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_color3I" node="switch" nodegroup="conditional">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in3" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in4" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in5" type="color3" value="0.0, 0.0, 0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="color3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_color4I" node="switch" nodegroup="conditional">
    <input name="in1" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in3" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in4" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in5" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="color4" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector2I" node="switch" nodegroup="conditional">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <input name="in3" type="vector2" value="0.0, 0.0" />
    <input name="in4" type="vector2" value="0.0, 0.0" />
    <input name="in5" type="vector2" value="0.0, 0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="vector2" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector3I" node="switch" nodegroup="conditional">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in3" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in4" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in5" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="vector3" defaultinput="in1" />
  </nodedef>
  <nodedef name="ND_switch_vector4I" node="switch" nodegroup="conditional">
    <input name="in1" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in2" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in3" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in4" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="in5" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="which" type="integer" value="0" />
    <output name="out" type="vector4" defaultinput="in1" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Channel nodes                                                            -->
  <!-- ======================================================================== -->

  <!--
    Node: <convert>
    Convert a stream from one type to another; only certain unambiguous conversion
    types are supported.
  -->
  <nodedef name="ND_convert_float_color3" node="convert" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_float_color4" node="convert" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_float_vector2" node="convert" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_float_vector3" node="convert" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_float_vector4" node="convert" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector2_vector3" node="convert" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector3_color3" node="convert" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector3_vector2" node="convert" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector3_vector4" node="convert" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector4_color4" node="convert" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_vector4_vector3" node="convert" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_color3_vector3" node="convert" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_color4_vector4" node="convert" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_color3_color4" node="convert" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_color4_color3" node="convert" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_convert_boolean_float" node="convert" nodegroup="channel">
    <input name="in" type="boolean" value="false" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_convert_integer_float" node="convert" nodegroup="channel">
    <input name="in" type="integer" value="0" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <swizzle>
    Perform an arbitrary permutation of the channels of the input stream, returning a new
    stream of the specified type. Individual channels may be replicated or omitted, and the output
    stream may have a different number of channels than the input.
  -->
  <!-- from type: float -->
  <nodedef name="ND_swizzle_float_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <input name="channels" type="string" value="rrr" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_float_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <input name="channels" type="string" value="rrrr" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_float_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <input name="channels" type="string" value="xx" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_float_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_float_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="float" value="0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!-- from type: color3 -->
  <nodedef name="ND_swizzle_color3_float" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="r" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color3_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrr" uniform="true" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_swizzle_color3_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrrr" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color3_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rr" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color3_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrr" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color3_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrrr" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!-- from type: color4 -->
  <nodedef name="ND_swizzle_color4_float" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="r" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color4_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrr" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color4_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrrr" uniform="true" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_swizzle_color4_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rr" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color4_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrr" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_color4_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="rrrr" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!-- from type: vector2 -->
  <nodedef name="ND_swizzle_vector2_float" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="x" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector2_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector2_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector2_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="xx" uniform="true" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_swizzle_vector2_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector2_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!-- from type: vector3 -->
  <nodedef name="ND_swizzle_vector3_float" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="x" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector3_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector3_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector3_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xx" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector3_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_swizzle_vector3_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <!-- from type: vector4 -->
  <nodedef name="ND_swizzle_vector4_float" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="x" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector4_color3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector4_color4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector4_vector2" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xx" uniform="true" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector4_vector3" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxx" uniform="true" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_swizzle_vector4_vector4" node="swizzle" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="channels" type="string" value="xxxx" uniform="true" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <combine2>
    Combine the channels from two streams into the same number of channels of a
    single output stream of a specified compatible type.
  -->
  <nodedef name="ND_combine2_vector2" node="combine2" nodegroup="channel">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector2" default="0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_combine2_color4CF" node="combine2" nodegroup="channel">
    <input name="in1" type="color3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_combine2_vector4VF" node="combine2" nodegroup="channel">
    <input name="in1" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="in2" type="float" value="0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_combine2_vector4VV" node="combine2" nodegroup="channel">
    <input name="in1" type="vector2" value="0.0, 0.0" />
    <input name="in2" type="vector2" value="0.0, 0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <combine3>
    Combine the channels from three streams into the same number of channels of a
    single output stream of a specified compatible type.
  -->
  <nodedef name="ND_combine3_color3" node="combine3" nodegroup="channel">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <output name="out" type="color3" default="0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_combine3_vector3" node="combine3" nodegroup="channel">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <output name="out" type="vector3" default="0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <combine4>
    Combine the channels from four streams into the same number of channels of a
    single output stream of a specified compatible type.
  -->
  <nodedef name="ND_combine4_color4" node="combine4" nodegroup="channel">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <input name="in4" type="float" value="0.0" />
    <output name="out" type="color4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>
  <nodedef name="ND_combine4_vector4" node="combine4" nodegroup="channel">
    <input name="in1" type="float" value="0.0" />
    <input name="in2" type="float" value="0.0" />
    <input name="in3" type="float" value="0.0" />
    <input name="in4" type="float" value="0.0" />
    <output name="out" type="vector4" default="0.0, 0.0, 0.0, 0.0" />
  </nodedef>

  <!--
    Node: <extract> Supplemental Node
    Extract a single channel from a colorN or vectorN stream, outputting a float.
  -->
  <nodedef name="ND_extract_color3" node="extract" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="index" type="integer" value="0" uimin="0" uimax="2" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_extract_color4" node="extract" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="index" type="integer" value="0" uimin="0" uimax="3" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_extract_vector2" node="extract" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="index" type="integer" value="0" uimin="0" uimax="1" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_extract_vector3" node="extract" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="index" type="integer" value="0" uimin="0" uimax="2" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_extract_vector4" node="extract" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="index" type="integer" value="0" uimin="0" uimax="3" uniform="true" />
    <output name="out" type="float" default="0.0" />
  </nodedef>

  <!--
    Node: <separate2>, <separate3>, <separate4> Supplemental Nodes
    Output each of the channels of a color/vector stream as a separate float output.
  -->
  <nodedef name="ND_separate2_vector2" node="separate2" nodegroup="channel">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <output name="outx" type="float" default="0.0" />
    <output name="outy" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_separate3_color3" node="separate3" nodegroup="channel">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <output name="outr" type="float" default="0.0" />
    <output name="outg" type="float" default="0.0" />
    <output name="outb" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_separate3_vector3" node="separate3" nodegroup="channel">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <output name="outx" type="float" default="0.0" />
    <output name="outy" type="float" default="0.0" />
    <output name="outz" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_separate4_color4" node="separate4" nodegroup="channel">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="outr" type="float" default="0.0" />
    <output name="outg" type="float" default="0.0" />
    <output name="outb" type="float" default="0.0" />
    <output name="outa" type="float" default="0.0" />
  </nodedef>
  <nodedef name="ND_separate4_vector4" node="separate4" nodegroup="channel">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <output name="outx" type="float" default="0.0" />
    <output name="outy" type="float" default="0.0" />
    <output name="outz" type="float" default="0.0" />
    <output name="outw" type="float" default="0.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Convolution nodes                                                        -->
  <!-- ======================================================================== -->

  <!--
    Node: <blur>
    A gaussian-falloff blur.
  -->
  <nodedef name="ND_blur_float" node="blur" nodegroup="convolution2d">
    <input name="in" type="float" value="0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_blur_color3" node="blur" nodegroup="convolution2d">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_blur_color4" node="blur" nodegroup="convolution2d">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_blur_vector2" node="blur" nodegroup="convolution2d">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_blur_vector3" node="blur" nodegroup="convolution2d">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_blur_vector4" node="blur" nodegroup="convolution2d">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="size" type="float" value="0.0" />
    <input name="filtertype" type="string" value="box" enum="box,gaussian" uniform="true" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>

  <!--
    Node: <heighttonormal>
    Convert a scalar height map to a normal map of type vector3.
  -->
  <nodedef name="ND_heighttonormal_vector3" node="heighttonormal" nodegroup="convolution2d">
    <input name="in" type="float" value="0.0" />
    <input name="scale" type="float" value="1.0" />
    <output name="out" type="vector3" default="0.5, 0.5, 1.0" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- Organization nodes                                                       -->
  <!-- ======================================================================== -->

  <!--
    Node: <dot>
    No-op; passes its input to the output unchanged.
  -->
  <nodedef name="ND_dot_float" node="dot" nodegroup="organization">
    <input name="in" type="float" value="0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="float" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_color3" node="dot" nodegroup="organization">
    <input name="in" type="color3" value="0.0, 0.0, 0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="color3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_color4" node="dot" nodegroup="organization">
    <input name="in" type="color4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="color4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_vector2" node="dot" nodegroup="organization">
    <input name="in" type="vector2" value="0.0, 0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="vector2" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_vector3" node="dot" nodegroup="organization">
    <input name="in" type="vector3" value="0.0, 0.0, 0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="vector3" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_vector4" node="dot" nodegroup="organization">
    <input name="in" type="vector4" value="0.0, 0.0, 0.0, 0.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="vector4" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_boolean" node="dot" nodegroup="organization">
    <input name="in" type="boolean" value="false" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="boolean" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_integer" node="dot" nodegroup="organization">
    <input name="in" type="integer" value="0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="integer" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_matrix33" node="dot" nodegroup="organization">
    <input name="in" type="matrix33" value="1.0,0.0,0.0, 0.0,1.0,0.0, 0.0,0.0,1.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="matrix33" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_matrix44" node="dot" nodegroup="organization">
    <input name="in" type="matrix44" value="1.0,0.0,0.0,0.0, 0.0,1.0,0.0,0.0, 0.0,0.0,1.0,0.0, 0.0,0.0,0.0,1.0" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="matrix44" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_string" node="dot" nodegroup="organization">
    <input name="in" type="string" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="string" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_filename" node="dot" nodegroup="organization">
    <input name="in" type="filename" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="filename" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_surfaceshader" node="dot" nodegroup="organization">
    <input name="in" type="surfaceshader" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="surfaceshader" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_displacementshader" node="dot" nodegroup="organization">
    <input name="in" type="displacementshader" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="displacementshader" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_volumeshader" node="dot" nodegroup="organization">
    <input name="in" type="volumeshader" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="volumeshader" defaultinput="in" />
  </nodedef>
  <nodedef name="ND_dot_lightshader" node="dot" nodegroup="organization">
    <input name="in" type="lightshader" value="" />
    <input name="note" type="string" value="" uniform="true" />
    <output name="out" type="lightshader" defaultinput="in" />
  </nodedef>

</materialx>
cross({{in1}}, {{in2}})
mix({{valuel}}, {{valuer}}, aastep({{center}}, {{texcoord}}.x))
void mx_noise3d_fa_vector3(float amplitude, float pivot, vector position, output vector result)
{
    vector value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_geomcolor_float(int index, output float result)
{
    getattribute("color", result);
}
void mx_surface_unlit(float emission_weight, color emission_color, float transmission_weight, color transmission_color, float opacity, output surfaceshader result)
{
    float trans = clamp(transmission_weight, 0.0, 1.0);
    closure color E = (1.0 - trans) * emission_weight * emission_color * emission();
    closure color T = trans * transmission_color * transparent();
    
    float opac = clamp(opacity, 0.0, 1.0);
    result = (1.0 - opac) * transparent() + opac * (E + T);
}
void mx_fractal3d_vector2(vector2 amplitude, int octaves, float lacunarity, float diminish, vector position, output vector2 result)
{
    vector2 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
#include "stdlib/genosl/lib/mx_transform_color.osl"

void mx_srgb_texture_to_lin_rec709_color3(color _in, output color result)
{
    result = mx_srgb_texture_to_lin_rec709(_in);
}
void mx_rotate_vector2(vector2 _in, float amount, output vector2 result)
{
    float rotationRadians = radians(amount);
    float sa = sin(rotationRadians);
    float ca = cos(rotationRadians);
    result = vector2(ca*_in.x + sa*_in.y, -sa*_in.x + ca*_in.y);
}
max({{in1}}, {{in2}})
{{in}}
void mx_fractal3d_vector3(vector amplitude, int octaves, float lacunarity, float diminish, vector position, output vector result)
{
    vector f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
#include "$fileTransformUv"

void mx_image_vector2(textureresource file, string layer, vector2 default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output vector2 out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = color(default_value.x, default_value.y, 0.0);
    vector2 st = mx_transform_uv(texcoord);
    color rgb = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode);
    out.x = rgb[0];
    out.y = rgb[1];
}
{{in}} * (1.0 - {{mask}})
1 / {{in}}
void mx_time_float(float fps, output float result)
{
    float frame;
    getattribute("frame", frame);    
    result = frame / fps;
}
void mx_noise2d_fa_vector3(float amplitude, float pivot, vector2 texcoord, output vector result)
{
    vector value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
void mx_fractal3d_fa_color4(float amplitude, int octaves, float lacunarity, float diminish, vector position, output color4 result)
{
    color4 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
void mx_normalmap(vector value, string map_space, float normal_scale, vector N, vector U, output vector result)
{
    // Tangent space
    if (map_space == "tangent")
    {
        vector v = value * 2.0 - 1.0;
        vector T = normalize(U - dot(U, N) * N);
        vector B = normalize(cross(N, T));
        result = normalize(T * v[0] * normal_scale + B * v[1] * normal_scale + N * v[2]);
    }
    // Object space
    else
    {
        vector n = value * 2.0 - 1.0;
        result = normalize(n);
    }
}
void mx_frame_float(output float result)
{
    getattribute("frame", result);
}
vector(u,v,0)void mx_fractal3d_fa_vector3(float amplitude, int octaves, float lacunarity, float diminish, vector position, output vector result)
{
    vector f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
void mx_noise2d_color4(vector4 amplitude, float pivot, vector2 texcoord, output color4 result)
{
    color4 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * color4(color(amplitude.x, amplitude.y, amplitude.z), amplitude.w) + pivot;
}
mix({{valuel}}, {{valuer}}, clamp({{texcoord}}.x, 0, 1))
length({{in}})
transform({{space}}, normalize(dPdu))
void mx_hsvtorgb_color3(vector _in, output vector result)
{
    result = transformc("hsv","rgb", _in);
}
void mx_worleynoise2d_vector3(vector2 texcoord, float jitter, output vector result)
{
    result = mx_worley_noise_vector3(texcoord, jitter, 0);
}
void mx_worleynoise2d_float(vector2 texcoord, float jitter, output float result)
{
    result = mx_worley_noise_float(texcoord, jitter, 0);
}
asin({{in}})
void mx_geompropvalue_float(string geomprop, float defaultVal, output float result)
{
    if (getattribute(geomprop, result) == 0)
    {
        result = defaultVal;
    }
}
void mx_noise2d_fa_color4(float amplitude, float pivot, vector2 texcoord, output color4 result)
{
    color4 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
#include "stdlib/genosl/mx_dodge_float.osl"

void mx_dodge_color4(color4 fg , color4 bg , float mix , output color4 result)
{
    mx_dodge_float(fg.rgb[0], bg.rgb[0], mix, result.rgb[0]);
    mx_dodge_float(fg.rgb[1], bg.rgb[1], mix, result.rgb[1]);
    mx_dodge_float(fg.rgb[2], bg.rgb[2], mix, result.rgb[2]);
    mx_dodge_float(fg.a, bg.a, mix, result.a);
}
({{mix}}*((1.0 - (1.0 - {{fg}})) * (1 - {{bg}}))) + ((1.0-{{mix}})*{{bg}})
void mx_fractal3d_vector4(vector4 amplitude, int octaves, float lacunarity, float diminish, vector position, output vector4 result)
{
    vector4 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
void mx_rgbtohsv_color4(color4 _in, output color4 result)
{
    result = color4(transformc("rgb","hsv", _in.rgb), 1.0);
}
({{fg}} + ({{bg}}*(1.0-{{fg}}.a))) * {{mix}} + {{bg}} * (1.0-{{mix}})
float overlay(float fg, float bg)
{
    return (fg < 0.5) ? (2 * fg * bg) : (1 - (1 - fg) * (1 - bg));
}

color overlay(color fg, color bg)
{
    return color(overlay(fg[0], bg[0]),
                 overlay(fg[1], bg[1]),
                 overlay(fg[2], bg[2]));
}

color4 overlay(color4 fg, color4 bg)
{
    return color4(overlay(fg.rgb, bg.rgb),
                  overlay(fg.a, bg.a));
}

void mx_overlay_color4(color4 fg, color4 bg, float mix, output color4 out)
{
    out = mix * overlay(fg, bg) + (1-mix) * bg;
}
transform({{space}}, P)
({{fg}}*{{bg}}.a  * {{mix}}) + ({{bg}} * (1.0-{{mix}}))
void mx_worleynoise3d_vector3(vector position, float jitter, output vector result)
{
    result = mx_worley_noise_vector3(position, jitter, 0);
}
transform({{fromspace}}, {{tospace}}, {{in}})
void mx_cellnoise3d_float(vector position, output float result)
{
    result = cellnoise(position);
}
void mx_disjointover_color4(color4 fg, color4 bg, float mix, output color4 result)
{
    float summedAlpha = fg.a + bg.a;

    if (summedAlpha <= 1)
    {
        result.rgb = fg.rgb + bg.rgb;
    }
    else
    {
        if (abs(bg.a) < M_FLOAT_EPS)
        {
            result.rgb = 0.0;
        }
        else
        {
            float x = (1 - fg.a) / bg.a;
            result.rgb = fg.rgb + bg.rgb * x;
        }
    }
    result.a = min(summedAlpha, 1.0);

    result.rgb = result.rgb * mix + (1.0 - mix) * bg.rgb;
    result.a = result.a * mix + (1.0 - mix) * bg.a;
}
min({{in1}}, {{in2}})
void mx_geompropvalue_color(string geomprop, color defaultVal, output color out)
{
    if (getattribute(geomprop, out) == 0)
        out = defaultVal;
}
({{bg}}*{{fg}}.a  * {{mix}}) + ({{bg}} * (1.0-{{mix}}));
#include "stdlib/genosl/mx_burn_float.osl"

void mx_burn_color4(color4 fg, color4 bg, float mix, output color4 result)
{
    mx_burn_float(fg.rgb[0], bg.rgb[0], mix, result.rgb[0]);
    mx_burn_float(fg.rgb[1], bg.rgb[1], mix, result.rgb[1]);
    mx_burn_float(fg.rgb[2], bg.rgb[2], mix, result.rgb[2]);
    mx_burn_float(fg.a, bg.a, mix, result.a);
}
void mx_geompropvalue_vector(string geomprop, vector defaultVal, output vector out)
{
    if (getattribute(geomprop, out) == 0)
        out = defaultVal;
}
mx_add({{in1}}, {{in2}})
void mx_fractal3d_fa_vector4(float amplitude, int octaves, float lacunarity, float diminish, vector position, output vector4 result)
{
    vector4 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
normalize({{in}})
mod({{in1}}, {{in2}})
void mx_gamma18_to_linear_color3(color _in, output color result)
{
    color gamma = color(1.8, 1.8, 1.8);
    result = pow( max( color(0., 0., 0.), _in ), gamma );
}
void mx_noise2d_fa_vector4(float amplitude, float pivot, vector2 texcoord, output vector4 result)
{
    vector4 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
void mx_fractal3d_color3(vector amplitude, int octaves, float lacunarity, float diminish, vector position, output color result)
{
    color f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Unit System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_distance_unit_float_genosl" target="genosl" />
  <implementation name="IM_distance_unit_vector2_genosl" target="genosl" />
  <implementation name="IM_distance_unit_vector3_genosl" target="genosl" />
  <implementation name="IM_distance_unit_vector4_genosl" target="genosl" />

  <implementation name="IM_angle_unit_float_genosl" target="genosl" />
  <implementation name="IM_angle_unit_vector2_genosl" target="genosl" />
  <implementation name="IM_angle_unit_vector3_genosl" target="genosl" />
  <implementation name="IM_angle_unit_vector4_genosl" target="genosl" />

</materialx>
void mx_noise2d_fa_color3(float amplitude, float pivot, vector2 texcoord, output color result)
{
    color value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
void mx_ap1_to_rec709_color4(color4 _in, output color4 result)
{
    vector4 outColor = vector4(_in.rgb[0], _in.rgb[1], _in.rgb[2], _in.a);
    matrix m = transpose(matrix(1.705079555511475, -0.1297005265951157, -0.02416634373366833, 0., -0.6242334842681885, 1.138468623161316, -0.1246141716837883, 0., -0.0808461606502533, -0.008768022060394287, 1.148780584335327, 0., 0., 0., 0., 1.));
    vector4 resultVector4 = transform(m, outColor);
    result = color4(color(resultVector4.x, resultVector4.y, resultVector4.z), resultVector4.w);
}
void mx_noise3d_fa_vector4(float amplitude, float pivot, vector position, output vector4 result)
{
    vector4 value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_fractal3d_float(float amplitude, int octaves, float lacunarity, float diminish, vector position, output float result)
{
    float f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
transpose({{in}})
void mx_hsvtorgb_color4(color4 _in, output color4 result)
{
    result = color4(transformc("hsv","rgb", _in.rgb), 1.0);
}
mix({{bg}}, {{fg}}, {{mix}})
void mx_noise3d_color4(vector4 amplitude, float pivot, vector position, output color4 result)
{
    color4 value = noise("snoise", position);
    result = value * combine(amplitude.x, amplitude.y, amplitude.z, amplitude.w) + pivot;
}
void mx_fractal3d_fa_vector2(float amplitude, int octaves, float lacunarity, float diminish, vector position, output vector2 result)
{
    vector2 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
color4({{fg}}.rgb*{{fg}}.a + {{bg}}.rgb*(1.0-{{fg}}.a), {{fg}}.a + ({{bg}}.a*(1.0-{{fg}}.a)) ) * {{mix}} + ({{bg}} * (1.0-{{mix}}))
sin({{in}})
exp({{in}})
pow({{in1}}, {{in2}})
void mx_noise3d_vector3(vector amplitude, float pivot, vector position, output vector result)
{
    vector value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_geompropvalue_boolean(string geomprop, int defaultVal, output int out)
{
    if (getattribute(geomprop, out) == 0)
        out = defaultVal;
}
void mx_geomcolor_color4(int index, output color4 result)
{
    float value[4];
    getattribute("color", value);
    result.rgb[0] = value[0];
    result.rgb[1] = value[1];
    result.rgb[2] = value[2];
    result.a = value[3];
}
void mx_gamma18_to_linear_color4(color4 _in, output color4 result)
{
    color4 gamma = color4(color(1.8, 1.8, 1.8), 1.);
    result = pow( max( color4(color(0., 0., 0.), 0.), _in ), gamma );
}
({{mix}}*({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})
sqrt({{in}})
#include "$fileTransformUv"

void mx_image_vector3(textureresource file, string layer, vector default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output vector out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = default_value;
    vector2 st = mx_transform_uv(texcoord);
    out = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode);
}
clamp({{in}}, {{low}}, {{high}})
void mx_noise3d_float(float amplitude, float pivot, vector position, output float result)
{
    float value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_g22_ap1_to_lin_rec709_color4(color4 _in, output color4 result)
{
    color4 gamma = color4(color(2.2, 2.2, 2.2), 1.);
    color4 linearColor = pow( max( color4(color(0., 0., 0.), 0.), _in ), gamma );

    vector4 linearVector = vector4(linearColor.rgb[0], linearColor.rgb[1], linearColor.rgb[2], linearColor.a);
    matrix m = transpose(matrix(1.705079555511475, -0.1297005265951157, -0.02416634373366833, 0., -0.6242334842681885, 1.138468623161316, -0.1246141716837883, 0., -0.0808461606502533, -0.008768022060394287, 1.148780584335327, 0., 0., 0., 0., 1.));
    vector4 resultVector = transform(m, linearVector);

    result = color4(color(resultVector.x, resultVector.y, resultVector.z), resultVector.w);
}
transform({{space}}, normalize(dPdv))
void mx_ambientocclusion_float(float coneangle, float maxdistance, output float result)
{
    // This node is a stub and does not currently operate to specification
    result = 0;
}
{{amount}} - {{in}}
#include "stdlib/genosl/lib/mx_transform_color.osl"

void mx_srgb_texture_to_lin_rec709_color4(color4 _in, output color4 result)
{
    result = color4(mx_srgb_texture_to_lin_rec709(_in.rgb), _in.a);
}
void mx_gamma22_to_linear_color3(color _in, output color result)
{
    color gamma = color(2.2, 2.2, 2.2);
    result = pow( max( color(0., 0., 0.), _in ), gamma );
}
void mx_gamma24_to_linear_color4(color4 _in, output color4 result)
{
    color4 gamma = color4(color(2.4, 2.4, 2.4), 1.);
    result = pow( max( color4(color(0., 0., 0.), 0.), _in ), gamma );
}
transform({{fromspace}}, {{tospace}}, point({{in}}))
void mx_noise3d_vector4(vector4 amplitude, float pivot, vector position, output vector4 result)
{
    vector4 value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_ap1_to_rec709_color3(color _in, output color result)
{
    vector4 outColor = vector4(_in[0], _in[1], _in[2], 0.);
    matrix m = transpose(matrix(1.705079555511475, -0.1297005265951157, -0.02416634373366833, 0., -0.6242334842681885, 1.138468623161316, -0.1246141716837883, 0., -0.0808461606502533, -0.008768022060394287, 1.148780584335327, 0., 0., 0., 0., 1.));
    vector4 resultVector4 = transform(m, outColor);
    result = color(resultVector4.x, resultVector4.y, resultVector4.z);
}
#include "$fileTransformUv"

void mx_image_color4(textureresource file, string layer, color4 default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output color4 out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = default_value.rgb;
    float missingAlpha = default_value.a;
    vector2 st = mx_transform_uv(texcoord);
    float alpha;
    color rgb = texture(file.filename, st.x, st.y, "alpha", alpha, "subimage", layer,
                        "missingcolor", missingColor, "missingalpha", missingAlpha, "swrap", uaddressmode, "twrap", vaddressmode $extraTextureLookupArguments );

    out = color4(rgb, alpha);
}
void mx_noise2d_fa_vector2(float amplitude, float pivot, vector2 texcoord, output vector2 result)
{
    vector2 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
cos({{in}})
log({{in}})
smoothstep({{low}}, {{high}}, {{in}})mix({{valuet}}, {{valueb}}, clamp({{texcoord}}.y, 0, 1))
({{mix}}*({{bg}} + {{fg}})) + ((1.0-{{mix}})*{{bg}})
{{in}} * {{mask}}
void mx_geompropvalue_vector2(string geomprop, vector2 defaultVal, output vector2 out)
{
    float value[2];
    if (getattribute(geomprop, value) == 0)
    {
        out = defaultVal;
    }
    else
    {
        out.x = value[0];
        out.y = value[1];
    }
}
abs({{in}})
void mx_rgbtohsv_color3(vector _in, output vector result)
{
    result = transformc("rgb","hsv", _in);
}
dot({{in1}}, {{in2}})
atan2({{in1}},{{in2}})
void mx_geompropvalue_string(string geomprop, string defaultVal, output string out)
{
    if (getattribute(geomprop, out) == 0)
        out = defaultVal;
}
acos({{in}})
void mx_geomcolor_color3(int index, output color result)
{
    getattribute("color", result);
}
void mx_worleynoise3d_float(vector position, float jitter, output float result)
{
    result = mx_worley_noise_float(position, jitter, 0);
}
void mx_fractal3d_fa_color3(float amplitude, int octaves, float lacunarity, float diminish, vector position, output color result)
{
    color f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * amplitude;
}
void mx_noise2d_vector4(vector4 amplitude, float pivot, vector2 texcoord, output vector4 result)
{
    vector4 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
void mx_gamma22_to_linear_color4(color4 _in, output color4 result)
{
    color4 gamma = color4(color(2.2, 2.2, 2.2), 1.);
    result = pow( max( color4(color(0., 0., 0.), 0.), _in ), gamma );
}
void mx_geompropvalue_color4(string geomprop, color4 defaultVal, output color4 out)
{
    float value[4];
    if (getattribute(geomprop, value) == 0)
    {
        out.rgb = defaultVal.rgb;
        out.a = defaultVal.a;
    }
    else
    {
        out.rgb[0] = value[0];
        out.rgb[1] = value[1];
        out.rgb[2] = value[2];
        out.a = value[3];
    }
}
#include "stdlib/genosl/mx_burn_float.osl"

void mx_burn_color3(color fg, color bg, float mix, output color result)
{
    mx_burn_float(fg[0], bg[0], mix, result[0]);
    mx_burn_float(fg[1], bg[1], mix, result[1]);
    mx_burn_float(fg[2], bg[2], mix, result[2]);
}
transform({{mat}}, {{in}})
void mx_noise2d_vector2(vector2 amplitude, float pivot, vector2 texcoord, output vector2 result)
{
    vector2 value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
#include "$fileTransformUv"

void mx_image_vector4(textureresource file, string layer, vector4 default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output vector4 out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = color(default_value.x, default_value.y, default_value.z);
    float missingAlpha = default_value.w;
    vector2 st = mx_transform_uv(texcoord);
    float alpha;
    color rgb = texture(file.filename, st.x, st.y, "alpha", alpha, "subimage", layer,
                        "missingcolor", missingColor, "missingalpha", missingAlpha, "swrap", uaddressmode, "twrap", vaddressmode);

    out = vector4(rgb[0], rgb[1], rgb[2], alpha);
}
void mx_noise3d_fa_color4(float amplitude, float pivot, vector position, output color4 result)
{
    color4 value = noise("snoise", position);
    result = value * amplitude + pivot;
}
void mx_worleynoise3d_vector2(vector position, float jitter, output vector2 result)
{
    result = mx_worley_noise_vector2(position, jitter, 0);
}
void mx_burn_float(float fg, float bg, float mix, output float result)
{
    if (abs(fg) < M_FLOAT_EPS)
    {
        result = 0.0;
        return;
    }
    result = mix*(1.0 - ((1.0 - bg) / fg)) + ((1.0-mix)*bg);
}
void mx_unpremult_color4(color4 in, output color4 result)
{
    result = color4(in.rgb / in.a, in.a);
}
void mx_fractal3d_color4(vector4 amplitude, int octaves, float lacunarity, float diminish, vector position, output color4 result)
{
    color4 f = fBm(position, octaves, lacunarity, diminish, "snoise");
    result = f * combine(amplitude.x, amplitude.y, amplitude.z, amplitude.w);
}
void mx_dodge_float(float fg, float bg, float mix, output float out)
{
    if (abs(1.0 - fg) < M_FLOAT_EPS)
    {
        out = 0.0;
        return;
    }
    out = mix*(bg / (1.0 - fg)) + ((1.0-mix)*bg);
}
mx_sub({{in1}}, {{in2}})
void mx_noise3d_color3(vector amplitude, float pivot, vector position, output color result)
{
    color value = noise("snoise", position);
    result = value * amplitude + pivot;
}
determinant({{in}})
void mx_noise3d_fa_vector2(float amplitude, float pivot, vector position, output vector2 result)
{
    vector2 value = noise("snoise", position);
    result = value * amplitude + pivot;
}
{{in1}} / {{in2}}
({{fg}} < 0.5) ? ({{mix}}*2.0*{{fg}}*{{bg}}) + ((1.0-{{mix}})*{{bg}}) : ({{mix}}*(1.0-(1.0-{{fg}})*(1.0-{{bg}}))) + ((1.0-{{mix}})*{{bg}})
void mx_noise2d_vector3(vector amplitude, float pivot, vector2 texcoord, output vector result)
{
    vector value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
remap({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}}, 0)
void mx_luminance_color4(color4 in, color lumacoeffs, output color4 result)
{
    result = color4(dot(in.rgb, lumacoeffs), in.a);
}
transform({{fromspace}}, {{tospace}}, normal({{in}}))
({{fg}}*(1.0-{{bg}}.a)  * {{mix}}) + ({{bg}} * (1.0-{{mix}}))
#include "stdlib/genosl/mx_dodge_float.osl"

void mx_dodge_color3(color fg, color bg, float mix, output color result)
{
    mx_dodge_float(fg[0], bg[0], mix, result[0]);
    mx_dodge_float(fg[1], bg[1], mix, result[1]);
    mx_dodge_float(fg[2], bg[2], mix, result[2]);
}
void mx_gamma24_to_linear_color3(color _in, output color result)
{
    color gamma = color(2.4, 2.4, 2.4);
    result = pow( max( color(0., 0., 0.), _in ), gamma );
}
{{in1}} * {{in2}}
void mx_cellnoise2d_float(vector2 texcoord, output float result)
{
    result = cellnoise(texcoord.x, texcoord.y);
}
float overlay(float fg, float bg)
{
    return (fg < 0.5) ? (2 * fg * bg) : (1 - (1 - fg) * (1 - bg));
}

color overlay(color fg, color bg)
{
    return color(overlay(fg[0], bg[0]),
                 overlay(fg[1], bg[1]),
                 overlay(fg[2], bg[2]));
}

void mx_overlay_color3(color fg, color bg, float mix, output color out)
{
    out = mix * overlay(fg, bg) + (1-mix) * bg;
}
({{mix}}*abs({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})
#include "$fileTransformUv"

void mx_image_float(textureresource file, string layer, float default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output float out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = color(default_value);
    vector2 st = mx_transform_uv(texcoord);
    color rgb = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode);
    out = rgb[0];
}
sign({{in}})
ceil({{in}})
{{value}}
void mx_noise3d_fa_color3(float amplitude, float pivot, vector position, output color result)
{
    color value = noise("snoise", position);
    result = value * amplitude + pivot;
}
floor({{in}})
void mx_luminance_color3(color in, color lumacoeffs, output color result)
{
    result = dot(in, lumacoeffs);
}
tan({{in}})
mix({{valuet}}, {{valueb}}, aastep({{center}}, {{texcoord}}.y))
void mx_geompropvalue_integer(string geomprop, int defaultVal, output int out)
{
    if (getattribute(geomprop, out) == 0)
        out = defaultVal;
}
void mx_transformmatrix_vector2M3(vector2 val, matrix m, output vector2 result)
{
    point res = transform(m, point(val.x, val.y, 1.0));
    result.x = res[0];
    result.y = res[1];
}
mod({{in1}}, vector({{in2}},{{in2}},{{in2}}))
matrix rotationMatrix(vector axis, float angle)
{
    vector nAxis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return matrix(oc * nAxis[0] * nAxis[0] + c,             oc * nAxis[0] * nAxis[1] - nAxis[2] * s,  oc * nAxis[2] * nAxis[0] + nAxis[1] * s,  0.0,
                  oc * nAxis[0] * nAxis[1] + nAxis[2] * s,  oc * nAxis[1] * nAxis[1] + c,             oc * nAxis[1] * nAxis[2] - nAxis[0] * s,  0.0,
                  oc * nAxis[2] * nAxis[0] - nAxis[1] * s,  oc * nAxis[1] * nAxis[2] + nAxis[0] * s,  oc * nAxis[2] * nAxis[2] + c,             0.0,
                  0.0,                                      0.0,                                      0.0,                                      1.0);
}

void mx_rotate_vector3(vector _in, float amount, vector axis, output vector result)
{
    float rotationRadians = radians(amount);
    matrix m = rotationMatrix(axis, rotationRadians);
    vector4 trans = transform(m, vector4(_in[0], _in[1], _in[2], 1.0));
    result = vector(trans.x, trans.y, trans.z);
}
void mx_noise3d_vector2(vector2 amplitude, float pivot, vector position, output vector2 result)
{
    vector2 value = noise("snoise", position);
    result = value * amplitude + pivot;
}
contrast({{in}}, {{amount}}, {{pivot}})
transform({{space}}, N)
void mx_g22_ap1_to_lin_rec709_color3(color _in, output color result)
{
    color gamma = color(2.2, 2.2, 2.2);
    color linearColor = pow( max( color(0., 0., 0.), _in ), gamma );

    vector4 linearVector = vector4(linearColor[0], linearColor[1], linearColor[2], 0.);
    matrix m = transpose(matrix(1.705079555511475, -0.1297005265951157, -0.02416634373366833, 0., -0.6242334842681885, 1.138468623161316, -0.1246141716837883, 0., -0.0808461606502533, -0.008768022060394287, 1.148780584335327, 0., 0., 0., 0., 1.));
    vector4 resultVector = transform(m, linearVector);

    result = color(resultVector.x, resultVector.y, resultVector.z);
}
void mx_noise2d_float(float amplitude, float pivot, vector2 texcoord, output float result)
{
    float value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
mod({{in1}}, color({{in2}},{{in2}},{{in2}}))
void mx_geompropvalue_vector4(string geomprop, vector4 defaultVal, output vector4 out)
{
    float value[4];
    if (getattribute(geomprop, value) == 0)
    {
        out = defaultVal;
    }
    else
    {
        out.x = value[0];
        out.y = value[1];
        out.z = value[2];
        out.w = value[3];
    }
}
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2017 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Declarations for OSL implementations of standard nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Shader nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <surface> -->
  <implementation name="IM_surface_unlit_genosl" nodedef="ND_surface_unlit" file="stdlib/genosl/mx_surface_unlit.osl" function="mx_surface_unlit" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Texture nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <image> -->
  <implementation name="IM_image_float_genosl" nodedef="ND_image_float" file="stdlib/genosl/mx_image_float.osl" function="mx_image_float" target="genosl">
    <input name="default" type="float" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color3_genosl" nodedef="ND_image_color3" file="stdlib/genosl/mx_image_color3.osl" function="mx_image_color3" target="genosl">
    <input name="default" type="color3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color4_genosl" nodedef="ND_image_color4" file="stdlib/genosl/mx_image_color4.osl" function="mx_image_color4" target="genosl">
    <input name="default" type="color4" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector2_genosl" nodedef="ND_image_vector2" file="stdlib/genosl/mx_image_vector2.osl" function="mx_image_vector2" target="genosl">
    <input name="default" type="vector2" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector3_genosl" nodedef="ND_image_vector3" file="stdlib/genosl/mx_image_vector3.osl" function="mx_image_vector3" target="genosl">
    <input name="default" type="vector3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector4_genosl" nodedef="ND_image_vector4" file="stdlib/genosl/mx_image_vector4.osl" function="mx_image_vector4" target="genosl">
    <input name="default" type="vector4" implname="default_value" />
  </implementation>

  <!-- <triplanarprojection> -->

  <!-- <normalmap> -->
  <implementation name="IM_normalmap_genosl" nodedef="ND_normalmap" file="stdlib/genosl/mx_normalmap.osl" function="mx_normalmap" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Procedural nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <constant> -->
  <implementation name="IM_constant_float_genosl" nodedef="ND_constant_float" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_color3_genosl" nodedef="ND_constant_color3" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_color4_genosl" nodedef="ND_constant_color4" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_vector2_genosl" nodedef="ND_constant_vector2" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_vector3_genosl" nodedef="ND_constant_vector3" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_vector4_genosl" nodedef="ND_constant_vector4" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_boolean_genosl" nodedef="ND_constant_boolean" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_integer_genosl" nodedef="ND_constant_integer" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_matrix33_genosl" nodedef="ND_constant_matrix33" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_matrix44_genosl" nodedef="ND_constant_matrix44" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_string_genosl" nodedef="ND_constant_string" file="stdlib/genosl/mx_constant.inline" target="genosl" />
  <implementation name="IM_constant_filename_genosl" nodedef="ND_constant_filename" file="stdlib/genosl/mx_constant.inline" target="genosl" />

  <!-- <ramplr> -->
  <implementation name="IM_ramplr_float_genosl" nodedef="ND_ramplr_float" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />
  <implementation name="IM_ramplr_color3_genosl" nodedef="ND_ramplr_color3" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />
  <implementation name="IM_ramplr_color4_genosl" nodedef="ND_ramplr_color4" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />
  <implementation name="IM_ramplr_vector2_genosl" nodedef="ND_ramplr_vector2" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />
  <implementation name="IM_ramplr_vector3_genosl" nodedef="ND_ramplr_vector3" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />
  <implementation name="IM_ramplr_vector4_genosl" nodedef="ND_ramplr_vector4" file="stdlib/genosl/mx_ramplr.inline" target="genosl" />

  <!-- <ramptb> -->
  <implementation name="IM_ramptb_float_genosl" nodedef="ND_ramptb_float" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />
  <implementation name="IM_ramptb_color3_genosl" nodedef="ND_ramptb_color3" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />
  <implementation name="IM_ramptb_color4_genosl" nodedef="ND_ramptb_color4" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />
  <implementation name="IM_ramptb_vector2_genosl" nodedef="ND_ramptb_vector2" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />
  <implementation name="IM_ramptb_vector3_genosl" nodedef="ND_ramptb_vector3" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />
  <implementation name="IM_ramptb_vector4_genosl" nodedef="ND_ramptb_vector4" file="stdlib/genosl/mx_ramptb.inline" target="genosl" />

  <!-- <splitlr> -->
  <implementation name="IM_splitlr_float_genosl" nodedef="ND_splitlr_float" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />
  <implementation name="IM_splitlr_color3_genosl" nodedef="ND_splitlr_color3" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />
  <implementation name="IM_splitlr_color4_genosl" nodedef="ND_splitlr_color4" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />
  <implementation name="IM_splitlr_vector2_genosl" nodedef="ND_splitlr_vector2" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />
  <implementation name="IM_splitlr_vector3_genosl" nodedef="ND_splitlr_vector3" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />
  <implementation name="IM_splitlr_vector4_genosl" nodedef="ND_splitlr_vector4" file="stdlib/genosl/mx_splitlr.inline" target="genosl" />

  <!-- <splittb> -->
  <implementation name="IM_splittb_float_genosl" nodedef="ND_splittb_float" file="stdlib/genosl/mx_splittb.inline" target="genosl" />
  <implementation name="IM_splittb_color3_genosl" nodedef="ND_splittb_color3" file="stdlib/genosl/mx_splittb.inline" target="genosl" />
  <implementation name="IM_splittb_color4_genosl" nodedef="ND_splittb_color4" file="stdlib/genosl/mx_splittb.inline" target="genosl" />
  <implementation name="IM_splittb_vector2_genosl" nodedef="ND_splittb_vector2" file="stdlib/genosl/mx_splittb.inline" target="genosl" />
  <implementation name="IM_splittb_vector3_genosl" nodedef="ND_splittb_vector3" file="stdlib/genosl/mx_splittb.inline" target="genosl" />
  <implementation name="IM_splittb_vector4_genosl" nodedef="ND_splittb_vector4" file="stdlib/genosl/mx_splittb.inline" target="genosl" />

  <!-- <noise2d> -->
  <implementation name="IM_noise2d_float_genosl" nodedef="ND_noise2d_float" file="stdlib/genosl/mx_noise2d_float.osl" function="mx_noise2d_float" target="genosl" />
  <implementation name="IM_noise2d_color3_genosl" nodedef="ND_noise2d_color3" file="stdlib/genosl/mx_noise2d_color3.osl" function="mx_noise2d_color3" target="genosl" />
  <implementation name="IM_noise2d_color4_genosl" nodedef="ND_noise2d_color4" file="stdlib/genosl/mx_noise2d_color4.osl" function="mx_noise2d_color4" target="genosl" />
  <implementation name="IM_noise2d_color3FA_genosl" nodedef="ND_noise2d_color3FA" file="stdlib/genosl/mx_noise2d_fa_color3.osl" function="mx_noise2d_fa_color3" target="genosl" />
  <implementation name="IM_noise2d_color4FA_genosl" nodedef="ND_noise2d_color4FA" file="stdlib/genosl/mx_noise2d_fa_color4.osl" function="mx_noise2d_fa_color4" target="genosl" />
  <implementation name="IM_noise2d_vector2_genosl" nodedef="ND_noise2d_vector2" file="stdlib/genosl/mx_noise2d_vector2.osl" function="mx_noise2d_vector2" target="genosl" />
  <implementation name="IM_noise2d_vector3_genosl" nodedef="ND_noise2d_vector3" file="stdlib/genosl/mx_noise2d_vector3.osl" function="mx_noise2d_vector3" target="genosl" />
  <implementation name="IM_noise2d_vector4_genosl" nodedef="ND_noise2d_vector4" file="stdlib/genosl/mx_noise2d_vector4.osl" function="mx_noise2d_vector4" target="genosl" />
  <implementation name="IM_noise2d_vector2FA_genosl" nodedef="ND_noise2d_vector2FA" file="stdlib/genosl/mx_noise2d_fa_vector2.osl" function="mx_noise2d_fa_vector2" target="genosl" />
  <implementation name="IM_noise2d_vector3FA_genosl" nodedef="ND_noise2d_vector3FA" file="stdlib/genosl/mx_noise2d_fa_vector3.osl" function="mx_noise2d_fa_vector3" target="genosl" />
  <implementation name="IM_noise2d_vector4FA_genosl" nodedef="ND_noise2d_vector4FA" file="stdlib/genosl/mx_noise2d_fa_vector4.osl" function="mx_noise2d_fa_vector4" target="genosl" />

  <!-- <noise3d> -->
  <implementation name="IM_noise3d_float_genosl" nodedef="ND_noise3d_float" file="stdlib/genosl/mx_noise3d_float.osl" function="mx_noise3d_float" target="genosl" />
  <implementation name="IM_noise3d_color3_genosl" nodedef="ND_noise3d_color3" file="stdlib/genosl/mx_noise3d_color3.osl" function="mx_noise3d_color3" target="genosl" />
  <implementation name="IM_noise3d_color4_genosl" nodedef="ND_noise3d_color4" file="stdlib/genosl/mx_noise3d_color4.osl" function="mx_noise3d_color4" target="genosl" />
  <implementation name="IM_noise3d_color3FA_genosl" nodedef="ND_noise3d_color3FA" file="stdlib/genosl/mx_noise3d_fa_color3.osl" function="mx_noise3d_fa_color3" target="genosl" />
  <implementation name="IM_noise3d_color4FA_genosl" nodedef="ND_noise3d_color4FA" file="stdlib/genosl/mx_noise3d_fa_color4.osl" function="mx_noise3d_fa_color4" target="genosl" />
  <implementation name="IM_noise3d_vector2_genosl" nodedef="ND_noise3d_vector2" file="stdlib/genosl/mx_noise3d_vector2.osl" function="mx_noise3d_vector2" target="genosl" />
  <implementation name="IM_noise3d_vector3_genosl" nodedef="ND_noise3d_vector3" file="stdlib/genosl/mx_noise3d_vector3.osl" function="mx_noise3d_vector3" target="genosl" />
  <implementation name="IM_noise3d_vector4_genosl" nodedef="ND_noise3d_vector4" file="stdlib/genosl/mx_noise3d_vector4.osl" function="mx_noise3d_vector4" target="genosl" />
  <implementation name="IM_noise3d_vector2FA_genosl" nodedef="ND_noise3d_vector2FA" file="stdlib/genosl/mx_noise3d_fa_vector2.osl" function="mx_noise3d_fa_vector2" target="genosl" />
  <implementation name="IM_noise3d_vector3FA_genosl" nodedef="ND_noise3d_vector3FA" file="stdlib/genosl/mx_noise3d_fa_vector3.osl" function="mx_noise3d_fa_vector3" target="genosl" />
  <implementation name="IM_noise3d_vector4FA_genosl" nodedef="ND_noise3d_vector4FA" file="stdlib/genosl/mx_noise3d_fa_vector4.osl" function="mx_noise3d_fa_vector4" target="genosl" />

  <!-- <fractal3d> -->
  <implementation name="IM_fractal3d_float_genosl" nodedef="ND_fractal3d_float" file="stdlib/genosl/mx_fractal3d_float.osl" function="mx_fractal3d_float" target="genosl" />
  <implementation name="IM_fractal3d_color3_genosl" nodedef="ND_fractal3d_color3" file="stdlib/genosl/mx_fractal3d_color3.osl" function="mx_fractal3d_color3" target="genosl" />
  <implementation name="IM_fractal3d_color4_genosl" nodedef="ND_fractal3d_color4" file="stdlib/genosl/mx_fractal3d_color4.osl" function="mx_fractal3d_color4" target="genosl" />
  <implementation name="IM_fractal3d_color3FA_genosl" nodedef="ND_fractal3d_color3FA" file="stdlib/genosl/mx_fractal3d_fa_color3.osl" function="mx_fractal3d_fa_color3" target="genosl" />
  <implementation name="IM_fractal3d_color4FA_genosl" nodedef="ND_fractal3d_color4FA" file="stdlib/genosl/mx_fractal3d_fa_color4.osl" function="mx_fractal3d_fa_color4" target="genosl" />
  <implementation name="IM_fractal3d_vector2_genosl" nodedef="ND_fractal3d_vector2" file="stdlib/genosl/mx_fractal3d_vector2.osl" function="mx_fractal3d_vector2" target="genosl" />
  <implementation name="IM_fractal3d_vector3_genosl" nodedef="ND_fractal3d_vector3" file="stdlib/genosl/mx_fractal3d_vector3.osl" function="mx_fractal3d_vector3" target="genosl" />
  <implementation name="IM_fractal3d_vector4_genosl" nodedef="ND_fractal3d_vector4" file="stdlib/genosl/mx_fractal3d_vector4.osl" function="mx_fractal3d_vector4" target="genosl" />
  <implementation name="IM_fractal3d_vector2FA_genosl" nodedef="ND_fractal3d_vector2FA" file="stdlib/genosl/mx_fractal3d_fa_vector2.osl" function="mx_fractal3d_fa_vector2" target="genosl" />
  <implementation name="IM_fractal3d_vector3FA_genosl" nodedef="ND_fractal3d_vector3FA" file="stdlib/genosl/mx_fractal3d_fa_vector3.osl" function="mx_fractal3d_fa_vector3" target="genosl" />
  <implementation name="IM_fractal3d_vector4FA_genosl" nodedef="ND_fractal3d_vector4FA" file="stdlib/genosl/mx_fractal3d_fa_vector4.osl" function="mx_fractal3d_fa_vector4" target="genosl" />

  <!-- <cellnoise2d> -->
  <implementation name="IM_cellnoise2d_float_genosl" nodedef="ND_cellnoise2d_float" file="stdlib/genosl/mx_cellnoise2d_float.osl" function="mx_cellnoise2d_float" target="genosl" />

  <!-- <cellnoise3d> -->
  <implementation name="IM_cellnoise3d_float_genosl" nodedef="ND_cellnoise3d_float" file="stdlib/genosl/mx_cellnoise3d_float.osl" function="mx_cellnoise3d_float" target="genosl" />

  <!-- <worleynoise2d> -->
  <implementation name="IM_worleynoise2d_float_genosl" nodedef="ND_worleynoise2d_float" file="stdlib/genosl/mx_worleynoise2d_float.osl" function="mx_worleynoise2d_float" target="genosl" />
  <implementation name="IM_worleynoise2d_vector2_genosl" nodedef="ND_worleynoise2d_vector2" file="stdlib/genosl/mx_worleynoise2d_vector2.osl" function="mx_worleynoise2d_vector2" target="genosl" />
  <implementation name="IM_worleynoise2d_vector3_genosl" nodedef="ND_worleynoise2d_vector3" file="stdlib/genosl/mx_worleynoise2d_vector3.osl" function="mx_worleynoise2d_vector3" target="genosl" />

  <!-- <worleynoise3d> -->
  <implementation name="IM_worleynoise3d_float_genosl" nodedef="ND_worleynoise3d_float" file="stdlib/genosl/mx_worleynoise3d_float.osl" function="mx_worleynoise3d_float" target="genosl" />
  <implementation name="IM_worleynoise3d_vector2_genosl" nodedef="ND_worleynoise3d_vector2" file="stdlib/genosl/mx_worleynoise3d_vector2.osl" function="mx_worleynoise3d_vector2" target="genosl" />
  <implementation name="IM_worleynoise3d_vector3_genosl" nodedef="ND_worleynoise3d_vector3" file="stdlib/genosl/mx_worleynoise3d_vector3.osl" function="mx_worleynoise3d_vector3" target="genosl" />


  <!-- ======================================================================== -->
  <!-- Global nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <ambientocclusion> -->
  <implementation name="IM_ambientocclusion_float_genosl" nodedef="ND_ambientocclusion_float" file="stdlib/genosl/mx_ambientocclusion_float.osl" function="mx_ambientocclusion_float" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Geometric nodes                                                          -->
  <!-- ======================================================================== -->

  <!-- <position> -->
  <implementation name="IM_position_vector3_genosl" nodedef="ND_position_vector3" file="stdlib/genosl/mx_position_vector3.inline" target="genosl" />

  <!-- <normal> -->
  <implementation name="IM_normal_vector3_genosl" nodedef="ND_normal_vector3" file="stdlib/genosl/mx_normal_vector3.inline" target="genosl" />

  <!-- <tangent> -->
  <implementation name="IM_tangent_vector3_genosl" nodedef="ND_tangent_vector3" file="stdlib/genosl/mx_tangent_vector3.inline" target="genosl" />

  <!-- <bitangent> -->
  <implementation name="IM_bitangent_vector3_genosl" nodedef="ND_bitangent_vector3" file="stdlib/genosl/mx_bitangent_vector3.inline" target="genosl" />

  <!-- <texcoord> -->
  <implementation name="IM_texcoord_vector2_genosl" nodedef="ND_texcoord_vector2" file="stdlib/genosl/mx_texcoord_vector2.inline" target="genosl" />
  <implementation name="IM_texcoord_vector3_genosl" nodedef="ND_texcoord_vector3" file="stdlib/genosl/mx_texcoord_vector3.inline" target="genosl" />

  <!-- <geomcolor> -->
  <implementation name="IM_geomcolor_float_genosl" nodedef="ND_geomcolor_float" file="stdlib/genosl/mx_geomcolor_float.osl" function="mx_geomcolor_float" target="genosl" />
  <implementation name="IM_geomcolor_color3_genosl" nodedef="ND_geomcolor_color3" file="stdlib/genosl/mx_geomcolor_color3.osl" function="mx_geomcolor_color3" target="genosl" />
  <implementation name="IM_geomcolor_color4_genosl" nodedef="ND_geomcolor_color4" file="stdlib/genosl/mx_geomcolor_color4.osl" function="mx_geomcolor_color4" target="genosl" />

  <!-- <geompropvalue> -->
  <implementation name="IM_geompropvalue_integer_genosl" nodedef="ND_geompropvalue_integer" file="stdlib/genosl/mx_geompropvalue_integer.osl" function="mx_geompropvalue_integer" target="genosl" />
  <implementation name="IM_geompropvalue_boolean_genosl" nodedef="ND_geompropvalue_boolean" file="stdlib/genosl/mx_geompropvalue_boolean.osl" function="mx_geompropvalue_boolean" target="genosl" />
  <implementation name="IM_geompropvalue_string_genosl" nodedef="ND_geompropvalue_string" file="stdlib/genosl/mx_geompropvalue_string.osl" function="mx_geompropvalue_string" target="genosl" />
  <implementation name="IM_geompropvalue_float_genosl" nodedef="ND_geompropvalue_float" file="stdlib/genosl/mx_geompropvalue_float.osl" function="mx_geompropvalue_float" target="genosl" />
  <implementation name="IM_geompropvalue_color3_genosl" nodedef="ND_geompropvalue_color3" file="stdlib/genosl/mx_geompropvalue_color3.osl" function="mx_geompropvalue_color" target="genosl" />
  <implementation name="IM_geompropvalue_color4_genosl" nodedef="ND_geompropvalue_color4" file="stdlib/genosl/mx_geompropvalue_color4.osl" function="mx_geompropvalue_color4" target="genosl" />
  <implementation name="IM_geompropvalue_vector2_genosl" nodedef="ND_geompropvalue_vector2" file="stdlib/genosl/mx_geompropvalue_vector2.osl" function="mx_geompropvalue_vector2" target="genosl" />
  <implementation name="IM_geompropvalue_vector3_genosl" nodedef="ND_geompropvalue_vector3" file="stdlib/genosl/mx_geompropvalue_vector3.osl" function="mx_geompropvalue_vector" target="genosl" />
  <implementation name="IM_geompropvalue_vector4_genosl" nodedef="ND_geompropvalue_vector4" file="stdlib/genosl/mx_geompropvalue_vector4.osl" function="mx_geompropvalue_vector4" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Application nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <frame> -->
  <implementation name="IM_frame_float_genosl" nodedef="ND_frame_float" file="stdlib/genosl/mx_frame_float.osl" function="mx_frame_float" target="genosl" />

  <!-- <time> -->
  <implementation name="IM_time_float_genosl" nodedef="ND_time_float" file="stdlib/genosl/mx_time_float.osl" function="mx_time_float" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Math nodes                                                               -->
  <!-- ======================================================================== -->

  <!-- <add> -->
  <implementation name="IM_add_float_genosl" nodedef="ND_add_float" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_color3_genosl" nodedef="ND_add_color3" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_color3FA_genosl" nodedef="ND_add_color3FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_color4_genosl" nodedef="ND_add_color4" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_color4FA_genosl" nodedef="ND_add_color4FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector2_genosl" nodedef="ND_add_vector2" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector2FA_genosl" nodedef="ND_add_vector2FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector3_genosl" nodedef="ND_add_vector3" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector3FA_genosl" nodedef="ND_add_vector3FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector4_genosl" nodedef="ND_add_vector4" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_vector4FA_genosl" nodedef="ND_add_vector4FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_matrix33_genosl" nodedef="ND_add_matrix33" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_matrix33FA_genosl" nodedef="ND_add_matrix33FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_matrix44_genosl" nodedef="ND_add_matrix44" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_matrix44FA_genosl" nodedef="ND_add_matrix44FA" file="stdlib/genosl/mx_add.inline" target="genosl" />
  <implementation name="IM_add_surfaceshader_genosl" nodedef="ND_add_surfaceshader" file="stdlib/genosl/mx_add.inline" target="genosl" />

  <!-- <subtract> -->
  <implementation name="IM_subtract_float_genosl" nodedef="ND_subtract_float" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_color3_genosl" nodedef="ND_subtract_color3" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_color3FA_genosl" nodedef="ND_subtract_color3FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_color4_genosl" nodedef="ND_subtract_color4" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_color4FA_genosl" nodedef="ND_subtract_color4FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector2_genosl" nodedef="ND_subtract_vector2" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector2FA_genosl" nodedef="ND_subtract_vector2FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector3_genosl" nodedef="ND_subtract_vector3" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector3FA_genosl" nodedef="ND_subtract_vector3FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector4_genosl" nodedef="ND_subtract_vector4" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_vector4FA_genosl" nodedef="ND_subtract_vector4FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_matrix33_genosl" nodedef="ND_subtract_matrix33" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_matrix33FA_genosl" nodedef="ND_subtract_matrix33FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_matrix44_genosl" nodedef="ND_subtract_matrix44" file="stdlib/genosl/mx_subtract.inline" target="genosl" />
  <implementation name="IM_subtract_matrix44FA_genosl" nodedef="ND_subtract_matrix44FA" file="stdlib/genosl/mx_subtract.inline" target="genosl" />

  <!-- <multiply> -->
  <implementation name="IM_multiply_float_genosl" nodedef="ND_multiply_float" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_color3_genosl" nodedef="ND_multiply_color3" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_color3FA_genosl" nodedef="ND_multiply_color3FA" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_color4_genosl" nodedef="ND_multiply_color4" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_color4FA_genosl" nodedef="ND_multiply_color4FA" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector2_genosl" nodedef="ND_multiply_vector2" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector2FA_genosl" nodedef="ND_multiply_vector2FA" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector3_genosl" nodedef="ND_multiply_vector3" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector3FA_genosl" nodedef="ND_multiply_vector3FA" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector4_genosl" nodedef="ND_multiply_vector4" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_vector4FA_genosl" nodedef="ND_multiply_vector4FA" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_matrix33_genosl" nodedef="ND_multiply_matrix33" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_matrix44_genosl" nodedef="ND_multiply_matrix44" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_surfaceshaderF_genosl" nodedef="ND_multiply_surfaceshaderF" file="stdlib/genosl/mx_multiply.inline" target="genosl" />
  <implementation name="IM_multiply_surfaceshaderC_genosl" nodedef="ND_multiply_surfaceshaderC" file="stdlib/genosl/mx_multiply.inline" target="genosl" />

  <!-- <divide> -->
  <implementation name="IM_divide_float_genosl" nodedef="ND_divide_float" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_color3_genosl" nodedef="ND_divide_color3" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_color3FA_genosl" nodedef="ND_divide_color3FA" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_color4_genosl" nodedef="ND_divide_color4" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_color4FA_genosl" nodedef="ND_divide_color4FA" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector2_genosl" nodedef="ND_divide_vector2" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector2FA_genosl" nodedef="ND_divide_vector2FA" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector3_genosl" nodedef="ND_divide_vector3" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector3FA_genosl" nodedef="ND_divide_vector3FA" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector4_genosl" nodedef="ND_divide_vector4" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_vector4FA_genosl" nodedef="ND_divide_vector4FA" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_matrix33_genosl" nodedef="ND_divide_matrix33" file="stdlib/genosl/mx_divide.inline" target="genosl" />
  <implementation name="IM_divide_matrix44_genosl" nodedef="ND_divide_matrix44" file="stdlib/genosl/mx_divide.inline" target="genosl" />

  <!-- <modulo> -->
  <implementation name="IM_modulo_float_genosl" nodedef="ND_modulo_float" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_color3_genosl" nodedef="ND_modulo_color3" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_color3FA_genosl" nodedef="ND_modulo_color3FA" file="stdlib/genosl/mx_modulo_color3FA.inline" target="genosl" />
  <implementation name="IM_modulo_color4_genosl" nodedef="ND_modulo_color4" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_color4FA_genosl" nodedef="ND_modulo_color4FA" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_vector2_genosl" nodedef="ND_modulo_vector2" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_vector2FA_genosl" nodedef="ND_modulo_vector2FA" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_vector3_genosl" nodedef="ND_modulo_vector3" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_vector3FA_genosl" nodedef="ND_modulo_vector3FA" file="stdlib/genosl/mx_modulo_vector3FA.inline" target="genosl" />
  <implementation name="IM_modulo_vector4_genosl" nodedef="ND_modulo_vector4" file="stdlib/genosl/mx_modulo.inline" target="genosl" />
  <implementation name="IM_modulo_vector4FA_genosl" nodedef="ND_modulo_vector4FA" file="stdlib/genosl/mx_modulo.inline" target="genosl" />

  <!-- <invert> -->
  <implementation name="IM_invert_float_genosl" nodedef="ND_invert_float" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_color3_genosl" nodedef="ND_invert_color3" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_color3FA_genosl" nodedef="ND_invert_color3FA" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_color4_genosl" nodedef="ND_invert_color4" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_color4FA_genosl" nodedef="ND_invert_color4FA" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector2_genosl" nodedef="ND_invert_vector2" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector2FA_genosl" nodedef="ND_invert_vector2FA" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector3_genosl" nodedef="ND_invert_vector3" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector3FA_genosl" nodedef="ND_invert_vector3FA" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector4_genosl" nodedef="ND_invert_vector4" file="stdlib/genosl/mx_invert.inline" target="genosl" />
  <implementation name="IM_invert_vector4FA_genosl" nodedef="ND_invert_vector4FA" file="stdlib/genosl/mx_invert.inline" target="genosl" />

  <!-- <absval> -->
  <implementation name="IM_absval_float_genosl" nodedef="ND_absval_float" file="stdlib/genosl/mx_absval.inline" target="genosl" />
  <implementation name="IM_absval_color3_genosl" nodedef="ND_absval_color3" file="stdlib/genosl/mx_absval.inline" target="genosl" />
  <implementation name="IM_absval_color4_genosl" nodedef="ND_absval_color4" file="stdlib/genosl/mx_absval.inline" target="genosl" />
  <implementation name="IM_absval_vector2_genosl" nodedef="ND_absval_vector2" file="stdlib/genosl/mx_absval.inline" target="genosl" />
  <implementation name="IM_absval_vector3_genosl" nodedef="ND_absval_vector3" file="stdlib/genosl/mx_absval.inline" target="genosl" />
  <implementation name="IM_absval_vector4_genosl" nodedef="ND_absval_vector4" file="stdlib/genosl/mx_absval.inline" target="genosl" />

  <!-- <floor> -->
  <implementation name="IM_floor_float_genosl" nodedef="ND_floor_float" file="stdlib/genosl/mx_floor.inline" target="genosl" />
  <implementation name="IM_floor_color3_genosl" nodedef="ND_floor_color3" file="stdlib/genosl/mx_floor.inline" target="genosl" />
  <implementation name="IM_floor_color4_genosl" nodedef="ND_floor_color4" file="stdlib/genosl/mx_floor.inline" target="genosl" />
  <implementation name="IM_floor_vector2_genosl" nodedef="ND_floor_vector2" file="stdlib/genosl/mx_floor.inline" target="genosl" />
  <implementation name="IM_floor_vector3_genosl" nodedef="ND_floor_vector3" file="stdlib/genosl/mx_floor.inline" target="genosl" />
  <implementation name="IM_floor_vector4_genosl" nodedef="ND_floor_vector4" file="stdlib/genosl/mx_floor.inline" target="genosl" />

  <!-- <ceil> -->
  <implementation name="IM_ceil_float_genosl" nodedef="ND_ceil_float" file="stdlib/genosl/mx_ceil.inline" target="genosl" />
  <implementation name="IM_ceil_color3_genosl" nodedef="ND_ceil_color3" file="stdlib/genosl/mx_ceil.inline" target="genosl" />
  <implementation name="IM_ceil_color4_genosl" nodedef="ND_ceil_color4" file="stdlib/genosl/mx_ceil.inline" target="genosl" />
  <implementation name="IM_ceil_vector2_genosl" nodedef="ND_ceil_vector2" file="stdlib/genosl/mx_ceil.inline" target="genosl" />
  <implementation name="IM_ceil_vector3_genosl" nodedef="ND_ceil_vector3" file="stdlib/genosl/mx_ceil.inline" target="genosl" />
  <implementation name="IM_ceil_vector4_genosl" nodedef="ND_ceil_vector4" file="stdlib/genosl/mx_ceil.inline" target="genosl" />

  <!-- <power> -->
  <implementation name="IM_power_float_genosl" nodedef="ND_power_float" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_color3_genosl" nodedef="ND_power_color3" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_color3FA_genosl" nodedef="ND_power_color3FA" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_color4_genosl" nodedef="ND_power_color4" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_color4FA_genosl" nodedef="ND_power_color4FA" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector2_genosl" nodedef="ND_power_vector2" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector2FA_genosl" nodedef="ND_power_vector2FA" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector3_genosl" nodedef="ND_power_vector3" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector3FA_genosl" nodedef="ND_power_vector3FA" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector4_genosl" nodedef="ND_power_vector4" file="stdlib/genosl/mx_power.inline" target="genosl" />
  <implementation name="IM_power_vector4FA_genosl" nodedef="ND_power_vector4FA" file="stdlib/genosl/mx_power.inline" target="genosl" />

  <!-- <sin>, <cos>, <tan>, <asin>, <acos>, <atan2> -->
  <implementation name="IM_sin_float_genosl" nodedef="ND_sin_float" file="stdlib/genosl/mx_sin.inline" target="genosl" />
  <implementation name="IM_cos_float_genosl" nodedef="ND_cos_float" file="stdlib/genosl/mx_cos.inline" target="genosl" />
  <implementation name="IM_tan_float_genosl" nodedef="ND_tan_float" file="stdlib/genosl/mx_tan.inline" target="genosl" />
  <implementation name="IM_asin_float_genosl" nodedef="ND_asin_float" file="stdlib/genosl/mx_asin.inline" target="genosl" />
  <implementation name="IM_acos_float_genosl" nodedef="ND_acos_float" file="stdlib/genosl/mx_acos.inline" target="genosl" />
  <implementation name="IM_atan2_float_genosl" nodedef="ND_atan2_float" file="stdlib/genosl/mx_atan2.inline" target="genosl" />

  <implementation name="IM_sin_vector2_genosl" nodedef="ND_sin_vector2" file="stdlib/genosl/mx_sin.inline" target="genosl" />
  <implementation name="IM_cos_vector2_genosl" nodedef="ND_cos_vector2" file="stdlib/genosl/mx_cos.inline" target="genosl" />
  <implementation name="IM_tan_vector2_genosl" nodedef="ND_tan_vector2" file="stdlib/genosl/mx_tan.inline" target="genosl" />
  <implementation name="IM_asin_vector2_genosl" nodedef="ND_asin_vector2" file="stdlib/genosl/mx_asin.inline" target="genosl" />
  <implementation name="IM_acos_vector2_genosl" nodedef="ND_acos_vector2" file="stdlib/genosl/mx_acos.inline" target="genosl" />
  <implementation name="IM_atan2_vector2_genosl" nodedef="ND_atan2_vector2" file="stdlib/genosl/mx_atan2.inline" target="genosl" />

  <implementation name="IM_sin_vector3_genosl" nodedef="ND_sin_vector3" file="stdlib/genosl/mx_sin.inline" target="genosl" />
  <implementation name="IM_cos_vector3_genosl" nodedef="ND_cos_vector3" file="stdlib/genosl/mx_cos.inline" target="genosl" />
  <implementation name="IM_tan_vector3_genosl" nodedef="ND_tan_vector3" file="stdlib/genosl/mx_tan.inline" target="genosl" />
  <implementation name="IM_asin_vector3_genosl" nodedef="ND_asin_vector3" file="stdlib/genosl/mx_asin.inline" target="genosl" />
  <implementation name="IM_acos_vector3_genosl" nodedef="ND_acos_vector3" file="stdlib/genosl/mx_acos.inline" target="genosl" />
  <implementation name="IM_atan2_vector3_genosl" nodedef="ND_atan2_vector3" file="stdlib/genosl/mx_atan2.inline" target="genosl" />

  <implementation name="IM_sin_vector4_genosl" nodedef="ND_sin_vector4" file="stdlib/genosl/mx_sin.inline" target="genosl" />
  <implementation name="IM_cos_vector4_genosl" nodedef="ND_cos_vector4" file="stdlib/genosl/mx_cos.inline" target="genosl" />
  <implementation name="IM_tan_vector4_genosl" nodedef="ND_tan_vector4" file="stdlib/genosl/mx_tan.inline" target="genosl" />
  <implementation name="IM_asin_vector4_genosl" nodedef="ND_asin_vector4" file="stdlib/genosl/mx_asin.inline" target="genosl" />
  <implementation name="IM_acos_vector4_genosl" nodedef="ND_acos_vector4" file="stdlib/genosl/mx_acos.inline" target="genosl" />
  <implementation name="IM_atan2_vector4_genosl" nodedef="ND_atan2_vector4" file="stdlib/genosl/mx_atan2.inline" target="genosl" />

  <!-- <sqrt> -->
  <implementation name="IM_sqrt_float_genosl" nodedef="ND_sqrt_float" file="stdlib/genosl/mx_sqrt.inline" target="genosl" />
  <implementation name="IM_sqrt_vector2_genosl" nodedef="ND_sqrt_vector2" file="stdlib/genosl/mx_sqrt.inline" target="genosl" />
  <implementation name="IM_sqrt_vector3_genosl" nodedef="ND_sqrt_vector3" file="stdlib/genosl/mx_sqrt.inline" target="genosl" />
  <implementation name="IM_sqrt_vector4_genosl" nodedef="ND_sqrt_vector4" file="stdlib/genosl/mx_sqrt.inline" target="genosl" />

  <!-- <ln> -->
  <implementation name="IM_ln_float_genosl" nodedef="ND_ln_float" file="stdlib/genosl/mx_ln.inline" target="genosl" />
  <implementation name="IM_ln_vector2_genosl" nodedef="ND_ln_vector2" file="stdlib/genosl/mx_ln.inline" target="genosl" />
  <implementation name="IM_ln_vector3_genosl" nodedef="ND_ln_vector3" file="stdlib/genosl/mx_ln.inline" target="genosl" />
  <implementation name="IM_ln_vector4_genosl" nodedef="ND_ln_vector4" file="stdlib/genosl/mx_ln.inline" target="genosl" />

  <!-- <exp> -->
  <implementation name="IM_exp_float_genosl" nodedef="ND_exp_float" file="stdlib/genosl/mx_exp.inline" target="genosl" />
  <implementation name="IM_exp_vector2_genosl" nodedef="ND_exp_vector2" file="stdlib/genosl/mx_exp.inline" target="genosl" />
  <implementation name="IM_exp_vector3_genosl" nodedef="ND_exp_vector3" file="stdlib/genosl/mx_exp.inline" target="genosl" />
  <implementation name="IM_exp_vector4_genosl" nodedef="ND_exp_vector4" file="stdlib/genosl/mx_exp.inline" target="genosl" />

  <!-- sign -->
  <implementation name="IM_sign_float_genosl" nodedef="ND_sign_float" file="stdlib/genosl/mx_sign.inline" target="genosl" />
  <implementation name="IM_sign_color3_genosl" nodedef="ND_sign_color3" file="stdlib/genosl/mx_sign.inline" target="genosl" />
  <implementation name="IM_sign_color4_genosl" nodedef="ND_sign_color4" file="stdlib/genosl/mx_sign.inline" target="genosl" />
  <implementation name="IM_sign_vector2_genosl" nodedef="ND_sign_vector2" file="stdlib/genosl/mx_sign.inline" target="genosl" />
  <implementation name="IM_sign_vector3_genosl" nodedef="ND_sign_vector3" file="stdlib/genosl/mx_sign.inline" target="genosl" />
  <implementation name="IM_sign_vector4_genosl" nodedef="ND_sign_vector4" file="stdlib/genosl/mx_sign.inline" target="genosl" />

  <!-- <clamp> -->
  <implementation name="IM_clamp_float_genosl" nodedef="ND_clamp_float" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_color3_genosl" nodedef="ND_clamp_color3" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_color3FA_genosl" nodedef="ND_clamp_color3FA" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_color4_genosl" nodedef="ND_clamp_color4" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_color4FA_genosl" nodedef="ND_clamp_color4FA" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector2_genosl" nodedef="ND_clamp_vector2" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector2FA_genosl" nodedef="ND_clamp_vector2FA" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector3_genosl" nodedef="ND_clamp_vector3" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector3FA_genosl" nodedef="ND_clamp_vector3FA" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector4_genosl" nodedef="ND_clamp_vector4" file="stdlib/genosl/mx_clamp.inline" target="genosl" />
  <implementation name="IM_clamp_vector4FA_genosl" nodedef="ND_clamp_vector4FA" file="stdlib/genosl/mx_clamp.inline" target="genosl" />

  <!-- <min> -->
  <implementation name="IM_min_float_genosl" nodedef="ND_min_float" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_color3_genosl" nodedef="ND_min_color3" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_color3FA_genosl" nodedef="ND_min_color3FA" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_color4_genosl" nodedef="ND_min_color4" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_color4FA_genosl" nodedef="ND_min_color4FA" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector2_genosl" nodedef="ND_min_vector2" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector2FA_genosl" nodedef="ND_min_vector2FA" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector3_genosl" nodedef="ND_min_vector3" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector3FA_genosl" nodedef="ND_min_vector3FA" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector4_genosl" nodedef="ND_min_vector4" file="stdlib/genosl/mx_min.inline" target="genosl" />
  <implementation name="IM_min_vector4FA_genosl" nodedef="ND_min_vector4FA" file="stdlib/genosl/mx_min.inline" target="genosl" />

  <!-- <max> -->
  <implementation name="IM_max_float_genosl" nodedef="ND_max_float" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_color3_genosl" nodedef="ND_max_color3" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_color3FA_genosl" nodedef="ND_max_color3FA" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_color4_genosl" nodedef="ND_max_color4" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_color4FA_genosl" nodedef="ND_max_color4FA" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector2_genosl" nodedef="ND_max_vector2" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector2FA_genosl" nodedef="ND_max_vector2FA" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector3_genosl" nodedef="ND_max_vector3" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector3FA_genosl" nodedef="ND_max_vector3FA" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector4_genosl" nodedef="ND_max_vector4" file="stdlib/genosl/mx_max.inline" target="genosl" />
  <implementation name="IM_max_vector4FA_genosl" nodedef="ND_max_vector4FA" file="stdlib/genosl/mx_max.inline" target="genosl" />

  <!-- <normalize> -->
  <implementation name="IM_normalize_vector2_genosl" nodedef="ND_normalize_vector2" file="stdlib/genosl/mx_normalize.inline" target="genosl" />
  <implementation name="IM_normalize_vector3_genosl" nodedef="ND_normalize_vector3" file="stdlib/genosl/mx_normalize.inline" target="genosl" />
  <implementation name="IM_normalize_vector4_genosl" nodedef="ND_normalize_vector4" file="stdlib/genosl/mx_normalize.inline" target="genosl" />

  <!-- <magnitude> -->
  <implementation name="IM_magnitude_vector2_genosl" nodedef="ND_magnitude_vector2" file="stdlib/genosl/mx_magnitude.inline" target="genosl" />
  <implementation name="IM_magnitude_vector3_genosl" nodedef="ND_magnitude_vector3" file="stdlib/genosl/mx_magnitude.inline" target="genosl" />
  <implementation name="IM_magnitude_vector4_genosl" nodedef="ND_magnitude_vector4" file="stdlib/genosl/mx_magnitude.inline" target="genosl" />

  <!-- <dotproduct> -->
  <implementation name="IM_dotproduct_vector2_genosl" nodedef="ND_dotproduct_vector2" file="stdlib/genosl/mx_dotproduct.inline" target="genosl" />
  <implementation name="IM_dotproduct_vector3_genosl" nodedef="ND_dotproduct_vector3" file="stdlib/genosl/mx_dotproduct.inline" target="genosl" />
  <implementation name="IM_dotproduct_vector4_genosl" nodedef="ND_dotproduct_vector4" file="stdlib/genosl/mx_dotproduct.inline" target="genosl" />

  <!-- <crossproduct> -->
  <implementation name="IM_crossproduct_vector3_genosl" nodedef="ND_crossproduct_vector3" file="stdlib/genosl/mx_crossproduct.inline" target="genosl" />

  <!-- <transformpoint> -->
  <implementation name="IM_transformpoint_vector3_genosl" nodedef="ND_transformpoint_vector3" file="stdlib/genosl/mx_transformpoint.inline" target="genosl" />

  <!-- <transformvector> -->
  <implementation name="IM_transformvector_vector3_genosl" nodedef="ND_transformvector_vector3" file="stdlib/genosl/mx_transformvector.inline" target="genosl" />

  <!-- <transformnormal> -->
  <implementation name="IM_transformnormal_vector3_genosl" nodedef="ND_transformnormal_vector3" file="stdlib/genosl/mx_transformnormal.inline" target="genosl" />

  <!-- <transformmatrix> -->
  <implementation name="IM_transformmatrix_vector2M3_genosl" nodedef="ND_transformmatrix_vector2M3" function="mx_transformmatrix_vector2M3" file="stdlib/genosl/mx_transformmatrix_vector2M3.osl" target="genosl" />
  <implementation name="IM_transformmatrix_vector3_genosl" nodedef="ND_transformmatrix_vector3" file="stdlib/genosl/mx_transformmatrix.inline" target="genosl" />
  <implementation name="IM_transformmatrix_vector3M4_genosl" nodedef="ND_transformmatrix_vector3M4" file="stdlib/genosl/mx_transformmatrix.inline" target="genosl" />
  <implementation name="IM_transformmatrix_vector4_genosl" nodedef="ND_transformmatrix_vector4" file="stdlib/genosl/mx_transformmatrix.inline" target="genosl" />

  <!-- <transpose> -->
  <implementation name="IM_transpose_matrix33_genosl" nodedef="ND_transpose_matrix33" file="stdlib/genosl/mx_transpose.inline" target="genosl" />
  <implementation name="IM_transpose_matrix44_genosl" nodedef="ND_transpose_matrix44" file="stdlib/genosl/mx_transpose.inline" target="genosl" />

  <!-- <determinant> -->
  <implementation name="IM_determinant_matrix33_genosl" nodedef="ND_determinant_matrix33" file="stdlib/genosl/mx_determinant.inline" target="genosl" />
  <implementation name="IM_determinant_matrix44_genosl" nodedef="ND_determinant_matrix44" file="stdlib/genosl/mx_determinant.inline" target="genosl" />

  <!-- <invertmatrix> -->
  <implementation name="IM_invertmatrix_matrix33_genosl" nodedef="ND_invertmatrix_matrix33" file="stdlib/genosl/mx_invertM.inline" target="genosl" />
  <implementation name="IM_invertmatrix_matrix44_genosl" nodedef="ND_invertmatrix_matrix44" file="stdlib/genosl/mx_invertM.inline" target="genosl" />

  <!-- <rotate2d> -->
  <implementation name="IM_rotate2d_vector2_genosl" nodedef="ND_rotate2d_vector2" file="stdlib/genosl/mx_rotate_vector2.osl" function="mx_rotate_vector2" target="genosl" />

  <!-- <rotate3d> -->
  <implementation name="IM_rotate3d_vector3_genosl" nodedef="ND_rotate3d_vector3" file="stdlib/genosl/mx_rotate_vector3.osl" function="mx_rotate_vector3" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Adjustment nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <remap> -->
  <implementation name="IM_remap_float_genosl" nodedef="ND_remap_float" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_color3_genosl" nodedef="ND_remap_color3" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_color3FA_genosl" nodedef="ND_remap_color3FA" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_color4_genosl" nodedef="ND_remap_color4" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_color4FA_genosl" nodedef="ND_remap_color4FA" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector2_genosl" nodedef="ND_remap_vector2" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector2FA_genosl" nodedef="ND_remap_vector2FA" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector3_genosl" nodedef="ND_remap_vector3" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector3FA_genosl" nodedef="ND_remap_vector3FA" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector4_genosl" nodedef="ND_remap_vector4" file="stdlib/genosl/mx_remap.inline" target="genosl" />
  <implementation name="IM_remap_vector4FA_genosl" nodedef="ND_remap_vector4FA" file="stdlib/genosl/mx_remap.inline" target="genosl" />

  <!-- <smoothstep> -->
  <implementation name="IM_smoothstep_float_genosl" nodedef="ND_smoothstep_float" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_color3_genosl" nodedef="ND_smoothstep_color3" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_color3FA_genosl" nodedef="ND_smoothstep_color3FA" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_color4_genosl" nodedef="ND_smoothstep_color4" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_color4FA_genosl" nodedef="ND_smoothstep_color4FA" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector2_genosl" nodedef="ND_smoothstep_vector2" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector2FA_genosl" nodedef="ND_smoothstep_vector2FA" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector3_genosl" nodedef="ND_smoothstep_vector3" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector3FA_genosl" nodedef="ND_smoothstep_vector3FA" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector4_genosl" nodedef="ND_smoothstep_vector4" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />
  <implementation name="IM_smoothstep_vector4FA_genosl" nodedef="ND_smoothstep_vector4FA" file="stdlib/genosl/mx_smoothstep.inline" target="genosl" />

  <!-- <luminance> -->
  <implementation name="IM_luminance_color3_genosl" nodedef="ND_luminance_color3" file="stdlib/genosl/mx_luminance_color3.osl" function="mx_luminance_color3" target="genosl" />
  <implementation name="IM_luminance_color4_genosl" nodedef="ND_luminance_color4" file="stdlib/genosl/mx_luminance_color4.osl" function="mx_luminance_color4" target="genosl" />

  <!-- <rgbtohsv> -->
  <implementation name="IM_rgbtohsv_color3_genosl" nodedef="ND_rgbtohsv_color3" file="stdlib/genosl/mx_rgbtohsv_color3.osl" function="mx_rgbtohsv_color3" target="genosl" />
  <implementation name="IM_rgbtohsv_color4_genosl" nodedef="ND_rgbtohsv_color4" file="stdlib/genosl/mx_rgbtohsv_color4.osl" function="mx_rgbtohsv_color4" target="genosl" />

  <!-- <hsvtorgb> -->
  <implementation name="IM_hsvtorgb_color3_genosl" nodedef="ND_hsvtorgb_color3" file="stdlib/genosl/mx_hsvtorgb_color3.osl" function="mx_hsvtorgb_color3" target="genosl" />
  <implementation name="IM_hsvtorgb_color4_genosl" nodedef="ND_hsvtorgb_color4" file="stdlib/genosl/mx_hsvtorgb_color4.osl" function="mx_hsvtorgb_color4" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Compositing nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <premult> -->
  <implementation name="IM_premult_color4_genosl" nodedef="ND_premult_color4" file="stdlib/genosl/mx_premult_color4.osl" function="mx_premult_color4" target="genosl" />

  <!-- <unpremult> -->
  <implementation name="IM_unpremult_color4_genosl" nodedef="ND_unpremult_color4" file="stdlib/genosl/mx_unpremult_color4.osl" function="mx_unpremult_color4" target="genosl" />

  <!-- <plus> -->
  <implementation name="IM_plus_float_genosl" nodedef="ND_plus_float" file="stdlib/genosl/mx_plus.inline" target="genosl" />
  <implementation name="IM_plus_color3_genosl" nodedef="ND_plus_color3" file="stdlib/genosl/mx_plus.inline" target="genosl" />
  <implementation name="IM_plus_color4_genosl" nodedef="ND_plus_color4" file="stdlib/genosl/mx_plus.inline" target="genosl" />

  <!-- <minus> -->
  <implementation name="IM_minus_float_genosl" nodedef="ND_minus_float" file="stdlib/genosl/mx_minus.inline" target="genosl" />
  <implementation name="IM_minus_color3_genosl" nodedef="ND_minus_color3" file="stdlib/genosl/mx_minus.inline" target="genosl" />
  <implementation name="IM_minus_color4_genosl" nodedef="ND_minus_color4" file="stdlib/genosl/mx_minus.inline" target="genosl" />

  <!-- <difference> -->
  <implementation name="IM_difference_float_genosl" nodedef="ND_difference_float" file="stdlib/genosl/mx_difference.inline" target="genosl" />
  <implementation name="IM_difference_color3_genosl" nodedef="ND_difference_color3" file="stdlib/genosl/mx_difference.inline" target="genosl" />
  <implementation name="IM_difference_color4_genosl" nodedef="ND_difference_color4" file="stdlib/genosl/mx_difference.inline" target="genosl" />

  <!-- <burn> -->
  <implementation name="IM_burn_float_genosl" nodedef="ND_burn_float" file="stdlib/genosl/mx_burn_float.osl" function="mx_burn_float" target="genosl" />
  <implementation name="IM_burn_color3_genosl" nodedef="ND_burn_color3" file="stdlib/genosl/mx_burn_color3.osl" function="mx_burn_color3" target="genosl" />
  <implementation name="IM_burn_color4_genosl" nodedef="ND_burn_color4" file="stdlib/genosl/mx_burn_color4.osl" function="mx_burn_color4" target="genosl" />

  <!-- <dodge> -->
  <implementation name="IM_dodge_float_genosl" nodedef="ND_dodge_float" file="stdlib/genosl/mx_dodge_float.osl" function="mx_dodge_float" target="genosl" />
  <implementation name="IM_dodge_color3_genosl" nodedef="ND_dodge_color3" file="stdlib/genosl/mx_dodge_color3.osl" function="mx_dodge_color3" target="genosl" />
  <implementation name="IM_dodge_color4_genosl" nodedef="ND_dodge_color4" file="stdlib/genosl/mx_dodge_color4.osl" function="mx_dodge_color4" target="genosl" />

  <!-- <screen> -->
  <implementation name="IM_screen_float_genosl" nodedef="ND_screen_float" file="stdlib/genosl/mx_screen.inline" target="genosl" />
  <implementation name="IM_screen_color3_genosl" nodedef="ND_screen_color3" file="stdlib/genosl/mx_screen.inline" target="genosl" />
  <implementation name="IM_screen_color4_genosl" nodedef="ND_screen_color4" file="stdlib/genosl/mx_screen.inline" target="genosl" />

  <!-- <overlay> -->
  <implementation name="IM_overlay_float_genosl" nodedef="ND_overlay_float" file="stdlib/genosl/mx_overlay.inline" target="genosl" />
  <implementation name="IM_overlay_color3_genosl" nodedef="ND_overlay_color3" file="stdlib/genosl/mx_overlay_color3.osl" function="mx_overlay_color3" target="genosl" />
  <implementation name="IM_overlay_color4_genosl" nodedef="ND_overlay_color4" file="stdlib/genosl/mx_overlay_color4.osl" function="mx_overlay_color4" target="genosl" />

  <!-- <disjointover> -->
  <implementation name="IM_disjointover_color4_genosl" nodedef="ND_disjointover_color4" file="stdlib/genosl/mx_disjointover_color4.osl" function="mx_disjointover_color4" target="genosl" />

  <!-- <in> -->
  <implementation name="IM_in_color4_genosl" nodedef="ND_in_color4" file="stdlib/genosl/mx_in.inline" target="genosl" />

  <!-- <mask> -->
  <implementation name="IM_mask_color4_genosl" nodedef="ND_mask_color4" file="stdlib/genosl/mx_mask.inline" target="genosl" />

  <!-- <matte> -->
  <implementation name="IM_matte_color4_genosl" nodedef="ND_matte_color4" file="stdlib/genosl/mx_matte_color4.inline" target="genosl" />

  <!-- <out> -->
  <implementation name="IM_out_color4_genosl" nodedef="ND_out_color4" file="stdlib/genosl/mx_out.inline" target="genosl" />

  <!-- <over> -->
  <implementation name="IM_over_color4_genosl" nodedef="ND_over_color4" file="stdlib/genosl/mx_over.inline" target="genosl" />

  <!-- <inside> -->
  <implementation name="IM_inside_float_genosl" nodedef="ND_inside_float" file="stdlib/genosl/mx_inside.inline" target="genosl" />
  <implementation name="IM_inside_color3_genosl" nodedef="ND_inside_color3" file="stdlib/genosl/mx_inside.inline" target="genosl" />
  <implementation name="IM_inside_color4_genosl" nodedef="ND_inside_color4" file="stdlib/genosl/mx_inside.inline" target="genosl" />

  <!-- <outside> -->
  <implementation name="IM_outside_float_genosl" nodedef="ND_outside_float" file="stdlib/genosl/mx_outside.inline" target="genosl" />
  <implementation name="IM_outside_color3_genosl" nodedef="ND_outside_color3" file="stdlib/genosl/mx_outside.inline" target="genosl" />
  <implementation name="IM_outside_color4_genosl" nodedef="ND_outside_color4" file="stdlib/genosl/mx_outside.inline" target="genosl" />

  <!-- <mix> -->
  <implementation name="IM_mix_float_genosl" nodedef="ND_mix_float" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_color3_genosl" nodedef="ND_mix_color3" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_color4_genosl" nodedef="ND_mix_color4" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_vector2_genosl" nodedef="ND_mix_vector2" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_vector3_genosl" nodedef="ND_mix_vector3" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_vector4_genosl" nodedef="ND_mix_vector4" file="stdlib/genosl/mx_mix.inline" target="genosl" />
  <implementation name="IM_mix_surfaceshader_genosl" nodedef="ND_mix_surfaceshader" file="stdlib/genosl/mx_mix.inline" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Conditional nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <ifgreater> -->
  <implementation name="IM_ifgreater_float_genosl" nodedef="ND_ifgreater_float" target="genosl" />
  <implementation name="IM_ifgreater_color3_genosl" nodedef="ND_ifgreater_color3" target="genosl" />
  <implementation name="IM_ifgreater_color4_genosl" nodedef="ND_ifgreater_color4" target="genosl" />
  <implementation name="IM_ifgreater_vector2_genosl" nodedef="ND_ifgreater_vector2" target="genosl" />
  <implementation name="IM_ifgreater_vector3_genosl" nodedef="ND_ifgreater_vector3" target="genosl" />
  <implementation name="IM_ifgreater_vector4_genosl" nodedef="ND_ifgreater_vector4" target="genosl" />
  <implementation name="IM_ifgreater_floatI_genosl" nodedef="ND_ifgreater_floatI" target="genosl" />
  <implementation name="IM_ifgreater_color3I_genosl" nodedef="ND_ifgreater_color3I" target="genosl" />
  <implementation name="IM_ifgreater_color4I_genosl" nodedef="ND_ifgreater_color4I" target="genosl" />
  <implementation name="IM_ifgreater_vector2I_genosl" nodedef="ND_ifgreater_vector2I" target="genosl" />
  <implementation name="IM_ifgreater_vector3I_genosl" nodedef="ND_ifgreater_vector3I" target="genosl" />
  <implementation name="IM_ifgreater_vector4I_genosl" nodedef="ND_ifgreater_vector4I" target="genosl" />

  <!-- <ifgreatereq> -->
  <implementation name="IM_ifgreatereq_float_genosl" nodedef="ND_ifgreatereq_float" target="genosl" />
  <implementation name="IM_ifgreatereq_color3_genosl" nodedef="ND_ifgreatereq_color3" target="genosl" />
  <implementation name="IM_ifgreatereq_color4_genosl" nodedef="ND_ifgreatereq_color4" target="genosl" />
  <implementation name="IM_ifgreatereq_vector2_genosl" nodedef="ND_ifgreatereq_vector2" target="genosl" />
  <implementation name="IM_ifgreatereq_vector3_genosl" nodedef="ND_ifgreatereq_vector3" target="genosl" />
  <implementation name="IM_ifgreatereq_vector4_genosl" nodedef="ND_ifgreatereq_vector4" target="genosl" />
  <implementation name="IM_ifgreatereq_floatI_genosl" nodedef="ND_ifgreatereq_floatI" target="genosl" />
  <implementation name="IM_ifgreatereq_color3I_genosl" nodedef="ND_ifgreatereq_color3I" target="genosl" />
  <implementation name="IM_ifgreatereq_color4I_genosl" nodedef="ND_ifgreatereq_color4I" target="genosl" />
  <implementation name="IM_ifgreatereq_vector2I_genosl" nodedef="ND_ifgreatereq_vector2I" target="genosl" />
  <implementation name="IM_ifgreatereq_vector3I_genosl" nodedef="ND_ifgreatereq_vector3I" target="genosl" />
  <implementation name="IM_ifgreatereq_vector4I_genosl" nodedef="ND_ifgreatereq_vector4I" target="genosl" />

  <!-- <ifequal> -->
  <implementation name="IM_ifequal_float_genosl" nodedef="ND_ifequal_float" target="genosl" />
  <implementation name="IM_ifequal_color3_genosl" nodedef="ND_ifequal_color3" target="genosl" />
  <implementation name="IM_ifequal_color4_genosl" nodedef="ND_ifequal_color4" target="genosl" />
  <implementation name="IM_ifequal_vector2_genosl" nodedef="ND_ifequal_vector2" target="genosl" />
  <implementation name="IM_ifequal_vector3_genosl" nodedef="ND_ifequal_vector3" target="genosl" />
  <implementation name="IM_ifequal_vector4_genosl" nodedef="ND_ifequal_vector4" target="genosl" />
  <implementation name="IM_ifequal_floatI_genosl" nodedef="ND_ifequal_floatI" target="genosl" />
  <implementation name="IM_ifequal_color3I_genosl" nodedef="ND_ifequal_color3I" target="genosl" />
  <implementation name="IM_ifequal_color4I_genosl" nodedef="ND_ifequal_color4I" target="genosl" />
  <implementation name="IM_ifequal_vector2I_genosl" nodedef="ND_ifequal_vector2I" target="genosl" />
  <implementation name="IM_ifequal_vector3I_genosl" nodedef="ND_ifequal_vector3I" target="genosl" />
  <implementation name="IM_ifequal_vector4I_genosl" nodedef="ND_ifequal_vector4I" target="genosl" />
  <implementation name="IM_ifequal_floatB_genosl" nodedef="ND_ifequal_floatB" target="genosl" />
  <implementation name="IM_ifequal_color3B_genosl" nodedef="ND_ifequal_color3B" target="genosl" />
  <implementation name="IM_ifequal_color4B_genosl" nodedef="ND_ifequal_color4B" target="genosl" />
  <implementation name="IM_ifequal_vector2B_genosl" nodedef="ND_ifequal_vector2B" target="genosl" />
  <implementation name="IM_ifequal_vector3B_genosl" nodedef="ND_ifequal_vector3B" target="genosl" />
  <implementation name="IM_ifequal_vector4B_genosl" nodedef="ND_ifequal_vector4B" target="genosl" />

  <!-- <switch> -->
  <!-- 'which' type : float -->
  <implementation name="IM_switch_float_genosl" nodedef="ND_switch_float" target="genosl" />
  <implementation name="IM_switch_color3_genosl" nodedef="ND_switch_color3" target="genosl" />
  <implementation name="IM_switch_color4_genosl" nodedef="ND_switch_color4" target="genosl" />
  <implementation name="IM_switch_vector2_genosl" nodedef="ND_switch_vector2" target="genosl" />
  <implementation name="IM_switch_vector3_genosl" nodedef="ND_switch_vector3" target="genosl" />
  <implementation name="IM_switch_vector4_genosl" nodedef="ND_switch_vector4" target="genosl" />
  <!-- 'which' type : integer -->
  <implementation name="IM_switch_floatI_genosl" nodedef="ND_switch_floatI" target="genosl" />
  <implementation name="IM_switch_color3I_genosl" nodedef="ND_switch_color3I" target="genosl" />
  <implementation name="IM_switch_color4I_genosl" nodedef="ND_switch_color4I" target="genosl" />
  <implementation name="IM_switch_vector2I_genosl" nodedef="ND_switch_vector2I" target="genosl" />
  <implementation name="IM_switch_vector3I_genosl" nodedef="ND_switch_vector3I" target="genosl" />
  <implementation name="IM_switch_vector4I_genosl" nodedef="ND_switch_vector4I" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Channel nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <convert> -->
  <implementation name="IM_convert_float_color3_genosl" nodedef="ND_convert_float_color3" target="genosl" />
  <implementation name="IM_convert_float_color4_genosl" nodedef="ND_convert_float_color4" target="genosl" />
  <implementation name="IM_convert_float_vector2_genosl" nodedef="ND_convert_float_vector2" target="genosl" />
  <implementation name="IM_convert_float_vector3_genosl" nodedef="ND_convert_float_vector3" target="genosl" />
  <implementation name="IM_convert_float_vector4_genosl" nodedef="ND_convert_float_vector4" target="genosl" />
  <implementation name="IM_convert_vector2_vector3_genosl" nodedef="ND_convert_vector2_vector3" target="genosl" />
  <implementation name="IM_convert_vector3_vector2_genosl" nodedef="ND_convert_vector3_vector2" target="genosl" />
  <implementation name="IM_convert_vector3_color3_genosl" nodedef="ND_convert_vector3_color3" target="genosl" />
  <implementation name="IM_convert_vector3_vector4_genosl" nodedef="ND_convert_vector3_vector4" target="genosl" />
  <implementation name="IM_convert_vector4_vector3_genosl" nodedef="ND_convert_vector4_vector3" target="genosl" />
  <implementation name="IM_convert_vector4_color4_genosl" nodedef="ND_convert_vector4_color4" target="genosl" />
  <implementation name="IM_convert_color3_vector3_genosl" nodedef="ND_convert_color3_vector3" target="genosl" />
  <implementation name="IM_convert_color4_vector4_genosl" nodedef="ND_convert_color4_vector4" target="genosl" />
  <implementation name="IM_convert_color3_color4_genosl" nodedef="ND_convert_color3_color4" target="genosl" />
  <implementation name="IM_convert_color4_color3_genosl" nodedef="ND_convert_color4_color3" target="genosl" />
  <implementation name="IM_convert_boolean_float_genosl" nodedef="ND_convert_boolean_float" target="genosl" />
  <implementation name="IM_convert_integer_float_genosl" nodedef="ND_convert_integer_float" target="genosl" />

  <!-- <swizzle> -->
  <!-- from type: float -->
  <implementation name="IM_swizzle_float_color3_genosl" nodedef="ND_swizzle_float_color3" target="genosl" />
  <implementation name="IM_swizzle_float_color4_genosl" nodedef="ND_swizzle_float_color4" target="genosl" />
  <implementation name="IM_swizzle_float_vector2_genosl" nodedef="ND_swizzle_float_vector2" target="genosl" />
  <implementation name="IM_swizzle_float_vector3_genosl" nodedef="ND_swizzle_float_vector3" target="genosl" />
  <implementation name="IM_swizzle_float_vector4_genosl" nodedef="ND_swizzle_float_vector4" target="genosl" />
  <!-- from type: color3 -->
  <implementation name="IM_swizzle_color3_float_genosl" nodedef="ND_swizzle_color3_float" target="genosl" />
  <implementation name="IM_swizzle_color3_color3_genosl" nodedef="ND_swizzle_color3_color3" target="genosl" />
  <implementation name="IM_swizzle_color3_color4_genosl" nodedef="ND_swizzle_color3_color4" target="genosl" />
  <implementation name="IM_swizzle_color3_vector2_genosl" nodedef="ND_swizzle_color3_vector2" target="genosl" />
  <implementation name="IM_swizzle_color3_vector3_genosl" nodedef="ND_swizzle_color3_vector3" target="genosl" />
  <implementation name="IM_swizzle_color3_vector4_genosl" nodedef="ND_swizzle_color3_vector4" target="genosl" />
  <!-- from type: color4 -->
  <implementation name="IM_swizzle_color4_float_genosl" nodedef="ND_swizzle_color4_float" target="genosl" />
  <implementation name="IM_swizzle_color4_color3_genosl" nodedef="ND_swizzle_color4_color3" target="genosl" />
  <implementation name="IM_swizzle_color4_color4_genosl" nodedef="ND_swizzle_color4_color4" target="genosl" />
  <implementation name="IM_swizzle_color4_vector2_genosl" nodedef="ND_swizzle_color4_vector2" target="genosl" />
  <implementation name="IM_swizzle_color4_vector3_genosl" nodedef="ND_swizzle_color4_vector3" target="genosl" />
  <implementation name="IM_swizzle_color4_vector4_genosl" nodedef="ND_swizzle_color4_vector4" target="genosl" />
  <!-- from type: vector2 -->
  <implementation name="IM_swizzle_vector2_float_genosl" nodedef="ND_swizzle_vector2_float" target="genosl" />
  <implementation name="IM_swizzle_vector2_color3_genosl" nodedef="ND_swizzle_vector2_color3" target="genosl" />
  <implementation name="IM_swizzle_vector2_color4_genosl" nodedef="ND_swizzle_vector2_color4" target="genosl" />
  <implementation name="IM_swizzle_vector2_vector2_genosl" nodedef="ND_swizzle_vector2_vector2" target="genosl" />
  <implementation name="IM_swizzle_vector2_vector3_genosl" nodedef="ND_swizzle_vector2_vector3" target="genosl" />
  <implementation name="IM_swizzle_vector2_vector4_genosl" nodedef="ND_swizzle_vector2_vector4" target="genosl" />
  <!-- from type: vector3 -->
  <implementation name="IM_swizzle_vector3_float_genosl" nodedef="ND_swizzle_vector3_float" target="genosl" />
  <implementation name="IM_swizzle_vector3_color3_genosl" nodedef="ND_swizzle_vector3_color3" target="genosl" />
  <implementation name="IM_swizzle_vector3_color4_genosl" nodedef="ND_swizzle_vector3_color4" target="genosl" />
  <implementation name="IM_swizzle_vector3_vector2_genosl" nodedef="ND_swizzle_vector3_vector2" target="genosl" />
  <implementation name="IM_swizzle_vector3_vector3_genosl" nodedef="ND_swizzle_vector3_vector3" target="genosl" />
  <implementation name="IM_swizzle_vector3_vector4_genosl" nodedef="ND_swizzle_vector3_vector4" target="genosl" />
  <!-- from type: vector4 -->
  <implementation name="IM_swizzle_vector4_float_genosl" nodedef="ND_swizzle_vector4_float" target="genosl" />
  <implementation name="IM_swizzle_vector4_color3_genosl" nodedef="ND_swizzle_vector4_color3" target="genosl" />
  <implementation name="IM_swizzle_vector4_color4_genosl" nodedef="ND_swizzle_vector4_color4" target="genosl" />
  <implementation name="IM_swizzle_vector4_vector2_genosl" nodedef="ND_swizzle_vector4_vector2" target="genosl" />
  <implementation name="IM_swizzle_vector4_vector3_genosl" nodedef="ND_swizzle_vector4_vector3" target="genosl" />
  <implementation name="IM_swizzle_vector4_vector4_genosl" nodedef="ND_swizzle_vector4_vector4" target="genosl" />

  <!-- <combine2> -->
  <implementation name="IM_combine2_vector2_genosl" nodedef="ND_combine2_vector2" target="genosl" />
  <implementation name="IM_combine2_color4CF_genosl" nodedef="ND_combine2_color4CF" target="genosl" />
  <implementation name="IM_combine2_vector4VF_genosl" nodedef="ND_combine2_vector4VF" target="genosl" />
  <implementation name="IM_combine2_vector4VV_genosl" nodedef="ND_combine2_vector4VV" target="genosl" />

  <!-- <combine3> -->
  <implementation name="IM_combine3_color3_genosl" nodedef="ND_combine3_color3" target="genosl" />
  <implementation name="IM_combine3_vector3_genosl" nodedef="ND_combine3_vector3" target="genosl" />

  <!-- <combine4> -->
  <implementation name="IM_combine4_color4_genosl" nodedef="ND_combine4_color4" target="genosl" />
  <implementation name="IM_combine4_vector4_genosl" nodedef="ND_combine4_vector4" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Convolution nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <blur> -->
  <implementation name="IM_blur_float_genosl" nodedef="ND_blur_float" target="genosl" />
  <implementation name="IM_blur_color3_genosl" nodedef="ND_blur_color3" target="genosl" />
  <implementation name="IM_blur_color4_genosl" nodedef="ND_blur_color4" target="genosl" />
  <implementation name="IM_blur_vector2_genosl" nodedef="ND_blur_vector2" target="genosl" />
  <implementation name="IM_blur_vector3_genosl" nodedef="ND_blur_vector3" target="genosl" />
  <implementation name="IM_blur_vector4_genosl" nodedef="ND_blur_vector4" target="genosl" />

  <!-- <heighttonormal> -->
  <implementation name="IM_heighttonormal_vector3_genosl" nodedef="ND_heighttonormal_vector3" file="stdlib/genosl/mx_heighttonormal_vector3.osl" function="mx_heighttonormal_vector3" target="genosl" />

  <!-- ======================================================================== -->
  <!-- Organization nodes                                                       -->
  <!-- ======================================================================== -->

  <!-- <dot> -->
  <implementation name="IM_dot_float_genosl" nodedef="ND_dot_float" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_color3_genosl" nodedef="ND_dot_color3" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_color4_genosl" nodedef="ND_dot_color4" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_vector2_genosl" nodedef="ND_dot_vector2" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_vector3_genosl" nodedef="ND_dot_vector3" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_vector4_genosl" nodedef="ND_dot_vector4" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_boolean_genosl" nodedef="ND_dot_boolean" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_integer_genosl" nodedef="ND_dot_integer" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_matrix33_genosl" nodedef="ND_dot_matrix33" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_matrix44_genosl" nodedef="ND_dot_matrix44" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_string_genosl" nodedef="ND_dot_string" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_filename_genosl" nodedef="ND_dot_filename" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_surfaceshader_genosl" nodedef="ND_dot_surfaceshader" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_displacementshader_genosl" nodedef="ND_dot_displacementshader" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_volumeshader_genosl" nodedef="ND_dot_volumeshader" file="stdlib/genosl/mx_dot.inline" target="genosl" />
  <implementation name="IM_dot_lightshader_genosl" nodedef="ND_dot_lightshader" file="stdlib/genosl/mx_dot.inline" target="genosl" />

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Color Management System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_g18_rec709_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_gamma18_to_linear_color3.osl" function="mx_gamma18_to_linear_color3" target="genosl" />
  <implementation name="IM_g18_rec709_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_gamma18_to_linear_color4.osl" function="mx_gamma18_to_linear_color4" target="genosl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_gamma22_to_linear_color3.osl" function="mx_gamma22_to_linear_color3" target="genosl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_gamma22_to_linear_color4.osl" function="mx_gamma22_to_linear_color4" target="genosl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_gamma24_to_linear_color3.osl" function="mx_gamma24_to_linear_color3" target="genosl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_gamma24_to_linear_color4.osl" function="mx_gamma24_to_linear_color4" target="genosl" />

  <implementation name="IM_acescg_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_ap1_to_rec709_color3.osl" function="mx_ap1_to_rec709_color3" target="genosl" />
  <implementation name="IM_acescg_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_ap1_to_rec709_color4.osl" function="mx_ap1_to_rec709_color4" target="genosl" />

  <implementation name="IM_g22_ap1_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_g22_ap1_to_lin_rec709_color3.osl" function="mx_g22_ap1_to_lin_rec709_color3" target="genosl" />
  <implementation name="IM_g22_ap1_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_g22_ap1_to_lin_rec709_color4.osl" function="mx_g22_ap1_to_lin_rec709_color4" target="genosl" />

  <implementation name="IM_srgb_texture_to_lin_rec709_color3_genosl" file="stdlib/genosl/mx_srgb_texture_to_lin_rec709_color3.osl" function="mx_srgb_texture_to_lin_rec709_color3" target="genosl" />
  <implementation name="IM_srgb_texture_to_lin_rec709_color4_genosl" file="stdlib/genosl/mx_srgb_texture_to_lin_rec709_color4.osl" function="mx_srgb_texture_to_lin_rec709_color4" target="genosl" />

</materialx>
#include "$fileTransformUv"

void mx_image_color3(textureresource file, string layer, color default_value, vector2 texcoord, string uaddressmode, string vaddressmode, string filtertype, string framerange, int frameoffset, string frameendaction, output color out)
{
    if (file.filename == "" ||
        (uaddressmode == "constant" && (texcoord.x<0.0 || texcoord.x>1.0)) ||
        (vaddressmode == "constant" && (texcoord.y<0.0 || texcoord.y>1.0)))
    {
        out = default_value;
        return;
    }

    color missingColor = default_value;
    vector2 st = mx_transform_uv(texcoord);
    out = texture(file.filename, st.x, st.y, "subimage", layer, "missingcolor", missingColor, "swrap", uaddressmode, "twrap", vaddressmode $extraTextureLookupArguments);
}

void mx_worleynoise2d_vector2(vector2 texcoord, float jitter, output vector2 result)
{
    result = mx_worley_noise_vector2(texcoord, jitter, 0);
}
vector2(u,v)
void mx_noise2d_color3(vector amplitude, float pivot, vector2 texcoord, output color result)
{
    color value = noise("snoise", texcoord.x, texcoord.y);
    result = value * amplitude + pivot;
}
void mx_heighttonormal_vector3(float in, float scale, output vector result)
{
    point htP = P + normalize(N) * in * scale;
    result = normalize(calculatenormal(htP));
}
void mx_premult_color4(color4 in, output color4 result)
{
    result = color4(in.rgb * in.a, in.a);
}
// Open Shading Language : Copyright (c) 2009-2017 Sony Pictures Imageworks Inc., et al.
// https://github.com/imageworks/OpenShadingLanguage/blob/master/LICENSE
//
// MaterialX specification (c) 2017 Lucasfilm Ltd.
// http://www.materialx.org/

#pragma once
#include "color4.h"
#include "vector2.h"
#include "vector4.h"
#include "matrix33.h"


///////////////////////////////////////////////////////////////////////////
// This file contains lots of functions helpful in the implementation of
// the MaterialX nodes.
///////////////////////////////////////////////////////////////////////////


// Define mx_convert_type
//   float -> colvecN
color mx_convert (float a) { return color(a); }
color4 mx_convert (float a) { return color4(a,a); }
vector mx_convert (float a) { return vector(a); }
vector2 mx_convert (float a) { return vector2(a,a); }
vector4 mx_convert (float a) { return vector4(a,a,a,a); }
//   colN <-> vecN
vector mx_convert (color a) { return (vector)a; }
vector4 mx_convert (color4 a) { return vector4 (a.rgb[0], a.rgb[1], a.rgb[2], a.a); }
color mx_convert (vector a) { return (color)a; }
color4 mx_convert (vector4 a) { return color4 (color(a.x,a.y,a.z), a.w); }
//   col3 <-> col4
color mx_convert (color4 a) { return a.rgb; }
color4 mx_convert (color a) { return color4(a,1.0); }

// Define mx_add() overloaded for all MX types.
float mx_add (float a, float b) { return a+b; }
point mx_add (point a, point b) { return a+b; }
point mx_add (point a, float b) { return a+b; }
vector mx_add (vector a, vector b) { return a+b; }
vector mx_add (vector a, float b) { return a+b; }
vector2 mx_add (vector2 a, vector2 b) { return a+b; }
vector2 mx_add (vector2 a, float b) { return a+b; }
vector4 mx_add (vector4 a, vector4 b) { return a+b; }
vector4 mx_add (vector4 a, float b) { return a+b; }
color mx_add (color a, color b) { return a+b; }
color mx_add (color a, float b) { return a+b; }
color4 mx_add (color4 a, color4 b) { return a+b; }
color4 mx_add (color4 a, float b) { return a+b; }
closure color mx_add (closure color a, closure color b) { return a+b; }

matrix33 mx_add(matrix33 a, matrix33 b)
{
    return matrix33 (matrix(
        a.m[0][0]+b.m[0][0], a.m[0][1]+b.m[0][1], a.m[0][2]+b.m[0][2], 0.0,
        a.m[1][0]+b.m[1][0], a.m[1][1]+b.m[1][1], a.m[1][2]+b.m[1][2], 0.0,
        a.m[2][0]+b.m[2][0], a.m[2][1]+b.m[2][1], a.m[2][2]+b.m[2][2], 0.0,
        0.0, 0.0, 0.0, 1.0));
}

matrix33 mx_add(matrix33 a, float b)
{
    return matrix33 (matrix(a.m[0][0]+b, a.m[0][1]+b, a.m[0][2]+b, 0.0,
                            a.m[1][0]+b, a.m[1][1]+b, a.m[1][2]+b, 0.0,
                            a.m[2][0]+b, a.m[2][1]+b, a.m[2][2]+b, 0.0,
                            0.0, 0.0, 0.0, 1.0));
}

matrix mx_add(matrix a, matrix b)
{
    return matrix (a[0][0]+b[0][0], a[0][1]+b[0][1], a[0][2]+b[0][2], a[0][3]+b[0][3],
                   a[1][0]+b[1][0], a[1][1]+b[1][1], a[1][2]+b[1][2], a[1][3]+b[1][3],
                   a[2][0]+b[2][0], a[2][1]+b[2][1], a[2][2]+b[2][2], a[2][3]+b[2][3],
                   a[3][0]+b[3][0], a[3][1]+b[3][1], a[3][2]+b[3][2], a[3][3]+b[3][3]);
}

matrix mx_add(matrix a, float b)
{
    return matrix (a[0][0]+b, a[0][1]+b, a[0][2]+b, a[0][3]+b,
                   a[1][0]+b, a[1][1]+b, a[1][2]+b, a[1][3]+b,
                   a[2][0]+b, a[2][1]+b, a[2][2]+b, a[2][3]+b,
                   a[3][0]+b, a[3][1]+b, a[3][2]+b, a[3][3]+b);
}


// Define mx_sub() overloaded for all MX types.
float mx_sub (float a, float b) { return a-b; }
point mx_sub (point a, point b) { return a-b; }
point mx_sub (point a, float b) { return a-b; }
vector mx_sub (vector a, vector b) { return a-b; }
vector mx_sub (vector a, float b) { return a-b; }
vector2 mx_sub (vector2 a, vector2 b) { return a-b; }
vector2 mx_sub (vector2 a, float b) { return a-b; }
vector4 mx_sub (vector4 a, vector4 b) { return a-b; }
vector4 mx_sub (vector4 a, float b) { return a-b; }
color mx_sub (color a, color b) { return a-b; }
color mx_sub (color a, float b) { return a-b; }
color4 mx_sub (color4 a, color4 b) { return a-b; }
color4 mx_sub (color4 a, float b) { return a-b; }

matrix33 mx_sub (matrix33 a, matrix33 b)
{
    return matrix33 (matrix(
        a.m[0][0]-b.m[0][0], a.m[0][1]-b.m[0][1], a.m[0][2]-b.m[0][2], 0.0,
        a.m[1][0]-b.m[1][0], a.m[1][1]-b.m[1][1], a.m[1][2]-b.m[1][2], 0.0,
        a.m[2][0]-b.m[2][0], a.m[2][1]-b.m[2][1], a.m[2][2]-b.m[2][2], 0.0,
        0.0, 0.0, 0.0, 1.0));
}

matrix33 mx_sub (matrix33 a, float b)
{
    return matrix33 (matrix(
        a.m[0][0]-b, a.m[0][1]-b, a.m[0][2]-b, 0.0,
        a.m[1][0]-b, a.m[1][1]-b, a.m[1][2]-b, 0.0,
        a.m[2][0]-b, a.m[2][1]-b, a.m[2][2]-b, 0.0,
        0.0, 0.0, 0.0, 1.0));
}

matrix mx_sub (matrix a, matrix b)
{
    return matrix(a[0][0]-b[0][0], a[0][1]-b[0][1], a[0][2]-b[0][2], a[0][3]-b[0][3],
                  a[1][0]-b[1][0], a[1][1]-b[1][1], a[1][2]-b[1][2], a[1][3]-b[1][3],
                  a[2][0]-b[2][0], a[2][1]-b[2][1], a[2][2]-b[2][2], a[2][3]-b[2][3],
                  a[3][0]-b[3][0], a[3][1]-b[3][1], a[3][2]-b[3][2], a[3][3]-b[3][3]);
}

matrix mx_sub (matrix a, float b)
{
    return matrix (a[0][0]-b, a[0][1]-b, a[0][2]-b, a[0][3]-b,
                   a[1][0]-b, a[1][1]-b, a[1][2]-b, a[1][3]-b,
                   a[2][0]-b, a[2][1]-b, a[2][2]-b, a[2][3]-b,
                   a[3][0]-b, a[3][1]-b, a[3][2]-b, a[3][3]-b);
}



// remap `in` from [inLow, inHigh] to [outLow, outHigh], optionally clamping
// to the new range.
//
float remap(float in, float inLow, float inHigh, float outLow, float outHigh, int doClamp)
{
      float x = (in - inLow)/(inHigh-inLow);
      if (doClamp == 1) {
           x = clamp(x, 0, 1);
      }
      return outLow + (outHigh - outLow) * x;
}

color remap(color in, color inLow, color inHigh, color outLow, color outHigh, int doClamp)
{
      color x = (in - inLow) / (inHigh - inLow);
      if (doClamp == 1) {
           x = clamp(x, 0, 1);
      }
      return outLow + (outHigh - outLow) * x;
}

color remap(color in, float inLow, float inHigh, float outLow, float outHigh, int doClamp)
{
      color x = (in - inLow) / (inHigh - inLow);
      if (doClamp == 1) {
           x = clamp(x, 0, 1);
      }
      return outLow + (outHigh - outLow) * x;
}

color4 remap(color4 c, color4 inLow, color4 inHigh, color4 outLow, color4 outHigh, int doClamp)
{
      return color4(remap(c.rgb, inLow.rgb, inHigh.rgb, outLow.rgb, outHigh.rgb, doClamp),
                    remap(c.a, inLow.a, inHigh.a, outLow.a, outHigh.a, doClamp));
}

color4 remap(color4 c, float inLow, float inHigh, float outLow, float outHigh, int doClamp)
{
    color4 c4_inLow = color4(color(inLow), inLow);
    color4 c4_inHigh = color4(color(inHigh), inHigh);
    color4 c4_outLow = color4(color(outLow), outLow);
    color4 c4_outHigh = color4(color(outHigh), outHigh);
    return remap(c, c4_inLow, c4_inHigh, c4_outLow, c4_outHigh, doClamp);
}

vector2 remap(vector2 in, vector2 inLow, vector2 inHigh, vector2 outLow, vector2 outHigh, int doClamp)
{
    return vector2 (remap(in.x, inLow.x, inHigh.x, outLow.x, outHigh.x, doClamp),
                    remap(in.y, inLow.y, inHigh.y, outLow.y, outHigh.y, doClamp));
}

vector2 remap(vector2 in, float inLow, float inHigh, float outLow, float outHigh, int doClamp)
{
    return vector2 (remap(in.x, inLow, inHigh, outLow, outHigh, doClamp),
                    remap(in.y, inLow, inHigh, outLow, outHigh, doClamp));
}

vector4 remap(vector4 in, vector4 inLow, vector4 inHigh, vector4 outLow, vector4 outHigh, int doClamp)
{
    return vector4 (remap(in.x, inLow.x, inHigh.x, outLow.x, outHigh.x, doClamp),
                    remap(in.y, inLow.y, inHigh.y, outLow.y, outHigh.y, doClamp),
                    remap(in.z, inLow.z, inHigh.z, outLow.z, outHigh.z, doClamp),
                    remap(in.w, inLow.w, inHigh.w, outLow.w, outHigh.w, doClamp));
}

vector4 remap(vector4 in, float inLow, float inHigh, float outLow, float outHigh, int doClamp)
{
    return vector4 (remap(in.x, inLow, inHigh, outLow, outHigh, doClamp),
                    remap(in.y, inLow, inHigh, outLow, outHigh, doClamp),
                    remap(in.z, inLow, inHigh, outLow, outHigh, doClamp),
                    remap(in.w, inLow, inHigh, outLow, outHigh, doClamp));
}



float fgamma(float in, float g)
{
    return sign(in) * pow(abs(in), g);
}

color fgamma(color in, color g)
{
    return sign(in) * pow(abs(in), g);
}

color fgamma(color in, float g)
{
    return sign(in) * pow(abs(in), g);
}

color4 fgamma(color4 a, color4 b)
{
    return color4(fgamma(a.rgb, b.rgb), fgamma(a.a, b.a));
}

color4 fgamma(color4 a, float b)
{
    return fgamma(a, color4(color(b), b));
}

vector2 fgamma(vector2 in, vector2 g)
{
    return vector2 (fgamma(in.x, g.x), fgamma(in.y, g.y));
}

vector2 fgamma(vector2 in, float g)
{
    return vector2 (fgamma(in.x, g), fgamma(in.y, g));
}

vector4 fgamma(vector4 in, vector4 g)
{
    return vector4 (fgamma(in.x, g.x),
                    fgamma(in.y, g.y),
                    fgamma(in.z, g.z),
                    fgamma(in.w, g.w));
}

vector4 fgamma(vector4 in, float g)
{
    return vector4 (fgamma(in.x, g),
                    fgamma(in.y, g),
                    fgamma(in.z, g),
                    fgamma(in.w, g));
}



//
// contrast scales the input around a central `pivot` value.
//
float contrast(float in, float amount, float pivot)
{
    float out = in - pivot;
    out *= amount;
    out += pivot;
    return out;
}

color contrast(color in, color amount, color pivot)
{
    color out = in - pivot;
    out *= amount;
    out += pivot;
    return out;
}

color contrast(color in, float amount, float pivot)
{
    color out = in - pivot;
    out *= amount;
    out += pivot;
    return out;
}

color4 contrast(color4 c, color4 amount, color4 pivot)
{
    return color4(contrast(c.rgb, amount.rgb, pivot.rgb),
                  contrast(c.a, amount.a, pivot.a));
}

color4 contrast(color4 c, float amount, float pivot)
{
    return contrast(c, color4(color(amount), amount), color4(color(pivot), pivot));
}

vector2 contrast(vector2 in, vector2 amount, vector2 pivot)
{
    return vector2 (contrast(in.x, amount.x, pivot.x),
                    contrast(in.y, amount.y, pivot.y));
}

vector2 contrast(vector2 in, float amount, float pivot)
{
    return contrast(in, vector2(amount, amount), vector2(pivot, pivot));
}

vector4 contrast(vector4 in, vector4 amount, vector4 pivot)
{
    return vector4 (contrast(in.x, amount.x, pivot.x),
                    contrast(in.y, amount.y, pivot.y),
                    contrast(in.z, amount.z, pivot.z),
                    contrast(in.w, amount.w, pivot.w));
}

vector4 contrast(vector4 in, float amount, float pivot)
{
    return vector4 (contrast(in.x, amount, pivot),
                    contrast(in.y, amount, pivot),
                    contrast(in.z, amount, pivot),
                    contrast(in.w, amount, pivot));
}



vector2 noise (string noisetype, float x, float y)
{
    color cnoise = (color) noise (noisetype, x, y);
    return vector2 (cnoise[0], cnoise[1]);
}

color4 noise (string noisetype, float x, float y)
{
    color cnoise = (color) noise (noisetype, x, y);
    float fnoise = (float) noise (noisetype, x + 19, y + 73);
    return color4 (cnoise, fnoise);
}

vector4 noise (string noisetype, float x, float y)
{
    color cnoise = (color) noise (noisetype, x, y);
    float fnoise = (float) noise (noisetype, x + 19, y + 73);
    return vector4 (cnoise[0], cnoise[1], cnoise[2], fnoise);
}


vector2 noise (string noisetype, point position)
{
    color cnoise = (color) noise (noisetype, position);
    return vector2 (cnoise[0], cnoise[1]);
}

color4 noise (string noisetype, point position)
{
    color cnoise = (color) noise (noisetype, position);
    float fnoise = (float) noise (noisetype, position+vector(19,73,29));
    return color4 (cnoise, fnoise);
}

vector4 noise (string noisetype, point position)
{
    color cnoise = (color) noise (noisetype, position);
    float fnoise = (float) noise (noisetype, position+vector(19,73,29));
    return vector4 (cnoise[0], cnoise[1], cnoise[2], fnoise);
}



vector2 cellnoise (float x, float y)
{
    color cnoise = (color) cellnoise (x, y);
    return vector2 (cnoise[0], cnoise[1]);
}

color4 cellnoise (float x, float y)
{
    color cnoise = (color) cellnoise (x, y);
    float fnoise = (float) cellnoise (x + 19, y + 73);
    return color4 (cnoise, fnoise);
}

vector4 cellnoise (float x, float y)
{
    color cnoise = (color) cellnoise (x, y);
    float fnoise = (float) cellnoise (x + 19, y + 73);
    return vector4 (cnoise[0], cnoise[1], cnoise[2], fnoise);
}



vector2 cellnoise (point position)
{
    color cnoise = (color) cellnoise (position);
    return vector2 (cnoise[0], cnoise[1]);
}

color4 cellnoise (point position)
{
    color cnoise = (color) cellnoise (position);
    float fnoise = (float) cellnoise (position+vector(19,73,29));
    return color4 (cnoise, fnoise);
}

vector4 cellnoise (point position)
{
    color cnoise = (color) cellnoise (position);
    float fnoise = (float) cellnoise (position+vector(19,73,29));
    return vector4 (cnoise[0], cnoise[1], cnoise[2], fnoise);
}



//
// fractional Brownian motion
//
float fBm( point position, int octaves, float lacunarity, float diminish, string noisetype)
{
    float out = 0;
    float amp = 1.0;
    point p = position;

    for (int i = 0;  i < octaves;  i += 1) {
        out += amp * noise(noisetype, p);
        amp *= diminish;
        p *= lacunarity;
    }
    return out;
}

color fBm( point position, int octaves, float lacunarity, float diminish, string noisetype)
{
    color out = 0;
    float amp = 1.0;
    point p = position;

    for (int i = 0;  i < octaves;  i += 1) {
        out += amp * (color)noise(noisetype, p);
        amp *= diminish;
        p *= lacunarity;
    }
    return out;
}

vector2 fBm( point position, int octaves, float lacunarity, float diminish, string noisetype)
{
    return vector2 ((float) fBm (position, octaves, lacunarity, diminish, noisetype),
                    (float) fBm (position+point(19, 193, 17), octaves, lacunarity, diminish, noisetype));
}

color4 fBm( point position, int octaves, float lacunarity, float diminish, string noisetype)
{
    color c = (color) fBm (position, octaves, lacunarity, diminish, noisetype);
    float f = (float) fBm (position+point(19, 193, 17), octaves, lacunarity, diminish, noisetype);
    return color4 (c, f);
}

vector4 fBm( point position, int octaves, float lacunarity, float diminish, string noisetype)
{
    color c = (color) fBm (position, octaves, lacunarity, diminish, noisetype);
    float f = (float) fBm (position+point(19, 193, 17), octaves, lacunarity, diminish, noisetype);
    return vector4 (c[0], c[1], c[2], f);
}


void mx_split_float(output float x, output int ix)
{
    ix = int(floor(x));
    x -= ix;
}

float mx_worley_distance(vector2 p, int x, int y, int X, int Y, float jitter, int metric)
{
    vector o = cellnoise(x+X, y+Y);
    o = (o - .5)*jitter + .5;
    float cposx = x + o.x;
    float cposy = y + o.y;
    float diffx = cposx - p.x;
    float diffy = cposy - p.y;

    if (metric == 2)
        return abs(diffx) + abs(diffy);     // Manhattan distance
    if (metric == 3)
        return max(abs(diffx), abs(diffy)); // Chebyshev distance
    return diffx*diffx + diffy*diffy;       // Euclidean or distance^2
}

float mx_worley_distance(vector p, int x, int y, int z, int X, int Y, int Z, float jitter, int metric)
{
    vector o = cellnoise(vector(x+X, y+Y, z+Z));
    o = (o - .5)*jitter + .5;
    vector cpos = vector(x, y, z) + o;
    vector diff = cpos - p;

    if (metric == 2)
        return abs(diff.x) + abs(diff.y);     // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y)); // Chebyshev distance
    return dot(diff, diff);                   // Eucldean or distance^2
}

void mx_sort_distance(float dist, output vector2 result)
{
    if (dist < result.x)
    {
        result.y = result.x;
        result.x = dist;
    }
    else if (dist < result.y)
    {
        result.y = dist;
    }
}

void mx_sort_distance(float dist, output vector result)
{
    if (dist < result.x)
    {
        result.z = result.y;
        result.y = result.x;
        result.x = dist;
    }
    else if (dist < result.y)
    {
        result.z = result.y;
        result.y = dist;
    }
    else if (dist < result.z)
    {
        result.z = dist;
    }
}

float mx_worley_noise_float(vector2 p, float jitter, int metric)
{
    int X, Y;
    vector2 seed = p;
    float result = 1e6;

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float d = mx_worley_distance(seed, x, y, X, Y, jitter, metric);
            result = min(result, d);
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}

vector2 mx_worley_noise_vector2(vector2 p, float jitter, int metric)
{
    int X, Y;
    vector2 seed = p;
    vector2 result = vector2(1e6, 1e6);

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float d = mx_worley_distance(seed, x, y, X, Y, jitter, metric);
            mx_sort_distance(d, result);
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}

vector mx_worley_noise_vector3(vector2 p, float jitter, int metric)
{
    int X, Y;
    vector2 seed = p;
    vector result = vector(1e6, 1e6, 1e6);

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float d = mx_worley_distance(seed, x, y, X, Y, jitter, metric);
            mx_sort_distance(d, result);
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}

float mx_worley_noise_float(vector p, float jitter, int metric)
{
    int X, Y, Z;
    vector seed = p;
    float result = 1e6;

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    mx_split_float(seed.z, Z);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float d = mx_worley_distance(seed, x, y, z, X, Y, Z, jitter, metric);
                result = min(result, d);
            }
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}

vector2 mx_worley_noise_vector2(vector p, float jitter, int metric)
{
    int X, Y, Z;
    vector seed = p;
    vector2 result = vector2(1e6, 1e6);

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    mx_split_float(seed.z, Z);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float d = mx_worley_distance(seed, x, y, z, X, Y, Z, jitter, metric);
                mx_sort_distance(d, result);
            }
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}

vector mx_worley_noise_vector3(vector p, float jitter, int metric)
{
    int X, Y, Z;
    vector result = 1e6;
    vector seed = p;

    mx_split_float(seed.x, X);
    mx_split_float(seed.y, Y);
    mx_split_float(seed.z, Z);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float d = mx_worley_distance(seed, x, y, z, X, Y, Z, jitter, metric);
                mx_sort_distance(d, result);
            }
        }
    }
    if (metric == 0)
        result = sqrt(result);
    return result;
}


float swizzle_float (float in[4], string channels)
{
    float out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    out = outF[0];
    return out;
}



color swizzle_color (float in[4], string channels)
{
    color out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    return color(outF[0],outF[1],outF[2]);
}



vector swizzle_vector (float in[4], string channels)
{
    vector out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    return vector(outF[0],outF[1],outF[2]);
}



color4 swizzle_color4 (float in[4], string channels)
{
    color4  out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    out.rgb = color(outF[0],outF[1],outF[2]);
    out.a = outF[3];

    return out;
}


vector2 swizzle_vector2 (float in[4], string channels)
{
    vector2  out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    out.x = outF[0];
    out.y = outF[1];

    return out;
}



vector4 swizzle_vector4 (float in[4], string channels)
{
    vector4  out;
    float outF[4];
    int c_len = strlen(channels);

    for (int i=0; i<c_len; i++) {
        string ch = substr(channels, i, 1);
        if (ch == "r" || ch == "x")
            outF[i] = in[0];
        else if (ch == "g" || ch == "y")
            outF[i] = in[1];
        else if (ch == "b" || ch == "z")
            outF[i] = in[2];
        else if (ch == "a" || ch == "w")
            outF[i] = in[3];
        else if(ch == "1")
            outF[i] = 1;
        else
            outF[i] = 0;
    }
    out.x = outF[0];
    out.y = outF[1];
    out.z = outF[2];
    out.w = outF[3];
    return out;
}


//
// setup_missing_color_alpha() implements all the type permutations for
// setting up missingColor and missingAlpha given the default_value (and its
// specific type).
//

void setup_missing_color_alpha (float default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = default_value;
    missingAlpha = 1;
}

void setup_missing_color_alpha (color default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = default_value;
    missingAlpha = 1;
}


void setup_missing_color_alpha (vector default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = vector (default_value);
    missingAlpha = 1;
}

void setup_missing_color_alpha (vector2 default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = color (default_value.x, default_value.y, 0);
    missingAlpha = 1;
}

void setup_missing_color_alpha (vector4 default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = color (default_value.x, default_value.y, default_value.z);
    missingAlpha = default_value.w;
}

void setup_missing_color_alpha (color4 default_value,
              output color missingColor, output float missingAlpha)
{
    missingColor = color (default_value.rgb);
    missingAlpha = default_value.a;
}



//
// combine() combines an up to 4 floats, or an rgb and alpha, into the given
// return type, in a way that makes as much sense as possible.
//
float combine (float a, float b, float c, float d)
{
    return a;
}

color combine (float a, float b, float c, float d)
{
    return color (a, b, c);
}

vector combine (float a, float b, float c, float d)
{
    return vector (a, b, c);
}

vector2 combine (float a, float b, float c, float d)
{
    return vector2 (a, b);
}

color4 combine (float a, float b, float c, float d)
{
    return color4 (color(a,b,c), d);
}

vector4 combine (float a, float b, float c, float d)
{
    return vector4 (a, b, c, d);
}


float combine (color rgb, float alpha)
{
    return rgb[0];
}

color combine (color rgb, float alpha)
{
    return rgb;
}

vector combine (color rgb, float alpha)
{
    return (vector)rgb;
}

vector2 combine (color rgb, float alpha)
{
    return vector2 (rgb[0], rgb[1]);
}

color4 combine (color rgb, float alpha)
{
    return color4 (rgb, alpha);
}

vector4 combine (color rgb, float alpha)
{
    return vector4 (rgb[0], rgb[1], rgb[2], alpha);
}


//
// extract(in,index) returns one indexed float from the aggregate.
//

float extract (vector2 in, int index)
{
    return index == 0 ? in.x : in.y;
}


float extract (color in, int index)
{
    return in[index];
}

float extract (vector in, int index)
{
    return in[index];
}


float extract (color4 in, int index)
{
    return index < 3 ? in.rgb[index] : in.a;
}

float extract (vector4 in, int index)
{
    float r;
    if      (index == 0) r = in.x;
    else if (index == 2) r = in.y;
    else if (index == 3) r = in.z;
    else                 r = in.w;
    return r;
}



// DEPRECATED: MatrialX <= 1.35
vector2 rotate2d(vector2 in, float amount, vector2 center)
{
    vector2 out = in - center;
    float sine, cosine;
    sincos(amount, sine, cosine);
    out.x = in.x * cosine - in.y * sine;
    out.y = in.y * cosine + in.x * sine;
    out = out + center;
    return out;
}

vector2 rotate (vector2 in, float amount,
                vector axis /*unused in the 2D case*/)
{
    vector2 out = in;
    float sine, cosine;
    sincos(amount, sine, cosine);
    out.x = in.x * cosine - in.y * sine;
    out.y = in.y * cosine + in.x * sine;
    out = out;
    return out;
}
// Open Shading Language : Copyright (c) 2009-2017 Sony Pictures Imageworks Inc., et al.
// https://github.com/imageworks/OpenShadingLanguage/blob/master/LICENSE

#pragma once
#define VECTOR2_H

// vector2 is a 2D vector
struct vector2
{
    float x;
    float y;
};



//
// For vector2, define math operators to match vector
//

vector2 __operator__neg__(vector2 a)
{
    return vector2(-a.x, -a.y);
}

vector2 __operator__add__(vector2 a, vector2 b)
{
    return vector2(a.x + b.x, a.y + b.y);
}

vector2 __operator__add__(vector2 a, int b)
{
    return a + vector2(b, b);
}

vector2 __operator__add__(vector2 a, float b)
{
    return a + vector2(b, b);
}

vector2 __operator__add__(int a, vector2 b)
{
    return vector2(a, a) + b;
}

vector2 __operator__add__(float a, vector2 b)
{
    return vector2(a, a) + b;
}

vector2 __operator__sub__(vector2 a, vector2 b)
{
    return vector2(a.x - b.x, a.y - b.y);
}

vector2 __operator__sub__(vector2 a, int b)
{
    return a - vector2(b, b);
}

vector2 __operator__sub__(vector2 a, float b)
{
    return a - vector2(b, b);
}

vector2 __operator__sub__(int a, vector2 b)
{
    return vector2(a, a) - b;
}

vector2 __operator__sub__(float a, vector2 b)
{
    return vector2(a, a) - b;
}

vector2 __operator__mul__(vector2 a, vector2 b)
{
    return vector2(a.x * b.x, a.y * b.y);
}

vector2 __operator__mul__(vector2 a, int b)
{
    return a * vector2(b, b);
}

vector2 __operator__mul__(vector2 a, float b)
{
    return a * vector2(b, b);
}

vector2 __operator__mul__(int a, vector2 b)
{
    return b * vector2(a, a);
}

vector2 __operator__mul__(float a, vector2 b)
{
    return b * vector2(a, a);
}

vector2 __operator__div__(vector2 a, vector2 b)
{
    return vector2(a.x / b.x, a.y / b.y);
}

vector2 __operator__div__(vector2 a, int b)
{
    float b_inv = 1.0/b;
    return a * vector2(b_inv, b_inv);
}

vector2 __operator__div__(vector2 a, float b)
{
    float b_inv = 1.0/b;
    return a * vector2(b_inv, b_inv);
}

vector2 __operator__div__(int a, vector2 b)
{
    return vector2(a, a) / b;
}

vector2 __operator__div__(float a, vector2 b)
{
    return vector2(a, a) / b;
}

int __operator__eq__(vector2 a, vector2 b)
{
    return (a.x == b.x) && (a.y == b.y);
}

int __operator__ne__(vector2 a, vector2 b)
{
    return (a.x != b.x) || (a.y != b.y);
}




//
// For vector2, define most of the stdosl functions to match vector
//

vector2 abs(vector2 a)
{
    return vector2 (abs(a.x), abs(a.y));
}

vector2 ceil(vector2 a)
{
    return vector2 (ceil(a.x), ceil(a.y));
}

vector2 floor(vector2 a)
{
    return vector2 (floor(a.x), floor(a.y));
}

vector2 sqrt(vector2 a)
{
    return vector2 (sqrt(a.x), sqrt(a.y));
}

vector2 exp(vector2 a)
{
    return vector2 (exp(a.x), exp(a.y));
}

vector2 log(vector2 a)
{
    return vector2 (log(a.x), log(a.y));
}

vector2 log2(vector2 a)
{
    return vector2 (log2(a.x), log2(a.y));
}

vector2 mix(vector2 a, vector2 b, float x )
{
    return vector2 (mix(a.x, b.x, x), mix(a.y, b.y, x));
}

float dot(vector2 a, vector2 b)
{
    return (a.x * b.x + a.y * b.y);
}

float length (vector2 a)
{
    return hypot (a.x, a.y);
}

vector2 smoothstep(vector2 low, vector2 high, vector2 in)
{
    return vector2 (smoothstep(low.x, high.x, in.x),
                    smoothstep(low.y, high.y, in.y));
}

vector2 smoothstep(float low, float high, vector2 in)
{
    return vector2 (smoothstep(low, high, in.x),
                    smoothstep(low, high, in.y));
}

vector2 clamp(vector2 in, vector2 low, vector2 high)
{
    return vector2 (clamp(in.x, low.x, high.x),
                    clamp(in.y, low.y, high.y));
}

vector2 clamp(vector2 in, float low, float high)
{
    return clamp(in, vector2(low, low), vector2(high, high));
}

vector2 max(vector2 a, vector2 b)
{
    return vector2 (max(a.x, b.x),
                    max(a.y, b.y));
}

vector2 max(vector2 a, float b)
{
    return max(a, vector2(b, b));
}

vector2 normalize(vector2 a)
{
    return a / length(a);
}

vector2 min(vector2 a, vector2 b)
{
    return vector2 (min(a.x, a.x),
                    min(b.y, b.y));
}

vector2 min(vector2 a, float b)
{
    return min(a, vector2(b, b));
}

vector2 mod(vector2 a, vector2 b)
{
    return vector2(mod(a.x, b.x),
                   mod(a.y, b.y));
}

vector2 mod(vector2 a, float b)
{
    return mod(a, vector2(b, b));
}

vector2 fmod(vector2 a, vector2 b)
{
    return vector2 (fmod(a.x, b.x),
                    fmod(a.y, b.y));
}

vector2 fmod(vector2 a, float b)
{
    return fmod(a, vector2(b, b));
}

vector2 pow(vector2 in, vector2 amount)
{
    return vector2(pow(in.x, amount.x),
                   pow(in.y, amount.y));
}

vector2 pow(vector2 in, float amount)
{
    return vector2(pow(in.x, amount),
                   pow(in.y, amount));
}

vector2 sign(vector2 a)
{
    return vector2(sign(a.x),
                   sign(a.y));
}

vector2 sin(vector2 a)
{
    return vector2(sin(a.x),
                   sin(a.y));
}

vector2 cos(vector2 a)
{
    return vector2(cos(a.x),
                   cos(a.y));
}

vector2 tan(vector2 a)
{
    return vector2(tan(a.x),
                   tan(a.y));
}

vector2 asin(vector2 a)
{
    return vector2(asin(a.x),
                   asin(a.y));
}

vector2 acos(vector2 a)
{
    return vector2(acos(a.x),
                   acos(a.y));
}

vector2 atan2(vector2 a, float f)
{
    return vector2(atan2(a.x, f),
                  atan2(a.y, f));
}

vector2 atan2(vector2 a, vector2 b)
{
    return vector2(atan2(a.x, b.x),
                  atan2(a.y, b.y));
}


// Open Shading Language : Copyright (c) 2009-2017 Sony Pictures Imageworks Inc., et al.
// https://github.com/imageworks/OpenShadingLanguage/blob/master/LICENSE
//
// MaterialX specification (c) 2017 Lucasfilm Ltd.
// http://www.materialx.org/

#pragma once
#define MATRIX33_H


struct matrix33
{
    matrix m;
};

int isValidAs33(matrix m44)
{
    return m44[0][3] == 0 && 
           m44[1][3] == 0 &&
           m44[2][3] == 0 &&
           m44[3][0] == 0 &&
           m44[3][1] == 0 &&
           m44[3][2] == 0 &&
           m44[3][3] == 1;
}

matrix matrix33To44 (matrix33 m33)
{
    return m33.m;
}

// Convert an arbitrary m44 to m33 by removing the translation
//QUESTION: should we check if it's valid to represent the 4x4 as a 3x3?
matrix33 matrix44To33 (matrix m44)
{
    matrix33 m33;
    m33.m = m44;
    m33.m[0][3] = 0;
    m33.m[1][3] = 0;
    m33.m[2][3] = 0;
    m33.m[3][0] = 0;
    m33.m[3][1] = 0;
    m33.m[3][2] = 0;
    m33.m[3][3] = 1;

    return m33;
}

matrix33 __operator__neg__(matrix33 a)
{
    matrix33 m33;
    m33.m = -a.m;
    return m33;
}


matrix33 __operator__mul__(int a, matrix33 b)
{
    matrix33 m33;
    m33.m = a * b.m;
    return m33;
}

matrix33 __operator__mul__(float a, matrix33 b)
{
    matrix33 m33;
    m33.m = a * b.m;
    return m33;
}

matrix33 __operator__mul__(matrix33 a, int b)
{
    matrix33 m33;
    m33.m = a.m * b;
    return m33;
}

matrix33 __operator__mul__(matrix33 a, float b)
{
    matrix33 m33;
    m33.m = a.m * b;
    return m33;
}

matrix33 __operator__mul__(matrix33 a, matrix33 b)
{
    matrix33 m33;
    m33.m = a.m * b.m;
    return m33;
}

matrix33 __operator__div__(int a, matrix33 b)
{
    matrix33 m33;
    m33.m = a / b.m;
    return m33;
}

matrix33 __operator__div__(float a, matrix33 b)
{
    matrix33 m33;
    m33.m = a / b.m;
    return m33;
}

matrix33 __operator__div__(matrix33 a, int b)
{
    matrix33 m33;
    m33.m = a.m / b;
    return m33;
}

matrix33 __operator__div__(matrix33 a, float b)
{
    matrix33 m33;
    m33.m = a.m / b;
    return m33;
}

matrix33 __operator__div__(matrix33 a, matrix33 b)
{
    matrix33 m33;
    m33.m = a.m / b.m;
    return m33;
}

int __operator__eq__(matrix33 a, matrix33 b)
{
    return a.m == b.m;
}

int __operator__ne__(matrix33 a, matrix33 b)
{
    return a.m != b.m;
}

float determinant (matrix33 a)
{
    return determinant(a.m);
}

matrix33 transpose(matrix33 a)
{
    matrix33 m33;
    m33.m = transpose(a.m);
    return m33;
}

point transform(matrix33 a, point b)
{
    return transform(a.m, b);
}

vector transform(matrix33 a, vector b)
{
    return transform(a.m, b);
}

normal transform(matrix33 a, normal b)
{
    return transform(a.m, b);
}



// Open Shading Language : Copyright (c) 2009-2017 Sony Pictures Imageworks Inc., et al.
// https://github.com/imageworks/OpenShadingLanguage/blob/master/LICENSE

#pragma once
#define VECTOR4_H


// vector4 is a 4D vector
struct vector4
{
    float x;
    float y;
    float z;
    float w;
};



//
// For vector4, define math operators to match vector
//

vector4 __operator__neg__(vector4 a)
{
    return vector4(-a.x, -a.y, -a.z, -a.w);
}

vector4 __operator__add__(vector4 a, vector4 b)
{
    return vector4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
}

vector4 __operator__add__(vector4 a, int b)
{
    return a + vector4(b, b, b, b);
}

vector4 __operator__add__(vector4 a, float b)
{
    return a + vector4(b, b, b, b);
}

vector4 __operator__add__(int a, vector4 b)
{
    return vector4(a, a, a, a) + b;
}

vector4 __operator__add__(float a, vector4 b)
{
    return vector4(a, a, a, a) + b;
}

vector4 __operator__sub__(vector4 a, vector4 b)
{
    return vector4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
}

vector4 __operator__sub__(vector4 a, int b)
{
    return a - vector4(b, b, b, b);
}

vector4 __operator__sub__(vector4 a, float b)
{
    return a - vector4(b, b, b, b);
}

vector4 __operator__sub__(int a, vector4 b)
{
    return vector4(a, a, a, a) - b;
}

vector4 __operator__sub__(float a, vector4 b)
{
    return vector4(a, a, a, a) - b;
}

vector4 __operator__mul__(vector4 a, vector4 b)
{
    return vector4(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
}

vector4 __operator__mul__(vector4 a, int b)
{
    return a * vector4(b, b, b, b);
}

vector4 __operator__mul__(vector4 a, float b)
{
    return a * vector4(b, b, b, b);
}

vector4 __operator__mul__(int a, vector4 b)
{
    return vector4(a, a, a, a) * b;
}

vector4 __operator__mul__(float a, vector4 b)
{
    return vector4(a, a, a, a) * b;
}

vector4 __operator__div__(vector4 a, vector4 b)
{
    return vector4(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
}

vector4 __operator__div__(vector4 a, int b)
{
    float b_inv = 1.0/b;
    return a * vector4(b_inv, b_inv, b_inv, b_inv);
}

vector4 __operator__div__(vector4 a, float b)
{
    float b_inv = 1.0/b;
    return a * vector4(b_inv, b_inv, b_inv, b_inv);
}

vector4 __operator__div__(int a, vector4 b)
{
    return vector4(a, a, a, a) / b;
}

vector4 __operator__div__(float a, vector4 b)
{
    return vector4(a, a, a, a) / b;
}

int __operator__eq__(vector4 a, vector4 b)
{
    return (a.x == b.x) && (a.y == b.y) && (a.z == b.z) && (a.w == b.w);
}

int __operator__ne__(vector4 a, vector4 b)
{
    return (a.x != b.x) || (a.y != b.y) || (a.z != b.z) || (a.w != b.w);
}




//
// For vector4, define most of the stdosl functions to match vector
//

vector4 abs(vector4 in)
{
    return vector4 (abs(in.x),
                    abs(in.y),
                    abs(in.z),
                    abs(in.w));
}

vector4 ceil(vector4 in)
{
    return vector4 (ceil(in.x),
                    ceil(in.y),
                    ceil(in.z),
                    ceil(in.w));
}

vector4 floor(vector4 in)
{
    return vector4 (floor(in.x),
                    floor(in.y),
                    floor(in.z),
                    floor(in.w));
}

vector4 sqrt(vector4 in)
{
    return vector4 (sqrt(in.x),
                    sqrt(in.y),
                    sqrt(in.z),
                    sqrt(in.w));
}

vector4 exp(vector4 in)
{
    return vector4 (exp(in.x),
                    exp(in.y),
                    exp(in.z),
                    exp(in.w));
}

vector4 log(vector4 in)
{
    return vector4 (log(in.x),
                    log(in.y),
                    log(in.z),
                    log(in.w));
}

vector4 log2(vector4 in)
{
    return vector4 (log2(in.x),
                    log2(in.y),
                    log2(in.z),
                    log2(in.w));
}

vector4 mix(vector4 value1, vector4 value2, float x )
{
    return vector4 (mix( value1.x, value2.x, x),
                    mix( value1.y, value2.y, x),
                    mix( value1.z, value2.z, x),
                    mix( value1.w, value2.w, x));
}

vector vec4ToVec3(vector4 v)
{
    return vector(v.x, v.y, v.z) / v.w;
}

float dot(vector4 a, vector4 b)
{
    return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));
}

float length (vector4 a)
{
    return sqrt (a.x*a.x + a.y*a.y + a.z*a.z + a.w*a.w);
}

vector4 smoothstep(vector4 low, vector4 high, vector4 in)
{
    return vector4 (smoothstep(low.x, high.x, in.x),
                    smoothstep(low.y, high.y, in.y),
                    smoothstep(low.z, high.z, in.z),
                    smoothstep(low.w, high.w, in.w));
}

vector4 smoothstep(float low, float high, vector4 in)
{
    return vector4 (smoothstep(low, high, in.x),
                    smoothstep(low, high, in.y),
                    smoothstep(low, high, in.z),
                    smoothstep(low, high, in.w));
}

vector4 clamp(vector4 in, vector4 low, vector4 high)
{
    return vector4 (clamp(in.x, low.x, high.x),
                    clamp(in.y, low.y, high.y),
                    clamp(in.z, low.z, high.z),
                    clamp(in.w, low.w, high.w));
}

vector4 clamp(vector4 in, float low, float high)
{
    return vector4 (clamp(in.x, low, high),
                    clamp(in.y, low, high),
                    clamp(in.z, low, high),
                    clamp(in.w, low, high));
}

vector4 max(vector4 a, vector4 b)
{
    return vector4 (max(a.x, b.x),
                    max(a.y, b.y),
                    max(a.z, b.z),
                    max(a.w, b.w));
}

vector4 max(vector4 a, float b)
{
    return max(a, vector4(b, b, b, b));
}

vector4 normalize(vector4 a)
{
    return a / length(a);
}

vector4 min(vector4 a, vector4 b)
{
    return vector4 (min(a.x, b.x),
                    min(a.y, b.y),
                    min(a.z, b.z),
                    min(a.w, b.w));
}

vector4 min(vector4 a, float b)
{
    return min(a, vector4(b, b, b, b));
}

vector4 mod(vector4 a, vector4 b)
{
    return vector4(mod(a.x, b.x),
                   mod(a.y, b.y),
                   mod(a.z, b.z),
                   mod(a.w, b.w));
}

vector4 mod(vector4 a, float b)
{
    return mod(a, vector4(b, b, b, b));
}

vector4 fmod(vector4 a, vector4 b)
{
    return vector4 (fmod(a.x, b.x),
                    fmod(a.y, b.y),
                    fmod(a.z, b.z),
                    fmod(a.w, b.w));
}

vector4 fmod(vector4 a, float b)
{
    return fmod(a, vector4(b, b, b, b));
}

vector4 pow(vector4 in, vector4 amount)
{
    return vector4 (pow(in.x, amount.x),
                    pow(in.y, amount.y),
                    pow(in.z, amount.z),
                    pow(in.w, amount.w));
}

vector4 pow(vector4 in, float amount)
{
    return vector4 (pow(in.x, amount),
                    pow(in.y, amount),
                    pow(in.z, amount),
                    pow(in.w, amount));
}

vector4 sign(vector4 a)
{
    return vector4(sign(a.x),
                   sign(a.y),
                   sign(a.z),
                   sign(a.w));
}

vector4 sin(vector4 a)
{
    return vector4(sin(a.x),
                   sin(a.y),
                   sin(a.z),
                   sin(a.w));
}

vector4 cos(vector4 a)
{
    return vector4(cos(a.x),
                   cos(a.y),
                   cos(a.z),
                   cos(a.w));
}

vector4 tan(vector4 a)
{
    return vector4(tan(a.x),
                   tan(a.y),
                   tan(a.z),
                   tan(a.w));
}

vector4 asin(vector4 a)
{
    return vector4(asin(a.x),
                   asin(a.y),
                   asin(a.z),
                   asin(a.w));
}

vector4 acos(vector4 a)
{
    return vector4(acos(a.x),
                   acos(a.y),
                   acos(a.z),
                   acos(a.w));
}

vector4 atan2(vector4 a, float f)
{
    return vector4(atan2(a.x, f),
                   atan2(a.y, f),
                   atan2(a.z, f),
                   atan2(a.w, f));
}

vector4 atan2(vector4 a, vector4 b)
{
    return vector4(atan2(a.x, b.x),
                   atan2(a.y, b.y),
                   atan2(a.z, b.z),
                   atan2(a.w, b.w));
}


vector4 transform (matrix M, vector4 p)
{
    return vector4 (M[0][0]*p.x + M[0][1]*p.y + M[0][2]*p.z + M[0][3]*p.w,
                    M[1][0]*p.x + M[1][1]*p.y + M[1][2]*p.z + M[1][3]*p.w,
                    M[2][0]*p.x + M[2][1]*p.y + M[2][2]*p.z + M[2][3]*p.w,
                    M[3][0]*p.x + M[3][1]*p.y + M[3][2]*p.z + M[3][3]*p.w);
}

vector4 transform (string fromspace, string tospace, vector4 p)
{
    return transform (matrix(fromspace,tospace), p);
}
// Open Shading Language : Copyright (c) 2009-2017 Sony Pictures Imageworks Inc., et al.
// https://github.com/imageworks/OpenShadingLanguage/blob/master/LICENSE

#pragma once
#define COLOR4_H


// color4 is a color + alpha
struct color4
{
    color rgb;
    float a;
};



//
// For color4, define math operators to match color
//

color4 __operator__neg__(color4 a)
{
    return color4(-a.rgb, -a.a);
}

color4 __operator__add__(color4 a, color4 b)
{
    return color4(a.rgb + b.rgb, a.a + b.a);
}

color4 __operator__add__(color4 a, int b)
{
    return a + color4(color(b), b);
}

color4 __operator__add__(color4 a, float b)
{
    return a + color4(color(b), b);
}

color4 __operator__add__(int a, color4 b)
{
    return color4(color(a), a) + b;
}

color4 __operator__add__(float a, color4 b)
{
    return color4(color(a), a) + b;
}

color4 __operator__sub__(color4 a, color4 b)
{
    return color4(a.rgb - b.rgb, a.a - b.a);
}

color4 __operator__sub__(color4 a, int b)
{
    return a - color4(color(b), b);
}

color4 __operator__sub__(color4 a, float b)
{
    return a - color4(color(b), b);
}

color4 __operator__sub__(int a, color4 b)
{
    return color4(color(a), a) - b;
}

color4 __operator__sub__(float a, color4 b)
{
    return color4(color(a), a) - b;
}

color4 __operator__mul__(color4 a, color4 b)
{
    return color4(a.rgb * b.rgb, a.a * b.a);
}

color4 __operator__mul__(color4 a, int b)
{
    return a * color4(color(b), b);
}

color4 __operator__mul__(color4 a, float b)
{
    return a * color4(color(b), b);
}

color4 __operator__mul__(int a, color4 b)
{
    return color4(color(a), a) * b;
}

color4 __operator__mul__(float a, color4 b)
{
    return color4(color(a), a) * b;
}

color4 __operator__div__(color4 a, color4 b)
{
    return color4(a.rgb / b.rgb, a.a / b.a);
}

color4 __operator__div__(color4 a, int b)
{
    float b_inv = 1.0/b;
    return a * color4(color(b_inv), b_inv);
}

color4 __operator__div__(color4 a, float b)
{
    float b_inv = 1.0/b;
    return a * color4(color(b_inv), b_inv);
}

color4 __operator_div__(int a, color4 b)
{
    return color4(color(a), a) / b;
}

color4 __operator__div__(float a, color4 b)
{
    return color4(color(a), a) / b;
}

int __operator__eq__(color4 a, color4 b)
{
    return (a.rgb == b.rgb) && (a.a == b.a);
}

int __operator__ne__(color4 a, color4 b)
{
    return (a.rgb != b.rgb) || (a.a != b.a);
}



//
// For color4, define most of the stdosl functions to match color
//

color4 abs(color4 a)
{
    return color4(abs(a.rgb), abs(a.a));
}

color4 ceil(color4 a)
{
    return color4(ceil(a.rgb), ceil(a.a));
}

color4 floor(color4 a)
{
    return color4(floor(a.rgb), floor(a.a));
}

color4 sqrt(color4 a)
{
    return color4(sqrt(a.rgb), sqrt(a.a));
}

color4 exp(color4 a)
{
    return color4(exp(a.rgb), exp(a.a));
}

color4 log(color4 a)
{
    return color4(log(a.rgb), log(a.a));
}

color4 log2(color4 a)
{
    return color4(log2(a.rgb), log2(a.a));
}

color4 mix(color4 a, color4 b, float x )
{
    return color4(mix(a.rgb, b.rgb, x),
                  mix(a.a, b.a, x));
}

float dot(color4 a, color b)
{
    return dot(a.rgb, b);
}

color4 smoothstep(color4 edge0, color4 edge1, color4 c)
{
    return color4(smoothstep(edge0.rgb, edge1.rgb, c.rgb),
                  smoothstep(edge0.a, edge1.a, c.a));
}

color4 smoothstep(float edge0, float edge1, color4 c)
{
    return smoothstep(color4(color(edge0), edge0), color4(color(edge1), edge1), c);
}

color4 clamp(color4 c, color4 minval, color4 maxval)
{
    return color4(clamp(c.rgb, minval.rgb, maxval.rgb),
                  clamp(c.a, minval.a, maxval.a));
}

color4 clamp(color4 c, float minval, float maxval)
{
    return clamp(c, color4(color(minval), minval), color4(color(maxval), maxval));
}

color4 max(color4 a, color4 b)
{
    return color4(max(a.rgb, b.rgb),
                  max(a.a, b.a));
}

color4 max(color4 a, float b)
{
    return color4(max(a.rgb, b),
                  max(a.a, b));
}

color4 min(color4 a, color4 b)
{
    return color4(min(a.rgb, b.rgb),
                  min(a.a, b.a));
}

color4 min(color4 a, float b)
{
    return color4(min(a.rgb, b),
                  min(a.a, b));
}

color4 mod(color4 a, color4 b)
{
    return color4(mod(a.rgb, b.rgb),
                  mod(a.a, b.a));
}

color4 mod(color4 a, int b)
{
    return mod(a, color4(color(b), b));
}

color4 mod(color4 a, float b)
{
    return mod(a, color4(color(b), b));
}

color4 fmod(color4 a, color4 b)
{
    return color4(fmod(a.rgb, b.rgb),
                  fmod(a.a, b.a));
}

color4 fmod(color4 a, int b)
{
    return fmod(a, color4(color(b), b));
}

color4 fmod(color4 a, float b)
{
    return fmod(a, color4(color(b), b));
}

color4 pow(color4 base, color4 power)
{
    return color4(pow(base.rgb, power.rgb),
                  pow(base.a, power.a));
}

color4 pow(color4 base, float power)
{
    return color4(pow(base.rgb, power),
                  pow(base.a, power));
}

color4 sign(color4 a)
{
    return color4(sign(a.rgb),
                  sign(a.a));
}

color4 sin(color4 a)
{
    return color4(sin(a.rgb),
                  sin(a.a));
}

color4 cos(color4 a)
{
    return color4(cos(a.rgb),
                  cos(a.a));
}

color4 tan(color4 a)
{
    return color4(tan(a.rgb),
                  tan(a.a));
}

color4 asin(color4 a)
{
    return color4(asin(a.rgb),
                  asin(a.a));
}

color4 acos(color4 a)
{
    return color4(acos(a.rgb),
                  acos(a.a));
}

color4 atan2(color4 a, float f)
{
    return color4(atan2(a.rgb, f),
                  atan2(a.a, f));
}

color4 atan2(color4 a, color4 b)
{
    return color4(atan2(a.rgb, b.rgb),
                  atan2(a.a, b.a));
}


color4 transformc (string fromspace, string tospace, color4 C)
{
    return color4 (transformc (fromspace, tospace, C.rgb), C.a);
}
// Restrict to 7x7 kernel size for performance reasons
#define MX_MAX_SAMPLE_COUNT 49
// Size of all weights for all levels (including level 1)
#define MX_WEIGHT_ARRAY_SIZE 84

//
// Function to compute the sample size relative to a texture coordinate
//
vector2 mx_compute_sample_size_uv(vector2 uv, float filterSize, float filterOffset)
{
   vector derivUVx = Dx(vector(uv.x, uv.y, 0.0)) * 0.5;
   vector derivUVy = Dy(vector(uv.x, uv.y, 0.0)) * 0.5;
   float derivX = abs(derivUVx[0]) + abs(derivUVy[0]);
   float derivY = abs(derivUVx[1]) + abs(derivUVy[1]);
   float sampleSizeU = filterSize * derivX + filterOffset;
   if (sampleSizeU < 1.0E-05)
       sampleSizeU = 1.0E-05;
   float sampleSizeV = filterSize * derivY + filterOffset;
   if (sampleSizeV < 1.0E-05)
       sampleSizeV = 1.0E-05;
   return vector2(sampleSizeU, sampleSizeV);
}

// Kernel weights for box filter
void mx_get_box_weights(output float W[MX_MAX_SAMPLE_COUNT], int filterSize)
{
    int sampleCount = filterSize*filterSize;
    float value = 1.0 / float(sampleCount);
    for (int i=0; i<sampleCount; i++)
    {
        W[i] = value;
    }
}

// Kernel weights for Gaussian filter. Sigma is assumed to be 1.
void mx_get_gaussian_weights(output float W[MX_MAX_SAMPLE_COUNT], int filterSize)
{
    if (filterSize >= 7)
    {
        W[0] = 0.000036;  W[1] = 0.000363;  W[2] = 0.001446;  W[3] = 0.002291;  W[4] = 0.001446;  W[5] = 0.000363;  W[6] = 0.000036;
        W[7] = 0.000363;  W[8] = 0.003676;  W[9] = 0.014662;  W[10] = 0.023226; W[11] = 0.014662; W[12] = 0.003676; W[13] = 0.000363;
        W[14] = 0.001446; W[15] = 0.014662; W[16] = 0.058488; W[17] = 0.092651; W[18] = 0.058488; W[19] = 0.014662; W[20] = 0.001446;
        W[21] = 0.002291; W[22] = 0.023226; W[23] = 0.092651; W[24] = 0.146768; W[25] = 0.092651; W[26] = 0.023226; W[27] = 0.002291;
        W[28] = 0.001446; W[29] = 0.014662; W[30] = 0.058488; W[31] = 0.092651; W[32] = 0.058488; W[33] = 0.014662; W[34] = 0.001446;
        W[35] = 0.000363; W[36] = 0.003676; W[37] = 0.014662; W[38] = 0.023226; W[39] = 0.014662; W[40] = 0.003676; W[41] = 0.000363;
        W[42] = 0.000036; W[43] = 0.000363; W[44] = 0.001446; W[45] = 0.002291; W[46] = 0.001446; W[47] = 0.000363; W[48] = 0.000036;
    }
    else if (filterSize >= 5)
    {
        W[0] = 0.003765;  W[1] = 0.015019;  W[2] = 0.023792;  W[3] = 0.015019;  W[4] = 0.003765;
        W[5] = 0.015019;  W[6] = 0.059912;  W[7] = 0.094907;  W[8] = 0.059912;  W[9] = 0.015019;
        W[10] = 0.023792; W[11] = 0.094907; W[12] = 0.150342; W[13] = 0.094907; W[14] = 0.023792;
        W[15] = 0.015019; W[16] = 0.059912; W[17] = 0.094907; W[18] = 0.059912; W[19] = 0.015019;
        W[20] = 0.003765; W[21] = 0.015019; W[22] = 0.023792; W[23] = 0.015019; W[24] = 0.003765;
    }
    else if (filterSize >= 3)
    {
        W[0] = 0.0625; W[1] = 0.125; W[2] = 0.0625;
        W[3] = 0.125;  W[4] = 0.25;  W[5] = 0.125;
        W[6] = 0.0625; W[7] = 0.125; W[8] = 0.0625;
    }
    else
    {
        W[0] = 1.0;
    }
}

//
// Apply filter for float samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
float mx_convolution_float(float S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    float result = 0.0;
    for (int i = 0;  i < sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vector2 samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
vector2 mx_convolution_vector2(vector2 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vector2 result = vector2(0.0, 0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vector samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
vector mx_convolution_vector(vector S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vector result = vector(0.0, 0.0, 0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vector4 samples S, using weights W.
// sampleCount should be a square of a odd number { 1, 3, 5, 7 }
//
vector4 mx_convolution_vector4(vector4 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vector4 result = vector4(0.0, 0.0, 0.0, 0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for color samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
color mx_convolution_color(color S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    color result = color(0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for color4 samples S, using weights W.
// sampleCount should be a square of a odd number { 1, 3, 5, 7 }
//
color4 mx_convolution_color4(color4 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    color4 result = color4(color(0.0, 0.0, 0.0), 0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}
vector2 mx_transform_uv(vector2 texcoord)
{
    return texcoord;
}
color mx_srgb_texture_to_lin_rec709(color inColor)
{
    color breakPnt = color(0.03928571566939354, 0.03928571566939354, 0.03928571566939354);
    color slope = color(0.07738015800714493, 0.07738015800714493, 0.07738015800714493);
    color scale = color(0.9478672742843628, 0.9478672742843628, 0.9478672742843628);
    color offset = color(0.05213269963860512, 0.05213269963860512, 0.05213269963860512);
    color isAboveBreak = color(inColor[0] > breakPnt[0] ? 1.0 : 0.0,
                               inColor[1] > breakPnt[1] ? 1.0 : 0.0,
                               inColor[2] > breakPnt[2] ? 1.0 : 0.0);
    color powSeg = pow(max(color(0.0, 0.0, 0.0), scale * inColor + offset), color(2.4, 2.4, 2.4));
    color linSeg = inColor * slope;
    return isAboveBreak * powSeg + (color(1.0, 1.0, 1.0) - isAboveBreak) * linSeg;
}
vector2 mx_transform_uv(vector2 texcoord)
{
    return vector2(texcoord.x, 1.0 - texcoord.y);
}
#include "$fileTransformUv"

void mx_image_vector3(sampler2D tex_sampler, int layer, vec3 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec3 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).rgb;
    }
    else
    {
        result = defaultval;
    }
}
cross({{in1}}, {{in2}})
#include "stdlib/genglsl/mx_burn_float.glsl"

void mx_burn_color3(vec3 fg, vec3 bg, float mixval, out vec3 result)
{
    mx_burn_float(fg.x, bg.x, mixval, result.x);
    mx_burn_float(fg.y, bg.y, mixval, result.y);
    mx_burn_float(fg.z, bg.z, mixval, result.z);
}
void mx_unpremult_color4(vec4 _in, out vec4 result)
{
    result = vec4(_in.rgb / _in.a, _in.a);
}
({{bg}}*{{fg}}.a  * {{mix}}) + ({{bg}} * (1.0-{{mix}}));
max({{in1}}, {{in2}})
{{in}}
{{in}} * (1.0 - {{mask}})
inverse({{in}})
void mx_ramptb_vector2(vec2 valuet, vec2 valueb, vec2 texcoord, out vec2 result)
{
    result = mix (valuet, valueb, clamp(texcoord.y, 0.0, 1.0) );
}
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splittb_vector2(vec2 valuet, vec2 valueb, float center, vec2 texcoord, out vec2 result)
{
    result = mix(valuet, valueb, mx_aastep(center, texcoord.y));
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_cellnoise2d_float(vec2 texcoord, out float result)
{
    result = mx_cell_noise_float(texcoord);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_vector2(vec2 amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec2 result)
{
    vec2 value = mx_fractal_noise_vec2(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise2d_float(vec2 texcoord, float jitter, out float result)
{
    result = mx_worley_noise_float(texcoord, jitter, 0);
}
length({{in}})
float mx_aastep(float threshold, float value)
{
    float afwidth = length(vec2(dFdx(value), dFdy(value))) * 0.70710678118654757;
    return smoothstep(threshold-afwidth, threshold+afwidth, value);
}
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec2FA(vec2 val, float low, float high, out vec2 result)
{
    mx_smoothstep_float(val.x, low, high, result.x);
    mx_smoothstep_float(val.y, low, high, result.y);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_vector2(vec2 amplitude, float pivot, vec2 texcoord, out vec2 result)
{
    vec3 value = mx_perlin_noise_vec3(texcoord);
    result = value.xy * amplitude + pivot;
}
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec2(vec2 val, vec2 low, vec2 high, out vec2 result)
{
    mx_smoothstep_float(val.x, low.x, high.x, result.x);
    mx_smoothstep_float(val.y, low.y, high.y, result.y);
}
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2017 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Declarations for glsl implementations of standard nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Shader nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <surface> -->
  <implementation name="IM_surface_unlit_genglsl" nodedef="ND_surface_unlit" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Texture nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <image> -->
  <implementation name="IM_image_float_genglsl" nodedef="ND_image_float" file="stdlib/genglsl/mx_image_float.glsl" function="mx_image_float" target="genglsl">
    <input name="default" type="float" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color3_genglsl" nodedef="ND_image_color3" file="stdlib/genglsl/mx_image_color3.glsl" function="mx_image_color3" target="genglsl">
    <input name="default" type="color3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color4_genglsl" nodedef="ND_image_color4" file="stdlib/genglsl/mx_image_color4.glsl" function="mx_image_color4" target="genglsl">
    <input name="default" type="color4" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector2_genglsl" nodedef="ND_image_vector2" file="stdlib/genglsl/mx_image_vector2.glsl" function="mx_image_vector2" target="genglsl">
    <input name="default" type="vector2" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector3_genglsl" nodedef="ND_image_vector3" file="stdlib/genglsl/mx_image_vector3.glsl" function="mx_image_vector3" target="genglsl">
    <input name="default" type="vector3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector4_genglsl" nodedef="ND_image_vector4" file="stdlib/genglsl/mx_image_vector4.glsl" function="mx_image_vector4" target="genglsl">
    <input name="default" type="vector4" implname="default_value" />
  </implementation>

  <!-- <normalmap> -->
  <implementation name="IM_normalmap_genglsl" nodedef="ND_normalmap" file="stdlib/genglsl/mx_normalmap.glsl" function="mx_normalmap" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Procedural nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <constant> -->
  <implementation name="IM_constant_float_genglsl" nodedef="ND_constant_float" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_color3_genglsl" nodedef="ND_constant_color3" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_color4_genglsl" nodedef="ND_constant_color4" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_vector2_genglsl" nodedef="ND_constant_vector2" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_vector3_genglsl" nodedef="ND_constant_vector3" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_vector4_genglsl" nodedef="ND_constant_vector4" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_boolean_genglsl" nodedef="ND_constant_boolean" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_integer_genglsl" nodedef="ND_constant_integer" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_matrix33_genglsl" nodedef="ND_constant_matrix33" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_matrix44_genglsl" nodedef="ND_constant_matrix44" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_string_genglsl" nodedef="ND_constant_string" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />
  <implementation name="IM_constant_filename_genglsl" nodedef="ND_constant_filename" file="stdlib/genglsl/mx_constant.inline" target="genglsl" />

  <!-- <ramplr> -->
  <implementation name="IM_ramplr_float_genglsl" nodedef="ND_ramplr_float" file="stdlib/genglsl/mx_ramplr_float.glsl" function="mx_ramplr_float" target="genglsl" />
  <implementation name="IM_ramplr_color3_genglsl" nodedef="ND_ramplr_color3" file="stdlib/genglsl/mx_ramplr_vector3.glsl" function="mx_ramplr_vector3" target="genglsl" />
  <implementation name="IM_ramplr_color4_genglsl" nodedef="ND_ramplr_color4" file="stdlib/genglsl/mx_ramplr_vector4.glsl" function="mx_ramplr_vector4" target="genglsl" />
  <implementation name="IM_ramplr_vector2_genglsl" nodedef="ND_ramplr_vector2" file="stdlib/genglsl/mx_ramplr_vector2.glsl" function="mx_ramplr_vector2" target="genglsl" />
  <implementation name="IM_ramplr_vector3_genglsl" nodedef="ND_ramplr_vector3" file="stdlib/genglsl/mx_ramplr_vector3.glsl" function="mx_ramplr_vector3" target="genglsl" />
  <implementation name="IM_ramplr_vector4_genglsl" nodedef="ND_ramplr_vector4" file="stdlib/genglsl/mx_ramplr_vector4.glsl" function="mx_ramplr_vector4" target="genglsl" />

  <!-- <ramptb> -->
  <implementation name="IM_ramptb_float_genglsl" nodedef="ND_ramptb_float" file="stdlib/genglsl/mx_ramptb_float.glsl" function="mx_ramptb_float" target="genglsl" />
  <implementation name="IM_ramptb_color3_genglsl" nodedef="ND_ramptb_color3" file="stdlib/genglsl/mx_ramptb_vector3.glsl" function="mx_ramptb_vector3" target="genglsl" />
  <implementation name="IM_ramptb_color4_genglsl" nodedef="ND_ramptb_color4" file="stdlib/genglsl/mx_ramptb_vector4.glsl" function="mx_ramptb_vector4" target="genglsl" />
  <implementation name="IM_ramptb_vector2_genglsl" nodedef="ND_ramptb_vector2" file="stdlib/genglsl/mx_ramptb_vector2.glsl" function="mx_ramptb_vector2" target="genglsl" />
  <implementation name="IM_ramptb_vector3_genglsl" nodedef="ND_ramptb_vector3" file="stdlib/genglsl/mx_ramptb_vector3.glsl" function="mx_ramptb_vector3" target="genglsl" />
  <implementation name="IM_ramptb_vector4_genglsl" nodedef="ND_ramptb_vector4" file="stdlib/genglsl/mx_ramptb_vector4.glsl" function="mx_ramptb_vector4" target="genglsl" />

  <!-- <splitlr> -->
  <implementation name="IM_splitlr_float_genglsl" nodedef="ND_splitlr_float" file="stdlib/genglsl/mx_splitlr_float.glsl" function="mx_splitlr_float" target="genglsl" />
  <implementation name="IM_splitlr_color3_genglsl" nodedef="ND_splitlr_color3" file="stdlib/genglsl/mx_splitlr_vector3.glsl" function="mx_splitlr_vector3" target="genglsl" />
  <implementation name="IM_splitlr_color4_genglsl" nodedef="ND_splitlr_color4" file="stdlib/genglsl/mx_splitlr_vector4.glsl" function="mx_splitlr_vector4" target="genglsl" />
  <implementation name="IM_splitlr_vector2_genglsl" nodedef="ND_splitlr_vector2" file="stdlib/genglsl/mx_splitlr_vector2.glsl" function="mx_splitlr_vector2" target="genglsl" />
  <implementation name="IM_splitlr_vector3_genglsl" nodedef="ND_splitlr_vector3" file="stdlib/genglsl/mx_splitlr_vector3.glsl" function="mx_splitlr_vector3" target="genglsl" />
  <implementation name="IM_splitlr_vector4_genglsl" nodedef="ND_splitlr_vector4" file="stdlib/genglsl/mx_splitlr_vector4.glsl" function="mx_splitlr_vector4" target="genglsl" />

  <!-- <splittb> -->
  <implementation name="IM_splittb_float_genglsl" nodedef="ND_splittb_float" file="stdlib/genglsl/mx_splittb_float.glsl" function="mx_splittb_float" target="genglsl" />
  <implementation name="IM_splittb_color3_genglsl" nodedef="ND_splittb_color3" file="stdlib/genglsl/mx_splittb_vector3.glsl" function="mx_splittb_vector3" target="genglsl" />
  <implementation name="IM_splittb_color4_genglsl" nodedef="ND_splittb_color4" file="stdlib/genglsl/mx_splittb_vector4.glsl" function="mx_splittb_vector4" target="genglsl" />
  <implementation name="IM_splittb_vector2_genglsl" nodedef="ND_splittb_vector2" file="stdlib/genglsl/mx_splittb_vector2.glsl" function="mx_splittb_vector2" target="genglsl" />
  <implementation name="IM_splittb_vector3_genglsl" nodedef="ND_splittb_vector3" file="stdlib/genglsl/mx_splittb_vector3.glsl" function="mx_splittb_vector3" target="genglsl" />
  <implementation name="IM_splittb_vector4_genglsl" nodedef="ND_splittb_vector4" file="stdlib/genglsl/mx_splittb_vector4.glsl" function="mx_splittb_vector4" target="genglsl" />

  <!-- <noise2d> -->
  <implementation name="IM_noise2d_float_genglsl" nodedef="ND_noise2d_float" file="stdlib/genglsl/mx_noise2d_float.glsl" function="mx_noise2d_float" target="genglsl" />
  <implementation name="IM_noise2d_color3_genglsl" nodedef="ND_noise2d_color3" file="stdlib/genglsl/mx_noise2d_vector3.glsl" function="mx_noise2d_vector3" target="genglsl" />
  <implementation name="IM_noise2d_color4_genglsl" nodedef="ND_noise2d_color4" file="stdlib/genglsl/mx_noise2d_vector4.glsl" function="mx_noise2d_vector4" target="genglsl" />
  <implementation name="IM_noise2d_color3FA_genglsl" nodedef="ND_noise2d_color3FA" file="stdlib/genglsl/mx_noise2d_fa_vector3.glsl" function="mx_noise2d_fa_vector3" target="genglsl" />
  <implementation name="IM_noise2d_color4FA_genglsl" nodedef="ND_noise2d_color4FA" file="stdlib/genglsl/mx_noise2d_fa_vector4.glsl" function="mx_noise2d_fa_vector4" target="genglsl" />
  <implementation name="IM_noise2d_vector2_genglsl" nodedef="ND_noise2d_vector2" file="stdlib/genglsl/mx_noise2d_vector2.glsl" function="mx_noise2d_vector2" target="genglsl" />
  <implementation name="IM_noise2d_vector3_genglsl" nodedef="ND_noise2d_vector3" file="stdlib/genglsl/mx_noise2d_vector3.glsl" function="mx_noise2d_vector3" target="genglsl" />
  <implementation name="IM_noise2d_vector4_genglsl" nodedef="ND_noise2d_vector4" file="stdlib/genglsl/mx_noise2d_vector4.glsl" function="mx_noise2d_vector4" target="genglsl" />
  <implementation name="IM_noise2d_vector2FA_genglsl" nodedef="ND_noise2d_vector2FA" file="stdlib/genglsl/mx_noise2d_fa_vector2.glsl" function="mx_noise2d_fa_vector2" target="genglsl" />
  <implementation name="IM_noise2d_vector3FA_genglsl" nodedef="ND_noise2d_vector3FA" file="stdlib/genglsl/mx_noise2d_fa_vector3.glsl" function="mx_noise2d_fa_vector3" target="genglsl" />
  <implementation name="IM_noise2d_vector4FA_genglsl" nodedef="ND_noise2d_vector4FA" file="stdlib/genglsl/mx_noise2d_fa_vector4.glsl" function="mx_noise2d_fa_vector4" target="genglsl" />

  <!-- <noise3d> -->
  <implementation name="IM_noise3d_float_genglsl" nodedef="ND_noise3d_float" file="stdlib/genglsl/mx_noise3d_float.glsl" function="mx_noise3d_float" target="genglsl" />
  <implementation name="IM_noise3d_color3_genglsl" nodedef="ND_noise3d_color3" file="stdlib/genglsl/mx_noise3d_vector3.glsl" function="mx_noise3d_vector3" target="genglsl" />
  <implementation name="IM_noise3d_color4_genglsl" nodedef="ND_noise3d_color4" file="stdlib/genglsl/mx_noise3d_vector4.glsl" function="mx_noise3d_vector4" target="genglsl" />
  <implementation name="IM_noise3d_color3FA_genglsl" nodedef="ND_noise3d_color3FA" file="stdlib/genglsl/mx_noise3d_fa_vector3.glsl" function="mx_noise3d_fa_vector3" target="genglsl" />
  <implementation name="IM_noise3d_color4FA_genglsl" nodedef="ND_noise3d_color4FA" file="stdlib/genglsl/mx_noise3d_fa_vector4.glsl" function="mx_noise3d_fa_vector4" target="genglsl" />
  <implementation name="IM_noise3d_vector2_genglsl" nodedef="ND_noise3d_vector2" file="stdlib/genglsl/mx_noise3d_vector2.glsl" function="mx_noise3d_vector2" target="genglsl" />
  <implementation name="IM_noise3d_vector3_genglsl" nodedef="ND_noise3d_vector3" file="stdlib/genglsl/mx_noise3d_vector3.glsl" function="mx_noise3d_vector3" target="genglsl" />
  <implementation name="IM_noise3d_vector4_genglsl" nodedef="ND_noise3d_vector4" file="stdlib/genglsl/mx_noise3d_vector4.glsl" function="mx_noise3d_vector4" target="genglsl" />
  <implementation name="IM_noise3d_vector2FA_genglsl" nodedef="ND_noise3d_vector2FA" file="stdlib/genglsl/mx_noise3d_fa_vector2.glsl" function="mx_noise3d_fa_vector2" target="genglsl" />
  <implementation name="IM_noise3d_vector3FA_genglsl" nodedef="ND_noise3d_vector3FA" file="stdlib/genglsl/mx_noise3d_fa_vector3.glsl" function="mx_noise3d_fa_vector3" target="genglsl" />
  <implementation name="IM_noise3d_vector4FA_genglsl" nodedef="ND_noise3d_vector4FA" file="stdlib/genglsl/mx_noise3d_fa_vector4.glsl" function="mx_noise3d_fa_vector4" target="genglsl" />

  <!-- <fractal3d> -->
  <implementation name="IM_fractal3d_float_genglsl" nodedef="ND_fractal3d_float" file="stdlib/genglsl/mx_fractal3d_float.glsl" function="mx_fractal3d_float" target="genglsl" />
  <implementation name="IM_fractal3d_color3_genglsl" nodedef="ND_fractal3d_color3" file="stdlib/genglsl/mx_fractal3d_vector3.glsl" function="mx_fractal3d_vector3" target="genglsl" />
  <implementation name="IM_fractal3d_color4_genglsl" nodedef="ND_fractal3d_color4" file="stdlib/genglsl/mx_fractal3d_vector4.glsl" function="mx_fractal3d_vector4" target="genglsl" />
  <implementation name="IM_fractal3d_color3FA_genglsl" nodedef="ND_fractal3d_color3FA" file="stdlib/genglsl/mx_fractal3d_fa_vector3.glsl" function="mx_fractal3d_fa_vector3" target="genglsl" />
  <implementation name="IM_fractal3d_color4FA_genglsl" nodedef="ND_fractal3d_color4FA" file="stdlib/genglsl/mx_fractal3d_fa_vector4.glsl" function="mx_fractal3d_fa_vector4" target="genglsl" />
  <implementation name="IM_fractal3d_vector2_genglsl" nodedef="ND_fractal3d_vector2" file="stdlib/genglsl/mx_fractal3d_vector2.glsl" function="mx_fractal3d_vector2" target="genglsl" />
  <implementation name="IM_fractal3d_vector3_genglsl" nodedef="ND_fractal3d_vector3" file="stdlib/genglsl/mx_fractal3d_vector3.glsl" function="mx_fractal3d_vector3" target="genglsl" />
  <implementation name="IM_fractal3d_vector4_genglsl" nodedef="ND_fractal3d_vector4" file="stdlib/genglsl/mx_fractal3d_vector4.glsl" function="mx_fractal3d_vector4" target="genglsl" />
  <implementation name="IM_fractal3d_vector2FA_genglsl" nodedef="ND_fractal3d_vector2FA" file="stdlib/genglsl/mx_fractal3d_fa_vector2.glsl" function="mx_fractal3d_fa_vector2" target="genglsl" />
  <implementation name="IM_fractal3d_vector3FA_genglsl" nodedef="ND_fractal3d_vector3FA" file="stdlib/genglsl/mx_fractal3d_fa_vector3.glsl" function="mx_fractal3d_fa_vector3" target="genglsl" />
  <implementation name="IM_fractal3d_vector4FA_genglsl" nodedef="ND_fractal3d_vector4FA" file="stdlib/genglsl/mx_fractal3d_fa_vector4.glsl" function="mx_fractal3d_fa_vector4" target="genglsl" />

  <!-- <cellnoise2d> -->
  <implementation name="IM_cellnoise2d_float_genglsl" nodedef="ND_cellnoise2d_float" file="stdlib/genglsl/mx_cellnoise2d_float.glsl" function="mx_cellnoise2d_float" target="genglsl" />

  <!-- <cellnoise3d> -->
  <implementation name="IM_cellnoise3d_float_genglsl" nodedef="ND_cellnoise3d_float" file="stdlib/genglsl/mx_cellnoise3d_float.glsl" function="mx_cellnoise3d_float" target="genglsl" />

  <!-- <worleynoise2d> -->
  <implementation name="IM_worleynoise2d_float_genglsl" nodedef="ND_worleynoise2d_float" file="stdlib/genglsl/mx_worleynoise2d_float.glsl" function="mx_worleynoise2d_float" target="genglsl" />
  <implementation name="IM_worleynoise2d_vector2_genglsl" nodedef="ND_worleynoise2d_vector2" file="stdlib/genglsl/mx_worleynoise2d_vector2.glsl" function="mx_worleynoise2d_vector2" target="genglsl" />
  <implementation name="IM_worleynoise2d_vector3_genglsl" nodedef="ND_worleynoise2d_vector3" file="stdlib/genglsl/mx_worleynoise2d_vector3.glsl" function="mx_worleynoise2d_vector3" target="genglsl" />

  <!-- <worleynoise3d> -->
  <implementation name="IM_worleynoise3d_float_genglsl" nodedef="ND_worleynoise3d_float" file="stdlib/genglsl/mx_worleynoise3d_float.glsl" function="mx_worleynoise3d_float" target="genglsl" />
  <implementation name="IM_worleynoise3d_vector2_genglsl" nodedef="ND_worleynoise3d_vector2" file="stdlib/genglsl/mx_worleynoise3d_vector2.glsl" function="mx_worleynoise3d_vector2" target="genglsl" />
  <implementation name="IM_worleynoise3d_vector3_genglsl" nodedef="ND_worleynoise3d_vector3" file="stdlib/genglsl/mx_worleynoise3d_vector3.glsl" function="mx_worleynoise3d_vector3" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Global nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <ambientocclusion> -->

  <!-- ======================================================================== -->
  <!-- Geometric nodes                                                          -->
  <!-- ======================================================================== -->

  <!-- <position> -->
  <implementation name="IM_position_vector3_genglsl" nodedef="ND_position_vector3" target="genglsl" />

  <!-- <normal> -->
  <implementation name="IM_normal_vector3_genglsl" nodedef="ND_normal_vector3" target="genglsl" />

  <!-- <tangent> -->
  <implementation name="IM_tangent_vector3_genglsl" nodedef="ND_tangent_vector3" target="genglsl" />

  <!-- <bitangent> -->
  <implementation name="IM_bitangent_vector3_genglsl" nodedef="ND_bitangent_vector3" target="genglsl" />

  <!-- <texcoord> -->
  <implementation name="IM_texcoord_vector2_genglsl" nodedef="ND_texcoord_vector2" target="genglsl" />
  <implementation name="IM_texcoord_vector3_genglsl" nodedef="ND_texcoord_vector3" target="genglsl" />

  <!-- <geomcolor> -->
  <implementation name="IM_geomcolor_float_genglsl" nodedef="ND_geomcolor_float" target="genglsl" />
  <implementation name="IM_geomcolor_color3_genglsl" nodedef="ND_geomcolor_color3" target="genglsl" />
  <implementation name="IM_geomcolor_color4_genglsl" nodedef="ND_geomcolor_color4" target="genglsl" />

  <!-- <geompropvalue> -->
  <implementation name="IM_geompropvalue_integer_genglsl" nodedef="ND_geompropvalue_integer" function="mx_geompropvalue_int" target="genglsl" />
  <implementation name="IM_geompropvalue_boolean_genglsl" nodedef="ND_geompropvalue_boolean" function="mx_geompropvalue_bool" target="genglsl" />
  <implementation name="IM_geompropvalue_string_genglsl" nodedef="ND_geompropvalue_string" function="mx_geompropvalue_string" target="genglsl" />
  <implementation name="IM_geompropvalue_float_genglsl" nodedef="ND_geompropvalue_float" function="mx_geompropvalue_float" target="genglsl" />
  <implementation name="IM_geompropvalue_color3_genglsl" nodedef="ND_geompropvalue_color3" function="mx_geompropvalue_color" target="genglsl" />
  <implementation name="IM_geompropvalue_color4_genglsl" nodedef="ND_geompropvalue_color4" function="mx_geompropvalue_color4" target="genglsl" />
  <implementation name="IM_geompropvalue_vector2_genglsl" nodedef="ND_geompropvalue_vector2" function="mx_geompropvalue_vector2" target="genglsl" />
  <implementation name="IM_geompropvalue_vector3_genglsl" nodedef="ND_geompropvalue_vector3" function="mx_geompropvalue_vector" target="genglsl" />
  <implementation name="IM_geompropvalue_vector4_genglsl" nodedef="ND_geompropvalue_vector4" function="mx_geompropvalue_vector4" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Application nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <frame> -->

  <implementation name="IM_frame_float_genglsl" nodedef="ND_frame_float" function="mx_frame_float" target="genglsl" />

  <!-- <time> -->
  <implementation name="IM_time_float_genglsl" nodedef="ND_time_float" function="mx_time_float" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Math nodes                                                               -->
  <!-- ======================================================================== -->

  <!-- <add> -->
  <implementation name="IM_add_float_genglsl" nodedef="ND_add_float" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_color3_genglsl" nodedef="ND_add_color3" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_color3FA_genglsl" nodedef="ND_add_color3FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_color4_genglsl" nodedef="ND_add_color4" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_color4FA_genglsl" nodedef="ND_add_color4FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector2_genglsl" nodedef="ND_add_vector2" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector2FA_genglsl" nodedef="ND_add_vector2FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector3_genglsl" nodedef="ND_add_vector3" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector3FA_genglsl" nodedef="ND_add_vector3FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector4_genglsl" nodedef="ND_add_vector4" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_vector4FA_genglsl" nodedef="ND_add_vector4FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_matrix33_genglsl" nodedef="ND_add_matrix33" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_matrix33FA_genglsl" nodedef="ND_add_matrix33FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_matrix44_genglsl" nodedef="ND_add_matrix44" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_matrix44FA_genglsl" nodedef="ND_add_matrix44FA" file="stdlib/genglsl/mx_add.inline" target="genglsl" />
  <implementation name="IM_add_surfaceshader_genglsl" nodedef="ND_add_surfaceshader" function="mx_add_surfaceshader" file="stdlib/genglsl/mx_add_surfaceshader.glsl" target="genglsl" />

  <!-- <subtract> -->
  <implementation name="IM_subtract_float_genglsl" nodedef="ND_subtract_float" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_color3_genglsl" nodedef="ND_subtract_color3" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_color3FA_genglsl" nodedef="ND_subtract_color3FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_color4_genglsl" nodedef="ND_subtract_color4" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_color4FA_genglsl" nodedef="ND_subtract_color4FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector2_genglsl" nodedef="ND_subtract_vector2" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector2FA_genglsl" nodedef="ND_subtract_vector2FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector3_genglsl" nodedef="ND_subtract_vector3" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector3FA_genglsl" nodedef="ND_subtract_vector3FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector4_genglsl" nodedef="ND_subtract_vector4" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_vector4FA_genglsl" nodedef="ND_subtract_vector4FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_matrix33_genglsl" nodedef="ND_subtract_matrix33" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_matrix33FA_genglsl" nodedef="ND_subtract_matrix33FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_matrix44_genglsl" nodedef="ND_subtract_matrix44" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />
  <implementation name="IM_subtract_matrix44FA_genglsl" nodedef="ND_subtract_matrix44FA" file="stdlib/genglsl/mx_subtract.inline" target="genglsl" />

  <!-- <multiply> -->
  <implementation name="IM_multiply_float_genglsl" nodedef="ND_multiply_float" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_color3_genglsl" nodedef="ND_multiply_color3" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_color3FA_genglsl" nodedef="ND_multiply_color3FA" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_color4_genglsl" nodedef="ND_multiply_color4" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_color4FA_genglsl" nodedef="ND_multiply_color4FA" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector2_genglsl" nodedef="ND_multiply_vector2" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector2FA_genglsl" nodedef="ND_multiply_vector2FA" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector3_genglsl" nodedef="ND_multiply_vector3" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector3FA_genglsl" nodedef="ND_multiply_vector3FA" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector4_genglsl" nodedef="ND_multiply_vector4" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_vector4FA_genglsl" nodedef="ND_multiply_vector4FA" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_matrix33_genglsl" nodedef="ND_multiply_matrix33" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_matrix44_genglsl" nodedef="ND_multiply_matrix44" file="stdlib/genglsl/mx_multiply.inline" target="genglsl" />
  <implementation name="IM_multiply_surfaceshaderF_genglsl" nodedef="ND_multiply_surfaceshaderF" function="mx_multiply_surfaceshader_float" file="stdlib/genglsl/mx_multiply_surfaceshader_float.glsl" target="genglsl" />
  <implementation name="IM_multiply_surfaceshaderC_genglsl" nodedef="ND_multiply_surfaceshaderC" function="mx_multiply_surfaceshader_color3" file="stdlib/genglsl/mx_multiply_surfaceshader_color3.glsl" target="genglsl" />

  <!-- <divide> -->
  <implementation name="IM_divide_float_genglsl" nodedef="ND_divide_float" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_color3_genglsl" nodedef="ND_divide_color3" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_color3FA_genglsl" nodedef="ND_divide_color3FA" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_color4_genglsl" nodedef="ND_divide_color4" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_color4FA_genglsl" nodedef="ND_divide_color4FA" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector2_genglsl" nodedef="ND_divide_vector2" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector2FA_genglsl" nodedef="ND_divide_vector2FA" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector3_genglsl" nodedef="ND_divide_vector3" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector3FA_genglsl" nodedef="ND_divide_vector3FA" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector4_genglsl" nodedef="ND_divide_vector4" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_vector4FA_genglsl" nodedef="ND_divide_vector4FA" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_matrix33_genglsl" nodedef="ND_divide_matrix33" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />
  <implementation name="IM_divide_matrix44_genglsl" nodedef="ND_divide_matrix44" file="stdlib/genglsl/mx_divide.inline" target="genglsl" />

  <!-- <modulo> -->
  <implementation name="IM_modulo_float_genglsl" nodedef="ND_modulo_float" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_color3_genglsl" nodedef="ND_modulo_color3" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_color3FA_genglsl" nodedef="ND_modulo_color3FA" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_color4_genglsl" nodedef="ND_modulo_color4" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_color4FA_genglsl" nodedef="ND_modulo_color4FA" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector2_genglsl" nodedef="ND_modulo_vector2" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector2FA_genglsl" nodedef="ND_modulo_vector2FA" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector3_genglsl" nodedef="ND_modulo_vector3" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector3FA_genglsl" nodedef="ND_modulo_vector3FA" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector4_genglsl" nodedef="ND_modulo_vector4" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />
  <implementation name="IM_modulo_vector4FA_genglsl" nodedef="ND_modulo_vector4FA" file="stdlib/genglsl/mx_modulo.inline" target="genglsl" />

  <!-- <invert> -->
  <implementation name="IM_invert_float_genglsl" nodedef="ND_invert_float" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_color3_genglsl" nodedef="ND_invert_color3" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_color3FA_genglsl" nodedef="ND_invert_color3FA" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_color4_genglsl" nodedef="ND_invert_color4" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_color4FA_genglsl" nodedef="ND_invert_color4FA" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector2_genglsl" nodedef="ND_invert_vector2" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector2FA_genglsl" nodedef="ND_invert_vector2FA" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector3_genglsl" nodedef="ND_invert_vector3" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector3FA_genglsl" nodedef="ND_invert_vector3FA" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector4_genglsl" nodedef="ND_invert_vector4" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />
  <implementation name="IM_invert_vector4FA_genglsl" nodedef="ND_invert_vector4FA" file="stdlib/genglsl/mx_invert.inline" target="genglsl" />

  <!-- <absval> -->
  <implementation name="IM_absval_float_genglsl" nodedef="ND_absval_float" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />
  <implementation name="IM_absval_color3_genglsl" nodedef="ND_absval_color3" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />
  <implementation name="IM_absval_color4_genglsl" nodedef="ND_absval_color4" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />
  <implementation name="IM_absval_vector2_genglsl" nodedef="ND_absval_vector2" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />
  <implementation name="IM_absval_vector3_genglsl" nodedef="ND_absval_vector3" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />
  <implementation name="IM_absval_vector4_genglsl" nodedef="ND_absval_vector4" file="stdlib/genglsl/mx_absval.inline" target="genglsl" />

  <!-- <floor> -->
  <implementation name="IM_floor_float_genglsl" nodedef="ND_floor_float" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <implementation name="IM_floor_color3_genglsl" nodedef="ND_floor_color3" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <implementation name="IM_floor_color4_genglsl" nodedef="ND_floor_color4" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <implementation name="IM_floor_vector2_genglsl" nodedef="ND_floor_vector2" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <implementation name="IM_floor_vector3_genglsl" nodedef="ND_floor_vector3" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <implementation name="IM_floor_vector4_genglsl" nodedef="ND_floor_vector4" file="stdlib/genglsl/mx_floor.inline" target="genglsl" />
  <!-- <ceil> -->
  <implementation name="IM_ceil_float_genglsl" nodedef="ND_ceil_float" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />
  <implementation name="IM_ceil_color3_genglsl" nodedef="ND_ceil_color3" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />
  <implementation name="IM_ceil_color4_genglsl" nodedef="ND_ceil_color4" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />
  <implementation name="IM_ceil_vector2_genglsl" nodedef="ND_ceil_vector2" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />
  <implementation name="IM_ceil_vector3_genglsl" nodedef="ND_ceil_vector3" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />
  <implementation name="IM_ceil_vector4_genglsl" nodedef="ND_ceil_vector4" file="stdlib/genglsl/mx_ceil.inline" target="genglsl" />

  <!-- <power> -->
  <implementation name="IM_power_float_genglsl" nodedef="ND_power_float" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_color3_genglsl" nodedef="ND_power_color3" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_color3FA_genglsl" nodedef="ND_power_color3FA" file="stdlib/genglsl/mx_power_color3_float.inline" target="genglsl" />
  <implementation name="IM_power_color4_genglsl" nodedef="ND_power_color4" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_color4FA_genglsl" nodedef="ND_power_color4FA" file="stdlib/genglsl/mx_power_color4_float.inline" target="genglsl" />
  <implementation name="IM_power_vector2_genglsl" nodedef="ND_power_vector2" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_vector2FA_genglsl" nodedef="ND_power_vector2FA" file="stdlib/genglsl/mx_power_vector2_float.inline" target="genglsl" />
  <implementation name="IM_power_vector3_genglsl" nodedef="ND_power_vector3" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_vector3FA_genglsl" nodedef="ND_power_vector3FA" file="stdlib/genglsl/mx_power_vector3_float.inline" target="genglsl" />
  <implementation name="IM_power_vector4_genglsl" nodedef="ND_power_vector4" file="stdlib/genglsl/mx_power.inline" target="genglsl" />
  <implementation name="IM_power_vector4FA_genglsl" nodedef="ND_power_vector4FA" file="stdlib/genglsl/mx_power_vector4_float.inline" target="genglsl" />

  <!-- <sin>, <cos>, <tan>, <asin>, <acos>, <atan2> -->
  <implementation name="IM_sin_float_genglsl" nodedef="ND_sin_float" file="stdlib/genglsl/mx_sin.inline" target="genglsl" />
  <implementation name="IM_cos_float_genglsl" nodedef="ND_cos_float" file="stdlib/genglsl/mx_cos.inline" target="genglsl" />
  <implementation name="IM_tan_float_genglsl" nodedef="ND_tan_float" file="stdlib/genglsl/mx_tan.inline" target="genglsl" />
  <implementation name="IM_asin_float_genglsl" nodedef="ND_asin_float" file="stdlib/genglsl/mx_asin.inline" target="genglsl" />
  <implementation name="IM_acos_float_genglsl" nodedef="ND_acos_float" file="stdlib/genglsl/mx_acos.inline" target="genglsl" />
  <implementation name="IM_atan2_float_genglsl" nodedef="ND_atan2_float" file="stdlib/genglsl/mx_atan2.inline" target="genglsl" />
  <implementation name="IM_sin_vector2_genglsl" nodedef="ND_sin_vector2" file="stdlib/genglsl/mx_sin.inline" target="genglsl" />
  <implementation name="IM_cos_vector2_genglsl" nodedef="ND_cos_vector2" file="stdlib/genglsl/mx_cos.inline" target="genglsl" />
  <implementation name="IM_tan_vector2_genglsl" nodedef="ND_tan_vector2" file="stdlib/genglsl/mx_tan.inline" target="genglsl" />
  <implementation name="IM_asin_vector2_genglsl" nodedef="ND_asin_vector2" file="stdlib/genglsl/mx_asin.inline" target="genglsl" />
  <implementation name="IM_acos_vector2_genglsl" nodedef="ND_acos_vector2" file="stdlib/genglsl/mx_acos.inline" target="genglsl" />
  <implementation name="IM_atan2_vector2_genglsl" nodedef="ND_atan2_vector2" file="stdlib/genglsl/mx_atan2.inline" target="genglsl" />
  <implementation name="IM_sin_vector3_genglsl" nodedef="ND_sin_vector3" file="stdlib/genglsl/mx_sin.inline" target="genglsl" />
  <implementation name="IM_cos_vector3_genglsl" nodedef="ND_cos_vector3" file="stdlib/genglsl/mx_cos.inline" target="genglsl" />
  <implementation name="IM_tan_vector3_genglsl" nodedef="ND_tan_vector3" file="stdlib/genglsl/mx_tan.inline" target="genglsl" />
  <implementation name="IM_asin_vector3_genglsl" nodedef="ND_asin_vector3" file="stdlib/genglsl/mx_asin.inline" target="genglsl" />
  <implementation name="IM_acos_vector3_genglsl" nodedef="ND_acos_vector3" file="stdlib/genglsl/mx_acos.inline" target="genglsl" />
  <implementation name="IM_atan2_vector3_genglsl" nodedef="ND_atan2_vector3" file="stdlib/genglsl/mx_atan2.inline" target="genglsl" />
  <implementation name="IM_sin_vector4_genglsl" nodedef="ND_sin_vector4" file="stdlib/genglsl/mx_sin.inline" target="genglsl" />
  <implementation name="IM_cos_vector4_genglsl" nodedef="ND_cos_vector4" file="stdlib/genglsl/mx_cos.inline" target="genglsl" />
  <implementation name="IM_tan_vector4_genglsl" nodedef="ND_tan_vector4" file="stdlib/genglsl/mx_tan.inline" target="genglsl" />
  <implementation name="IM_asin_vector4_genglsl" nodedef="ND_asin_vector4" file="stdlib/genglsl/mx_asin.inline" target="genglsl" />
  <implementation name="IM_acos_vector4_genglsl" nodedef="ND_acos_vector4" file="stdlib/genglsl/mx_acos.inline" target="genglsl" />
  <implementation name="IM_atan2_vector4_genglsl" nodedef="ND_atan2_vector4" file="stdlib/genglsl/mx_atan2.inline" target="genglsl" />

  <!-- <sqrt> -->
  <implementation name="IM_sqrt_float_genglsl" nodedef="ND_sqrt_float" file="stdlib/genglsl/mx_sqrt.inline" target="genglsl" />
  <implementation name="IM_sqrt_vector2_genglsl" nodedef="ND_sqrt_vector2" file="stdlib/genglsl/mx_sqrt.inline" target="genglsl" />
  <implementation name="IM_sqrt_vector3_genglsl" nodedef="ND_sqrt_vector3" file="stdlib/genglsl/mx_sqrt.inline" target="genglsl" />
  <implementation name="IM_sqrt_vector4_genglsl" nodedef="ND_sqrt_vector4" file="stdlib/genglsl/mx_sqrt.inline" target="genglsl" />

  <!-- <ln> -->
  <implementation name="IM_ln_float_genglsl" nodedef="ND_ln_float" file="stdlib/genglsl/mx_ln.inline" target="genglsl" />
  <implementation name="IM_ln_vector2_genglsl" nodedef="ND_ln_vector2" file="stdlib/genglsl/mx_ln.inline" target="genglsl" />
  <implementation name="IM_ln_vector3_genglsl" nodedef="ND_ln_vector3" file="stdlib/genglsl/mx_ln.inline" target="genglsl" />
  <implementation name="IM_ln_vector4_genglsl" nodedef="ND_ln_vector4" file="stdlib/genglsl/mx_ln.inline" target="genglsl" />

  <!-- <exp> -->
  <implementation name="IM_exp_float_genglsl" nodedef="ND_exp_float" file="stdlib/genglsl/mx_exp.inline" target="genglsl" />
  <implementation name="IM_exp_vector2_genglsl" nodedef="ND_exp_vector2" file="stdlib/genglsl/mx_exp.inline" target="genglsl" />
  <implementation name="IM_exp_vector3_genglsl" nodedef="ND_exp_vector3" file="stdlib/genglsl/mx_exp.inline" target="genglsl" />
  <implementation name="IM_exp_vector4_genglsl" nodedef="ND_exp_vector4" file="stdlib/genglsl/mx_exp.inline" target="genglsl" />

  <!-- sign -->
  <implementation name="IM_sign_float_genglsl" nodedef="ND_sign_float" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />
  <implementation name="IM_sign_color3_genglsl" nodedef="ND_sign_color3" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />
  <implementation name="IM_sign_color4_genglsl" nodedef="ND_sign_color4" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />
  <implementation name="IM_sign_vector2_genglsl" nodedef="ND_sign_vector2" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />
  <implementation name="IM_sign_vector3_genglsl" nodedef="ND_sign_vector3" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />
  <implementation name="IM_sign_vector4_genglsl" nodedef="ND_sign_vector4" file="stdlib/genglsl/mx_sign.inline" target="genglsl" />

  <!-- <clamp> -->
  <implementation name="IM_clamp_float_genglsl" nodedef="ND_clamp_float" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_color3_genglsl" nodedef="ND_clamp_color3" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_color3FA_genglsl" nodedef="ND_clamp_color3FA" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_color4_genglsl" nodedef="ND_clamp_color4" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_color4FA_genglsl" nodedef="ND_clamp_color4FA" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector2_genglsl" nodedef="ND_clamp_vector2" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector2FA_genglsl" nodedef="ND_clamp_vector2FA" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector3_genglsl" nodedef="ND_clamp_vector3" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector3FA_genglsl" nodedef="ND_clamp_vector3FA" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector4_genglsl" nodedef="ND_clamp_vector4" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />
  <implementation name="IM_clamp_vector4FA_genglsl" nodedef="ND_clamp_vector4FA" file="stdlib/genglsl/mx_clamp.inline" target="genglsl" />

  <!-- <min> -->
  <implementation name="IM_min_float_genglsl" nodedef="ND_min_float" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_color3_genglsl" nodedef="ND_min_color3" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_color3FA_genglsl" nodedef="ND_min_color3FA" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_color4_genglsl" nodedef="ND_min_color4" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_color4FA_genglsl" nodedef="ND_min_color4FA" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector2_genglsl" nodedef="ND_min_vector2" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector2FA_genglsl" nodedef="ND_min_vector2FA" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector3_genglsl" nodedef="ND_min_vector3" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector3FA_genglsl" nodedef="ND_min_vector3FA" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector4_genglsl" nodedef="ND_min_vector4" file="stdlib/genglsl/mx_min.inline" target="genglsl" />
  <implementation name="IM_min_vector4FA_genglsl" nodedef="ND_min_vector4FA" file="stdlib/genglsl/mx_min.inline" target="genglsl" />

  <!-- <max> -->
  <implementation name="IM_max_float_genglsl" nodedef="ND_max_float" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_color3_genglsl" nodedef="ND_max_color3" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_color3FA_genglsl" nodedef="ND_max_color3FA" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_color4_genglsl" nodedef="ND_max_color4" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_color4FA_genglsl" nodedef="ND_max_color4FA" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector2_genglsl" nodedef="ND_max_vector2" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector2FA_genglsl" nodedef="ND_max_vector2FA" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector3_genglsl" nodedef="ND_max_vector3" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector3FA_genglsl" nodedef="ND_max_vector3FA" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector4_genglsl" nodedef="ND_max_vector4" file="stdlib/genglsl/mx_max.inline" target="genglsl" />
  <implementation name="IM_max_vector4FA_genglsl" nodedef="ND_max_vector4FA" file="stdlib/genglsl/mx_max.inline" target="genglsl" />

  <!-- <normalize> -->
  <implementation name="IM_normalize_vector2_genglsl" nodedef="ND_normalize_vector2" file="stdlib/genglsl/mx_normalize.inline" target="genglsl" />
  <implementation name="IM_normalize_vector3_genglsl" nodedef="ND_normalize_vector3" file="stdlib/genglsl/mx_normalize.inline" target="genglsl" />
  <implementation name="IM_normalize_vector4_genglsl" nodedef="ND_normalize_vector4" file="stdlib/genglsl/mx_normalize.inline" target="genglsl" />

  <!-- <magnitude> -->
  <implementation name="IM_magnitude_vector2_genglsl" nodedef="ND_magnitude_vector2" file="stdlib/genglsl/mx_magnitude.inline" target="genglsl" />
  <implementation name="IM_magnitude_vector3_genglsl" nodedef="ND_magnitude_vector3" file="stdlib/genglsl/mx_magnitude.inline" target="genglsl" />
  <implementation name="IM_magnitude_vector4_genglsl" nodedef="ND_magnitude_vector4" file="stdlib/genglsl/mx_magnitude.inline" target="genglsl" />

  <!-- <dotproduct> -->
  <implementation name="IM_dotproduct_vector2_genglsl" nodedef="ND_dotproduct_vector2" file="stdlib/genglsl/mx_dotproduct.inline" target="genglsl" />
  <implementation name="IM_dotproduct_vector3_genglsl" nodedef="ND_dotproduct_vector3" file="stdlib/genglsl/mx_dotproduct.inline" target="genglsl" />
  <implementation name="IM_dotproduct_vector4_genglsl" nodedef="ND_dotproduct_vector4" file="stdlib/genglsl/mx_dotproduct.inline" target="genglsl" />

  <!-- <crossproduct> -->
  <implementation name="IM_crossproduct_vector3_genglsl" nodedef="ND_crossproduct_vector3" file="stdlib/genglsl/mx_crossproduct.inline" target="genglsl" />

  <!-- <transformpoint> -->
  <implementation name="IM_transformpoint_vector3_genglsl" nodedef="ND_transformpoint_vector3" target="genglsl" />

  <!-- <transformvector> -->
  <implementation name="IM_transformvector_vector3_genglsl" nodedef="ND_transformvector_vector3" target="genglsl" />

  <!-- <transformnormal> -->
  <implementation name="IM_transformnormal_vector3_genglsl" nodedef="ND_transformnormal_vector3" target="genglsl" />

  <!-- <transformmatrix> -->
  <implementation name="IM_transformmatrix_vector2M3_genglsl" nodedef="ND_transformmatrix_vector2M3" function="mx_transformmatrix_vector2M3" file="stdlib/genglsl/mx_transformmatrix_vector2M3.glsl" target="genglsl" />
  <implementation name="IM_transformmatrix_vector3_genglsl" nodedef="ND_transformmatrix_vector3" file="stdlib/genglsl/mx_transformmatrix.inline" target="genglsl" />
  <implementation name="IM_transformmatrix_vector3M4_genglsl" nodedef="ND_transformmatrix_vector3M4" function="mx_transformmatrix_vector3M4" file="stdlib/genglsl/mx_transformmatrix_vector3M4.glsl" target="genglsl" />
  <implementation name="IM_transformmatrix_vector4_genglsl" nodedef="ND_transformmatrix_vector4" file="stdlib/genglsl/mx_transformmatrix.inline" target="genglsl" />

  <!-- <transpose> -->
  <implementation name="IM_transpose_matrix33_genglsl" nodedef="ND_transpose_matrix33" file="stdlib/genglsl/mx_transpose.inline" target="genglsl" />
  <implementation name="IM_transpose_matrix44_genglsl" nodedef="ND_transpose_matrix44" file="stdlib/genglsl/mx_transpose.inline" target="genglsl" />

  <!-- <determinant> -->
  <implementation name="IM_determinant_matrix33_genglsl" nodedef="ND_determinant_matrix33" file="stdlib/genglsl/mx_determinant.inline" target="genglsl" />
  <implementation name="IM_determinant_matrix44_genglsl" nodedef="ND_determinant_matrix44" file="stdlib/genglsl/mx_determinant.inline" target="genglsl" />

  <!-- <invertmatrix> -->
  <implementation name="IM_invertmatrix_matrix33_genglsl" nodedef="ND_invertmatrix_matrix33" file="stdlib/genglsl/mx_invertM.inline" target="genglsl" />
  <implementation name="IM_invertmatrix_matrix44_genglsl" nodedef="ND_invertmatrix_matrix44" file="stdlib/genglsl/mx_invertM.inline" target="genglsl" />

  <!-- <rotate2d> -->
  <implementation name="IM_rotate2d_vector2_genglsl" nodedef="ND_rotate2d_vector2" file="stdlib/genglsl/mx_rotate_vector2.glsl" function="mx_rotate_vector2" target="genglsl" />

  <!-- <rotate3d> -->
  <implementation name="IM_rotate3d_vector3_genglsl" nodedef="ND_rotate3d_vector3" file="stdlib/genglsl/mx_rotate_vector3.glsl" function="mx_rotate_vector3" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Adjustment nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <contrast> -->

  <!-- <remap> -->
  <implementation name="IM_remap_float_genglsl" nodedef="ND_remap_float" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_color3_genglsl" nodedef="ND_remap_color3" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_color3FA_genglsl" nodedef="ND_remap_color3FA" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_color4_genglsl" nodedef="ND_remap_color4" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_color4FA_genglsl" nodedef="ND_remap_color4FA" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector2_genglsl" nodedef="ND_remap_vector2" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector2FA_genglsl" nodedef="ND_remap_vector2FA" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector3_genglsl" nodedef="ND_remap_vector3" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector3FA_genglsl" nodedef="ND_remap_vector3FA" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector4_genglsl" nodedef="ND_remap_vector4" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />
  <implementation name="IM_remap_vector4FA_genglsl" nodedef="ND_remap_vector4FA" file="stdlib/genglsl/mx_remap.inline" target="genglsl" />

  <!-- <smoothstep> -->
  <implementation name="IM_smoothstep_float_genglsl" nodedef="ND_smoothstep_float" file="stdlib/genglsl/mx_smoothstep_float.glsl" function="mx_smoothstep_float" target="genglsl" />
  <implementation name="IM_smoothstep_color3_genglsl" nodedef="ND_smoothstep_color3" file="stdlib/genglsl/mx_smoothstep_vec3.glsl" function="mx_smoothstep_vec3" target="genglsl" />
  <implementation name="IM_smoothstep_color3FA_genglsl" nodedef="ND_smoothstep_color3FA" file="stdlib/genglsl/mx_smoothstep_vec3FA.glsl" function="mx_smoothstep_vec3FA" target="genglsl" />
  <implementation name="IM_smoothstep_color4_genglsl" nodedef="ND_smoothstep_color4" file="stdlib/genglsl/mx_smoothstep_vec4.glsl" function="mx_smoothstep_vec4" target="genglsl" />
  <implementation name="IM_smoothstep_color4FA_genglsl" nodedef="ND_smoothstep_color4FA" file="stdlib/genglsl/mx_smoothstep_vec4FA.glsl" function="mx_smoothstep_vec4FA" target="genglsl" />
  <implementation name="IM_smoothstep_vector2_genglsl" nodedef="ND_smoothstep_vector2" file="stdlib/genglsl/mx_smoothstep_vec2.glsl" function="mx_smoothstep_vec2" target="genglsl" />
  <implementation name="IM_smoothstep_vector2FA_genglsl" nodedef="ND_smoothstep_vector2FA" file="stdlib/genglsl/mx_smoothstep_vec2FA.glsl" function="mx_smoothstep_vec2FA" target="genglsl" />
  <implementation name="IM_smoothstep_vector3_genglsl" nodedef="ND_smoothstep_vector3" file="stdlib/genglsl/mx_smoothstep_vec3.glsl" function="mx_smoothstep_vec3" target="genglsl" />
  <implementation name="IM_smoothstep_vector3FA_genglsl" nodedef="ND_smoothstep_vector3FA" file="stdlib/genglsl/mx_smoothstep_vec3FA.glsl" function="mx_smoothstep_vec3FA" target="genglsl" />
  <implementation name="IM_smoothstep_vector4_genglsl" nodedef="ND_smoothstep_vector4" file="stdlib/genglsl/mx_smoothstep_vec4.glsl" function="mx_smoothstep_vec4" target="genglsl" />
  <implementation name="IM_smoothstep_vector4FA_genglsl" nodedef="ND_smoothstep_vector4FA" file="stdlib/genglsl/mx_smoothstep_vec4FA.glsl" function="mx_smoothstep_vec4FA" target="genglsl" />

  <!-- <luminance> -->
  <implementation name="IM_luminance_color3_genglsl" nodedef="ND_luminance_color3" file="stdlib/genglsl/mx_luminance_color3.glsl" function="mx_luminance_color3" target="genglsl" />
  <implementation name="IM_luminance_color4_genglsl" nodedef="ND_luminance_color4" file="stdlib/genglsl/mx_luminance_color4.glsl" function="mx_luminance_color4" target="genglsl" />

  <!-- <rgbtohsv> -->
  <implementation name="IM_rgbtohsv_color3_genglsl" nodedef="ND_rgbtohsv_color3" file="stdlib/genglsl/mx_rgbtohsv_color3.glsl" function="mx_rgbtohsv_color3" target="genglsl" />
  <implementation name="IM_rgbtohsv_color4_genglsl" nodedef="ND_rgbtohsv_color4" file="stdlib/genglsl/mx_rgbtohsv_color4.glsl" function="mx_rgbtohsv_color4" target="genglsl" />

  <!-- <hsvtorgb> -->
  <implementation name="IM_hsvtorgb_color3_genglsl" nodedef="ND_hsvtorgb_color3" file="stdlib/genglsl/mx_hsvtorgb_color3.glsl" function="mx_hsvtorgb_color3" target="genglsl" />
  <implementation name="IM_hsvtorgb_color4_genglsl" nodedef="ND_hsvtorgb_color4" file="stdlib/genglsl/mx_hsvtorgb_color4.glsl" function="mx_hsvtorgb_color4" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Compositing nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <premult> -->
  <implementation name="IM_premult_color4_genglsl" nodedef="ND_premult_color4" file="stdlib/genglsl/mx_premult_color4.glsl" function="mx_premult_color4" target="genglsl" />

  <!-- <unpremult> -->
  <implementation name="IM_unpremult_color4_genglsl" nodedef="ND_unpremult_color4" file="stdlib/genglsl/mx_unpremult_color4.glsl" function="mx_unpremult_color4" target="genglsl" />

  <!-- <plus> -->
  <implementation name="IM_plus_float_genglsl" nodedef="ND_plus_float" file="stdlib/genglsl/mx_plus.inline" target="genglsl" />
  <implementation name="IM_plus_color3_genglsl" nodedef="ND_plus_color3" file="stdlib/genglsl/mx_plus.inline" target="genglsl" />
  <implementation name="IM_plus_color4_genglsl" nodedef="ND_plus_color4" file="stdlib/genglsl/mx_plus.inline" target="genglsl" />

  <!-- <minus> -->
  <implementation name="IM_minus_float_genglsl" nodedef="ND_minus_float" file="stdlib/genglsl/mx_minus.inline" target="genglsl" />
  <implementation name="IM_minus_color3_genglsl" nodedef="ND_minus_color3" file="stdlib/genglsl/mx_minus.inline" target="genglsl" />
  <implementation name="IM_minus_color4_genglsl" nodedef="ND_minus_color4" file="stdlib/genglsl/mx_minus.inline" target="genglsl" />

  <!-- <difference> -->
  <implementation name="IM_difference_float_genglsl" nodedef="ND_difference_float" file="stdlib/genglsl/mx_difference.inline" target="genglsl" />
  <implementation name="IM_difference_color3_genglsl" nodedef="ND_difference_color3" file="stdlib/genglsl/mx_difference.inline" target="genglsl" />
  <implementation name="IM_difference_color4_genglsl" nodedef="ND_difference_color4" file="stdlib/genglsl/mx_difference.inline" target="genglsl" />

  <!-- <burn> -->
  <implementation name="IM_burn_float_genglsl" nodedef="ND_burn_float" file="stdlib/genglsl/mx_burn_float.glsl" function="mx_burn_float" target="genglsl" />
  <implementation name="IM_burn_color3_genglsl" nodedef="ND_burn_color3" file="stdlib/genglsl/mx_burn_color3.glsl" function="mx_burn_color3" target="genglsl" />
  <implementation name="IM_burn_color4_genglsl" nodedef="ND_burn_color4" file="stdlib/genglsl/mx_burn_color4.glsl" function="mx_burn_color4" target="genglsl" />

  <!-- <dodge> -->
  <implementation name="IM_dodge_float_genglsl" nodedef="ND_dodge_float" file="stdlib/genglsl/mx_dodge_float.glsl" function="mx_dodge_float" target="genglsl" />
  <implementation name="IM_dodge_color3_genglsl" nodedef="ND_dodge_color3" file="stdlib/genglsl/mx_dodge_color3.glsl" function="mx_dodge_color3" target="genglsl" />
  <implementation name="IM_dodge_color4_genglsl" nodedef="ND_dodge_color4" file="stdlib/genglsl/mx_dodge_color4.glsl" function="mx_dodge_color4" target="genglsl" />

  <!-- <screen> -->
  <implementation name="IM_screen_float_genglsl" nodedef="ND_screen_float" file="stdlib/genglsl/mx_screen.inline" target="genglsl" />
  <implementation name="IM_screen_color3_genglsl" nodedef="ND_screen_color3" file="stdlib/genglsl/mx_screen.inline" target="genglsl" />
  <implementation name="IM_screen_color4_genglsl" nodedef="ND_screen_color4" file="stdlib/genglsl/mx_screen.inline" target="genglsl" />

  <!-- <overlay> -->
  <implementation name="IM_overlay_float_genglsl" nodedef="ND_overlay_float" file="stdlib/genglsl/mx_overlay_float.inline" target="genglsl" />
  <implementation name="IM_overlay_color3_genglsl" nodedef="ND_overlay_color3" file="stdlib/genglsl/mx_overlay_color3.glsl" function="mx_overlay_color3" target="genglsl" />
  <implementation name="IM_overlay_color4_genglsl" nodedef="ND_overlay_color4" file="stdlib/genglsl/mx_overlay_color4.glsl" function="mx_overlay_color4" target="genglsl" />

  <!-- <disjointover> -->
  <implementation name="IM_disjointover_color4_genglsl" nodedef="ND_disjointover_color4" file="stdlib/genglsl/mx_disjointover_color4.glsl" function="mx_disjointover_color4" target="genglsl" />

  <!-- <in> -->
  <implementation name="IM_in_color4_genglsl" nodedef="ND_in_color4" file="stdlib/genglsl/mx_in_color4.inline" target="genglsl" />

  <!-- <mask> -->
  <implementation name="IM_mask_color4_genglsl" nodedef="ND_mask_color4" file="stdlib/genglsl/mx_mask_color4.inline" target="genglsl" />

  <!-- <matte> -->
  <implementation name="IM_matte_color4_genglsl" nodedef="ND_matte_color4" file="stdlib/genglsl/mx_matte_color4.inline" target="genglsl" />

  <!-- <out> -->
  <implementation name="IM_out_color4_genglsl" nodedef="ND_out_color4" file="stdlib/genglsl/mx_out_color4.inline" target="genglsl" />

  <!-- <over> -->
  <implementation name="IM_over_color4_genglsl" nodedef="ND_over_color4" file="stdlib/genglsl/mx_over_color4.inline" target="genglsl" />

  <!-- <inside> -->
  <implementation name="IM_inside_float_genglsl" nodedef="ND_inside_float" file="stdlib/genglsl/mx_inside.inline" target="genglsl" />
  <implementation name="IM_inside_color3_genglsl" nodedef="ND_inside_color3" file="stdlib/genglsl/mx_inside.inline" target="genglsl" />
  <implementation name="IM_inside_color4_genglsl" nodedef="ND_inside_color4" file="stdlib/genglsl/mx_inside.inline" target="genglsl" />

  <!-- <outside> -->
  <implementation name="IM_outside_float_genglsl" nodedef="ND_outside_float" file="stdlib/genglsl/mx_outside.inline" target="genglsl" />
  <implementation name="IM_outside_color3_genglsl" nodedef="ND_outside_color3" file="stdlib/genglsl/mx_outside.inline" target="genglsl" />
  <implementation name="IM_outside_color4_genglsl" nodedef="ND_outside_color4" file="stdlib/genglsl/mx_outside.inline" target="genglsl" />

  <!-- <mix> -->
  <implementation name="IM_mix_float_genglsl" nodedef="ND_mix_float" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_color3_genglsl" nodedef="ND_mix_color3" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_color4_genglsl" nodedef="ND_mix_color4" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_vector2_genglsl" nodedef="ND_mix_vector2" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_vector3_genglsl" nodedef="ND_mix_vector3" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_vector4_genglsl" nodedef="ND_mix_vector4" file="stdlib/genglsl/mx_mix.inline" target="genglsl" />
  <implementation name="IM_mix_surfaceshader_genglsl" nodedef="ND_mix_surfaceshader" function="mx_mix_surfaceshader" file="stdlib/genglsl/mx_mix_surfaceshader.glsl" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Conditional nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <ifgreater -->
  <implementation name="IM_ifgreater_float_genglsl" nodedef="ND_ifgreater_float" target="genglsl" />
  <implementation name="IM_ifgreater_color3_genglsl" nodedef="ND_ifgreater_color3" target="genglsl" />
  <implementation name="IM_ifgreater_color4_genglsl" nodedef="ND_ifgreater_color4" target="genglsl" />
  <implementation name="IM_ifgreater_vector2_genglsl" nodedef="ND_ifgreater_vector2" target="genglsl" />
  <implementation name="IM_ifgreater_vector3_genglsl" nodedef="ND_ifgreater_vector3" target="genglsl" />
  <implementation name="IM_ifgreater_vector4_genglsl" nodedef="ND_ifgreater_vector4" target="genglsl" />
  <implementation name="IM_ifgreater_floatI_genglsl" nodedef="ND_ifgreater_floatI" target="genglsl" />
  <implementation name="IM_ifgreater_color3I_genglsl" nodedef="ND_ifgreater_color3I" target="genglsl" />
  <implementation name="IM_ifgreater_color4I_genglsl" nodedef="ND_ifgreater_color4I" target="genglsl" />
  <implementation name="IM_ifgreater_vector2I_genglsl" nodedef="ND_ifgreater_vector2I" target="genglsl" />
  <implementation name="IM_ifgreater_vector3I_genglsl" nodedef="ND_ifgreater_vector3I" target="genglsl" />
  <implementation name="IM_ifgreater_vector4I_genglsl" nodedef="ND_ifgreater_vector4I" target="genglsl" />

  <!-- <ifgreatereq -->
  <implementation name="IM_ifgreatereq_float_genglsl" nodedef="ND_ifgreatereq_float" target="genglsl" />
  <implementation name="IM_ifgreatereq_color3_genglsl" nodedef="ND_ifgreatereq_color3" target="genglsl" />
  <implementation name="IM_ifgreatereq_color4_genglsl" nodedef="ND_ifgreatereq_color4" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector2_genglsl" nodedef="ND_ifgreatereq_vector2" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector3_genglsl" nodedef="ND_ifgreatereq_vector3" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector4_genglsl" nodedef="ND_ifgreatereq_vector4" target="genglsl" />
  <implementation name="IM_ifgreatereq_floatI_genglsl" nodedef="ND_ifgreatereq_floatI" target="genglsl" />
  <implementation name="IM_ifgreatereq_color3I_genglsl" nodedef="ND_ifgreatereq_color3I" target="genglsl" />
  <implementation name="IM_ifgreatereq_color4I_genglsl" nodedef="ND_ifgreatereq_color4I" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector2I_genglsl" nodedef="ND_ifgreatereq_vector2I" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector3I_genglsl" nodedef="ND_ifgreatereq_vector3I" target="genglsl" />
  <implementation name="IM_ifgreatereq_vector4I_genglsl" nodedef="ND_ifgreatereq_vector4I" target="genglsl" />

  <!-- <ifequal -->
  <implementation name="IM_ifequal_float_genglsl" nodedef="ND_ifequal_float" target="genglsl" />
  <implementation name="IM_ifequal_color3_genglsl" nodedef="ND_ifequal_color3" target="genglsl" />
  <implementation name="IM_ifequal_color4_genglsl" nodedef="ND_ifequal_color4" target="genglsl" />
  <implementation name="IM_ifequal_vector2_genglsl" nodedef="ND_ifequal_vector2" target="genglsl" />
  <implementation name="IM_ifequal_vector3_genglsl" nodedef="ND_ifequal_vector3" target="genglsl" />
  <implementation name="IM_ifequal_vector4_genglsl" nodedef="ND_ifequal_vector4" target="genglsl" />
  <implementation name="IM_ifequal_floatI_genglsl" nodedef="ND_ifequal_floatI" target="genglsl" />
  <implementation name="IM_ifequal_color3I_genglsl" nodedef="ND_ifequal_color3I" target="genglsl" />
  <implementation name="IM_ifequal_color4I_genglsl" nodedef="ND_ifequal_color4I" target="genglsl" />
  <implementation name="IM_ifequal_vector2I_genglsl" nodedef="ND_ifequal_vector2I" target="genglsl" />
  <implementation name="IM_ifequal_vector3I_genglsl" nodedef="ND_ifequal_vector3I" target="genglsl" />
  <implementation name="IM_ifequal_vector4I_genglsl" nodedef="ND_ifequal_vector4I" target="genglsl" />
  <implementation name="IM_ifequal_floatB_genglsl" nodedef="ND_ifequal_floatB" target="genglsl" />
  <implementation name="IM_ifequal_color3B_genglsl" nodedef="ND_ifequal_color3B" target="genglsl" />
  <implementation name="IM_ifequal_color4B_genglsl" nodedef="ND_ifequal_color4B" target="genglsl" />
  <implementation name="IM_ifequal_vector2B_genglsl" nodedef="ND_ifequal_vector2B" target="genglsl" />
  <implementation name="IM_ifequal_vector3B_genglsl" nodedef="ND_ifequal_vector3B" target="genglsl" />
  <implementation name="IM_ifequal_vector4B_genglsl" nodedef="ND_ifequal_vector4B" target="genglsl" />

  <!-- <switch> -->

  <!-- 'which' type : float -->
  <implementation name="IM_switch_float_genglsl" nodedef="ND_switch_float" target="genglsl" />
  <implementation name="IM_switch_color3_genglsl" nodedef="ND_switch_color3" target="genglsl" />
  <implementation name="IM_switch_color4_genglsl" nodedef="ND_switch_color4" target="genglsl" />
  <implementation name="IM_switch_vector2_genglsl" nodedef="ND_switch_vector2" target="genglsl" />
  <implementation name="IM_switch_vector3_genglsl" nodedef="ND_switch_vector3" target="genglsl" />
  <implementation name="IM_switch_vector4_genglsl" nodedef="ND_switch_vector4" target="genglsl" />

  <!-- 'which' type : integer -->
  <implementation name="IM_switch_floatI_genglsl" nodedef="ND_switch_floatI" target="genglsl" />
  <implementation name="IM_switch_color3I_genglsl" nodedef="ND_switch_color3I" target="genglsl" />
  <implementation name="IM_switch_color4I_genglsl" nodedef="ND_switch_color4I" target="genglsl" />
  <implementation name="IM_switch_vector2I_genglsl" nodedef="ND_switch_vector2I" target="genglsl" />
  <implementation name="IM_switch_vector3I_genglsl" nodedef="ND_switch_vector3I" target="genglsl" />
  <implementation name="IM_switch_vector4I_genglsl" nodedef="ND_switch_vector4I" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Channel nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <convert> -->
  <implementation name="IM_convert_float_color3_genglsl" nodedef="ND_convert_float_color3" target="genglsl" />
  <implementation name="IM_convert_float_color4_genglsl" nodedef="ND_convert_float_color4" target="genglsl" />
  <implementation name="IM_convert_float_vector2_genglsl" nodedef="ND_convert_float_vector2" target="genglsl" />
  <implementation name="IM_convert_float_vector3_genglsl" nodedef="ND_convert_float_vector3" target="genglsl" />
  <implementation name="IM_convert_float_vector4_genglsl" nodedef="ND_convert_float_vector4" target="genglsl" />
  <implementation name="IM_convert_vector2_vector3_genglsl" nodedef="ND_convert_vector2_vector3" target="genglsl" />
  <implementation name="IM_convert_vector3_vector2_genglsl" nodedef="ND_convert_vector3_vector2" target="genglsl" />
  <implementation name="IM_convert_vector3_color3_genglsl" nodedef="ND_convert_vector3_color3" target="genglsl" />
  <implementation name="IM_convert_vector3_vector4_genglsl" nodedef="ND_convert_vector3_vector4" target="genglsl" />
  <implementation name="IM_convert_vector4_vector3_genglsl" nodedef="ND_convert_vector4_vector3" target="genglsl" />
  <implementation name="IM_convert_vector4_color4_genglsl" nodedef="ND_convert_vector4_color4" target="genglsl" />
  <implementation name="IM_convert_color3_vector3_genglsl" nodedef="ND_convert_color3_vector3" target="genglsl" />
  <implementation name="IM_convert_color4_vector4_genglsl" nodedef="ND_convert_color4_vector4" target="genglsl" />
  <implementation name="IM_convert_color3_color4_genglsl" nodedef="ND_convert_color3_color4" target="genglsl" />
  <implementation name="IM_convert_color4_color3_genglsl" nodedef="ND_convert_color4_color3" target="genglsl" />
  <implementation name="IM_convert_boolean_float_genglsl" nodedef="ND_convert_boolean_float" target="genglsl" />
  <implementation name="IM_convert_integer_float_genglsl" nodedef="ND_convert_integer_float" target="genglsl" />

  <!-- <swizzle> -->
  <!-- from type: float -->
  <implementation name="IM_swizzle_float_color3_genglsl" nodedef="ND_swizzle_float_color3" target="genglsl" />
  <implementation name="IM_swizzle_float_color4_genglsl" nodedef="ND_swizzle_float_color4" target="genglsl" />
  <implementation name="IM_swizzle_float_vector2_genglsl" nodedef="ND_swizzle_float_vector2" target="genglsl" />
  <implementation name="IM_swizzle_float_vector3_genglsl" nodedef="ND_swizzle_float_vector3" target="genglsl" />
  <implementation name="IM_swizzle_float_vector4_genglsl" nodedef="ND_swizzle_float_vector4" target="genglsl" />
  <!-- from type: color3 -->
  <implementation name="IM_swizzle_color3_float_genglsl" nodedef="ND_swizzle_color3_float" target="genglsl" />
  <implementation name="IM_swizzle_color3_color3_genglsl" nodedef="ND_swizzle_color3_color3" target="genglsl" />
  <implementation name="IM_swizzle_color3_color4_genglsl" nodedef="ND_swizzle_color3_color4" target="genglsl" />
  <implementation name="IM_swizzle_color3_vector2_genglsl" nodedef="ND_swizzle_color3_vector2" target="genglsl" />
  <implementation name="IM_swizzle_color3_vector3_genglsl" nodedef="ND_swizzle_color3_vector3" target="genglsl" />
  <implementation name="IM_swizzle_color3_vector4_genglsl" nodedef="ND_swizzle_color3_vector4" target="genglsl" />
  <!-- from type: color4 -->
  <implementation name="IM_swizzle_color4_float_genglsl" nodedef="ND_swizzle_color4_float" target="genglsl" />
  <implementation name="IM_swizzle_color4_color3_genglsl" nodedef="ND_swizzle_color4_color3" target="genglsl" />
  <implementation name="IM_swizzle_color4_color4_genglsl" nodedef="ND_swizzle_color4_color4" target="genglsl" />
  <implementation name="IM_swizzle_color4_vector2_genglsl" nodedef="ND_swizzle_color4_vector2" target="genglsl" />
  <implementation name="IM_swizzle_color4_vector3_genglsl" nodedef="ND_swizzle_color4_vector3" target="genglsl" />
  <implementation name="IM_swizzle_color4_vector4_genglsl" nodedef="ND_swizzle_color4_vector4" target="genglsl" />
  <!-- from type: vector2 -->
  <implementation name="IM_swizzle_vector2_float_genglsl" nodedef="ND_swizzle_vector2_float" target="genglsl" />
  <implementation name="IM_swizzle_vector2_color3_genglsl" nodedef="ND_swizzle_vector2_color3" target="genglsl" />
  <implementation name="IM_swizzle_vector2_color4_genglsl" nodedef="ND_swizzle_vector2_color4" target="genglsl" />
  <implementation name="IM_swizzle_vector2_vector2_genglsl" nodedef="ND_swizzle_vector2_vector2" target="genglsl" />
  <implementation name="IM_swizzle_vector2_vector3_genglsl" nodedef="ND_swizzle_vector2_vector3" target="genglsl" />
  <implementation name="IM_swizzle_vector2_vector4_genglsl" nodedef="ND_swizzle_vector2_vector4" target="genglsl" />
  <!-- from type: vector3 -->
  <implementation name="IM_swizzle_vector3_float_genglsl" nodedef="ND_swizzle_vector3_float" target="genglsl" />
  <implementation name="IM_swizzle_vector3_color3_genglsl" nodedef="ND_swizzle_vector3_color3" target="genglsl" />
  <implementation name="IM_swizzle_vector3_color4_genglsl" nodedef="ND_swizzle_vector3_color4" target="genglsl" />
  <implementation name="IM_swizzle_vector3_vector2_genglsl" nodedef="ND_swizzle_vector3_vector2" target="genglsl" />
  <implementation name="IM_swizzle_vector3_vector3_genglsl" nodedef="ND_swizzle_vector3_vector3" target="genglsl" />
  <implementation name="IM_swizzle_vector3_vector4_genglsl" nodedef="ND_swizzle_vector3_vector4" target="genglsl" />
  <!-- from type: vector4 -->
  <implementation name="IM_swizzle_vector4_float_genglsl" nodedef="ND_swizzle_vector4_float" target="genglsl" />
  <implementation name="IM_swizzle_vector4_color3_genglsl" nodedef="ND_swizzle_vector4_color3" target="genglsl" />
  <implementation name="IM_swizzle_vector4_color4_genglsl" nodedef="ND_swizzle_vector4_color4" target="genglsl" />
  <implementation name="IM_swizzle_vector4_vector2_genglsl" nodedef="ND_swizzle_vector4_vector2" target="genglsl" />
  <implementation name="IM_swizzle_vector4_vector3_genglsl" nodedef="ND_swizzle_vector4_vector3" target="genglsl" />
  <implementation name="IM_swizzle_vector4_vector4_genglsl" nodedef="ND_swizzle_vector4_vector4" target="genglsl" />

  <!-- <combine> -->
  <implementation name="IM_combine2_vector2_genglsl" nodedef="ND_combine2_vector2" target="genglsl" />
  <implementation name="IM_combine2_color4CF_genglsl" nodedef="ND_combine2_color4CF" target="genglsl" />
  <implementation name="IM_combine2_vector4VF_genglsl" nodedef="ND_combine2_vector4VF" target="genglsl" />
  <implementation name="IM_combine2_vector4VV_genglsl" nodedef="ND_combine2_vector4VV" target="genglsl" />
  <implementation name="IM_combine3_color3_genglsl" nodedef="ND_combine3_color3" target="genglsl" />
  <implementation name="IM_combine3_vector3_genglsl" nodedef="ND_combine3_vector3" target="genglsl" />
  <implementation name="IM_combine4_color4_genglsl" nodedef="ND_combine4_color4" target="genglsl" />
  <implementation name="IM_combine4_vector4_genglsl" nodedef="ND_combine4_vector4" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Convolution nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <blur> -->
  <implementation name="IM_blur_float_genglsl" nodedef="ND_blur_float" target="genglsl" />
  <implementation name="IM_blur_color3_genglsl" nodedef="ND_blur_color3" target="genglsl" />
  <implementation name="IM_blur_color4_genglsl" nodedef="ND_blur_color4" target="genglsl" />
  <implementation name="IM_blur_vector2_genglsl" nodedef="ND_blur_vector2" target="genglsl" />
  <implementation name="IM_blur_vector3_genglsl" nodedef="ND_blur_vector3" target="genglsl" />
  <implementation name="IM_blur_vector4_genglsl" nodedef="ND_blur_vector4" target="genglsl" />

  <!-- <heighttonormal> -->
  <implementation name="IM_heighttonormal_vector3_genglsl" nodedef="ND_heighttonormal_vector3" target="genglsl" />

  <!-- ======================================================================== -->
  <!-- Organization nodes                                                       -->
  <!-- ======================================================================== -->

  <!-- <dot> -->
  <implementation name="IM_dot_float_genglsl" nodedef="ND_dot_float" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_color3_genglsl" nodedef="ND_dot_color3" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_color4_genglsl" nodedef="ND_dot_color4" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_vector2_genglsl" nodedef="ND_dot_vector2" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_vector3_genglsl" nodedef="ND_dot_vector3" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_vector4_genglsl" nodedef="ND_dot_vector4" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_integer_genglsl" nodedef="ND_dot_integer" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_boolean_genglsl" nodedef="ND_dot_boolean" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_matrix33_genglsl" nodedef="ND_dot_matrix33" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_matrix44_genglsl" nodedef="ND_dot_matrix44" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_string_genglsl" nodedef="ND_dot_string" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_filename_genglsl" nodedef="ND_dot_filename" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_surfaceshader_genglsl" nodedef="ND_dot_surfaceshader" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_displacementshader_genglsl" nodedef="ND_dot_displacementshader" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_volumeshader_genglsl" nodedef="ND_dot_volumeshader" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />
  <implementation name="IM_dot_lightshader_genglsl" nodedef="ND_dot_lightshader" file="stdlib/genglsl/mx_dot.inline" target="genglsl" />

</materialx>
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_fa_vector2(float amplitude, float pivot, vec2 texcoord, out vec2 result)
{
    vec3 value = mx_perlin_noise_vec3(texcoord);
    result = value.xy * amplitude + pivot;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_float(float amplitude, float pivot, vec2 texcoord, out float result)
{
    float value = mx_perlin_noise_float(texcoord);
    result = value * amplitude + pivot;
}
asin({{in}})
({{mix}}*((1.0 - (1.0 - {{fg}})) * (1.0 - {{bg}}))) + ((1.0-{{mix}})*{{bg}})
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splitlr_vector2(vec2 valuel, vec2 valuer, float center, vec2 texcoord, out vec2 result)
{
    result = mix(valuel, valuer, mx_aastep(center, texcoord.x));
}
#include "$fileTransformUv"

void mx_image_vector2(sampler2D tex_sampler, int layer, vec2 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec2 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).rg;
    }
    else
    {
        result = defaultval;
    }
}
void mx_mix_surfaceshader(surfaceshader fg, surfaceshader bg, float w, out surfaceshader returnshader)
{
    returnshader.color = mix(bg.color, fg.color, w);
    returnshader.transparency = mix(bg.transparency, fg.transparency, w);
}
#include "$fileTransformUv"

void mx_image_color4(sampler2D tex_sampler, int layer, vec4 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec4 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv);
    }
    else
    {
        result = defaultval;
    }
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise2d_vector2(vec2 texcoord, float jitter, out vec2 result)
{
    result = mx_worley_noise_vec2(texcoord, jitter, 0);
}
({{fg}}*(1.0-{{bg}}.g)  * {{mix}}) + ({{bg}} * (1.0-{{mix}}));
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_fa_vector2(float amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec2 result)
{
    vec2 value = mx_fractal_noise_vec2(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
#include "stdlib/genglsl/mx_burn_float.glsl"

void mx_burn_color4(vec4 fg, vec4 bg, float mixval, out vec4 result)
{
    mx_burn_float(fg.x, bg.x, mixval, result.x);
    mx_burn_float(fg.y, bg.y, mixval, result.y);
    mx_burn_float(fg.z, bg.z, mixval, result.z);
    mx_burn_float(fg.w, bg.w, mixval, result.w);
}
void mx_gamma18_to_linear_color3(vec3 _in, out vec3 result)
{
    result = pow(max(vec3(0.0), _in), vec3(1.8));
}
mat4 mx_rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;

    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void mx_rotate_vector3(vec3 _in, float amount, vec3 axis, out vec3 result)
{
    float rotationRadians = radians(amount);
    mat4 m = mx_rotationMatrix(axis, rotationRadians);
    result = (m * vec4(_in, 1.0)).xyz;
}
min({{in1}}, {{in2}})
({{fg}} + ({{bg}}*(1.0-{{fg}}[3]))) * {{mix}} + {{bg}} * (1.0-{{mix}})
void mx_multiply_surfaceshader_float(surfaceshader shader1, float value, out surfaceshader returnshader)
{
    returnshader.color = shader1.color * vec3(value);
    returnshader.transparency = shader1.transparency * value;
}
{{in1}} + {{in2}}
normalize({{in}})
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_vector3(vec3 amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec3 result)
{
    vec3 value = mx_fractal_noise_vec3(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
mod({{in1}}, {{in2}})
#include "stdlib/genglsl/mx_dodge_float.glsl"

void mx_dodge_color4(vec4 fg , vec4 bg , float mixval, out vec4 result)
{
    mx_dodge_float(fg.x, bg.x, mixval, result.x);
    mx_dodge_float(fg.y, bg.y, mixval, result.y);
    mx_dodge_float(fg.z, bg.z, mixval, result.z);
    mx_dodge_float(fg.w, bg.w, mixval, result.w);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise3d_vector3(vec3 position, float jitter, out vec3 result)
{
    result = mx_worley_noise_vec3(position, jitter, 0);
}
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec3(vec3 val, vec3 low, vec3 high, out vec3 result)
{
    mx_smoothstep_float(val.x, low.x, high.x, result.x);
    mx_smoothstep_float(val.y, low.y, high.y, result.y);
    mx_smoothstep_float(val.z, low.z, high.z, result.z);
}
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_ap1_to_rec709_color4(vec4 _in, out vec4 result)
{
    result = vec4(M_AP1_TO_REC709 * _in.rgb, _in.a);
}
transpose({{in}})
({{fg}}*{{bg}}.a  * {{mix}}) + ({{bg}} * (1.0-{{mix}}));
mix({{bg}}, {{fg}}, {{mix}})
#include "$fileTransformUv"

void mx_image_color3(sampler2D tex_sampler, int layer, vec3 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec3 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).rgb;
    }
    else
    {
        result = defaultval;
    }
}
void mx_ramptb_vector4(vec4 valuet, vec4 valueb, vec2 texcoord, out vec4 result)
{
    result = mix (valuet, valueb, clamp(texcoord.y, 0.0, 1.0) );
}
vec4( {{fg}}.xyz*{{fg}}.w + {{bg}}.xyz*(1.0-{{fg}}.w), {{fg}}.w + ({{bg}}.w*(1.0-{{fg}}.w)) ) * {{mix}} + ({{bg}} * (1.0-{{mix}}));
sin({{in}})
exp({{in}})
void mx_ramplr_float(float valuel, float valuer, vec2 texcoord, out float result)
{
    result = mix (valuel, valuer, clamp(texcoord.x, 0.0, 1.0) );
}
pow({{in1}}, {{in2}})
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_srgb_texture_to_lin_rec709_color3(vec3 _in, out vec3 result)
{
    result = mx_srgb_texture_to_lin_rec709(_in);
}
void mx_rotate_vector2(vec2 _in, float amount, out vec2 result)
{
    float rotationRadians = radians(amount);
    float sa = sin(rotationRadians);
    float ca = cos(rotationRadians);
    result = vec2(ca*_in.x + sa*_in.y, -sa*_in.x + ca*_in.y);
}
({{mix}}*({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})
sqrt({{in}})
clamp({{in}}, {{low}}, {{high}})
void mx_gamma18_to_linear_color4(vec4 _in, out vec4 result)
{
    vec4 gamma = vec4(1.8, 1.8, 1.8, 1.0);
    result = pow(max(vec4(0.0), _in), gamma);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_vector4(vec4 amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec4 result)
{
    vec4 value = mx_fractal_noise_vec4(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
void mx_disjointover_color4(vec4 fg, vec4 bg, float mixval, out vec4 result)
{
    float summedAlpha = fg.w + bg.w;

    if (summedAlpha <= 1.0)
    {
        result.xyz = fg.xyz + bg.xyz;
    }
    else
    {
        if (abs(bg.w) < M_FLOAT_EPS)
        {
            result.xyz = vec3(0.0);
        }
        else
        {
            float x = (1.0 - fg.w) / bg.w;
            result.xyz = fg.xyz + bg.xyz * x;
        }
    }
    result.w = min(summedAlpha, 1.0);

    result.xyz = result.xyz * mixval + (1.0 - mixval) * bg.xyz;
    result.w = result.w * mixval + (1.0 - mixval) * bg.w;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_fa_vector4(float amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec4 result)
{
    vec4 value = mx_fractal_noise_vec4(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
void mx_premult_color4(vec4 _in, out vec4 result)
{
    result = vec4(_in.rgb * _in.a, _in.a);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise3d_vector2(vec3 position, float jitter, out vec2 result)
{
    result = mx_worley_noise_vec2(position, jitter, 0);
}
{{amount}} - {{in}}
#include "stdlib/genglsl/mx_overlay.glsl"

void mx_overlay_color3(vec3 fg, vec3 bg, float mix, out vec3 result)
{
    result = mix * mx_overlay(fg, bg) + (1.0-mix) * bg;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_vector4(vec4 amplitude, float pivot, vec2 texcoord, out vec4 result)
{
    vec3 xyz = mx_perlin_noise_vec3(texcoord);
    float w = mx_perlin_noise_float(texcoord + vec2(19, 73));
    result = vec4(xyz, w) * amplitude + pivot;
}
pow({{in1}}, vec3({{in2}}))
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splitlr_vector3(vec3 valuel, vec3 valuer, float center, vec2 texcoord, out vec3 result)
{
    result = mix(valuel, valuer, mx_aastep(center, texcoord.x));
}
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_srgb_texture_to_lin_rec709_color4(vec4 _in, out vec4 result)
{
    result = vec4(mx_srgb_texture_to_lin_rec709(_in.rgb), _in.a);
}
void mx_transformmatrix_vector2M3(vec2 val, mat3 transform, out vec2 result)
{
  vec3 res = transform * vec3(val, 1.0);
  result = res.xy;
}
cos({{in}})
log({{in}})
void mx_gamma24_to_linear_color4(vec4 _in, out vec4 result)
{
    vec4 gamma = vec4(2.4, 2.4, 2.4, 1.0);
    result = pow(max(vec4(0.0), _in), gamma);
}
({{mix}}*({{bg}} + {{fg}})) + ((1.0-{{mix}})*{{bg}})
pow({{in1}}, vec2({{in2}}))
{{mix}}*({{bg}} / (1 - {{fg}})) + ((1.0-{{mix}})*{{bg}})
{{in}} * {{mask}}
void mx_transformmatrix_vector3M4(vec3 val, mat4 transform, out vec3 result)
{
  vec4 res = transform * vec4(val, 1.0);
  result = res.xyz;
}
abs({{in}})
dot({{in1}}, {{in2}})
atan({{in1}}, {{in2}})
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_fa_vector4(float amplitude, float pivot, vec3 position, out vec4 result)
{
    vec3 xyz = mx_perlin_noise_vec3(position);
    float w = mx_perlin_noise_float(position + vec3(19, 73, 29));
    result = vec4(xyz, w) * amplitude + pivot;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_fa_vector2(float amplitude, float pivot, vec3 position, out vec2 result)
{
    vec3 value = mx_perlin_noise_vec3(position);
    result = value.xy * amplitude + pivot;
}
void mx_multiply_surfaceshader_color3(surfaceshader shader1, vec3 value, out surfaceshader returnshader)
{
    returnshader.color = shader1.color * value;
    returnshader.transparency = shader1.transparency;
}
#include "stdlib/genglsl/lib/mx_hsv.glsl"

void mx_hsvtorgb_color4(vec4 _in, out vec4 result)
{
    result = vec4(mx_hsvtorgb(_in.rgb), 1.0);
}
#include "stdlib/genglsl/lib/mx_hsv.glsl"

void mx_rgbtohsv_color3(vec3 _in, out vec3 result)
{
    result = mx_rgbtohsv(_in);
}
acos({{in}})
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec4(vec4 val, vec4 low, vec4 high, out vec4 result)
{
    mx_smoothstep_float(val.x, low.x, high.x, result.x);
    mx_smoothstep_float(val.y, low.y, high.y, result.y);
    mx_smoothstep_float(val.z, low.z, high.z, result.z);
    mx_smoothstep_float(val.w, low.w, high.w, result.w);
}
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec3FA(vec3 val, float low, float high, out vec3 result)
{
    mx_smoothstep_float(val.x, low, high, result.x);
    mx_smoothstep_float(val.y, low, high, result.y);
    mx_smoothstep_float(val.z, low, high, result.z);
}
#include "stdlib/genglsl/mx_dodge_float.glsl"

void mx_dodge_color3(vec3 fg, vec3 bg, float mixval, out vec3 result)
{
    mx_dodge_float(fg.x, bg.x, mixval, result.x);
    mx_dodge_float(fg.y, bg.y, mixval, result.y);
    mx_dodge_float(fg.z, bg.z, mixval, result.z);
}
pow({{in1}}, vec4({{in2}}))
pow({{in1}}, vec4({{in2}}))
{{mat}} * {{in}}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise3d_float(vec3 position, float jitter, out float result)
{
    result = mx_worley_noise_float(position, jitter, 0);
}
void mx_normalmap(vec3 value, int map_space, float normal_scale, vec3 N, vec3 T,  out vec3 result)
{
    // Decode the normal map.
    value = (value == vec3(0.0f)) ? vec3(0.0, 0.0, 1.0) : value * 2.0 - 1.0;

    // Transform from tangent space if needed.
    if (map_space == 0)
    {
        vec3 B = normalize(cross(N, T));
        value.xy *= normal_scale;
        value = T * value.x + B * value.y + N * value.z;
    }

    // Normalize the result.
    result = normalize(value);
}
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splittb_vector4(vec4 valuet, vec4 valueb, float center, vec2 texcoord, out vec4 result)
{
    result = mix(valuet, valueb, mx_aastep(center, texcoord.y));
}
void mx_ramplr_vector4(vec4 valuel, vec4 valuer, vec2 texcoord, out vec4 result)
{
    result = mix (valuel, valuer, clamp(texcoord.x, 0.0, 1.0) );
}
void mx_gamma22_to_linear_color3(vec3 _in, out vec3 result)
{
    result = pow(max(vec3(0.0), _in), vec3(2.2));
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_vector3(vec3 amplitude, float pivot, vec3 position, out vec3 result)
{
    vec3 value = mx_perlin_noise_vec3(position);
    result = value * amplitude + pivot;
}
{{in1}} - {{in2}}
determinant({{in}})
void mx_luminance_color3(vec3 _in, vec3 lumacoeffs, out vec3 result)
{
    result = vec3(dot(_in, lumacoeffs));
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_fa_vector3(float amplitude, int octaves, float lacunarity, float diminish, vec3 position, out vec3 result)
{
    vec3 value = mx_fractal_noise_vec3(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_fa_vector4(float amplitude, float pivot, vec2 texcoord, out vec4 result)
{
    vec3 xyz = mx_perlin_noise_vec3(texcoord);
    float w = mx_perlin_noise_float(texcoord + vec2(19, 73));
    result = vec4(xyz, w) * amplitude + pivot;
}
void mx_smoothstep_float(float val, float low, float high, out float result)
{
    if (val <= low)
        result = 0.0;
    else if (val >= high)
        result = 1.0;
    else
        result = smoothstep(low, high, val);
}
({{fg}} < 0.5) ? ({{mix}}*2.0*{{fg}}*{{bg}}) + ((1.0-{{mix}})*{{bg}}) : ({{mix}}*(1.0-(1.0-{{fg}})*(1.0-{{bg}}))) + ((1.0-{{mix}})*{{bg}})
#include "stdlib/genglsl/mx_smoothstep_float.glsl"

void mx_smoothstep_vec4FA(vec4 val, float low, float high, out vec4 result)
{
    mx_smoothstep_float(val.x, low, high, result.x);
    mx_smoothstep_float(val.y, low, high, result.y);
    mx_smoothstep_float(val.z, low, high, result.z);
    mx_smoothstep_float(val.w, low, high, result.w);
}
{{in1}} / {{in2}}
#include "stdlib/genglsl/mx_overlay.glsl"

void mx_overlay_color4(vec4 fg, vec4 bg, float mix, out vec4 result)
{
    result = mix * mx_overlay(fg, bg) + (1.0-mix) * bg;
}
({{fg}} + ({{bg}}*(1.0-{{fg}}[1]))) * {{mix}} + {{bg}} * (1.0-{{mix}})void mx_ramplr_vector2(vec2 valuel, vec2 valuer, vec2 texcoord, out vec2 result)
{
    result = mix (valuel, valuer, clamp(texcoord.x, 0.0, 1.0) );
}
{{outlow}} + ({{in}} - {{inlow}}) * ({{outhigh}} - {{outlow}}) / ({{inhigh}} - {{inlow}})
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_worleynoise2d_vector3(vec2 texcoord, float jitter, out vec3 result)
{
    result = mx_worley_noise_vec3(texcoord, jitter, 0);
}
#include "$fileTransformUv"

void mx_image_vector4(sampler2D tex_sampler, int layer, vec4 defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out vec4 result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv);
    }
    else
    {
        result = defaultval;
    }
}
{{in1}} * {{in2}}
void mx_add_surfaceshader(surfaceshader shader1, surfaceshader shader2, out surfaceshader returnshader)
{
    returnshader.color = shader1.color + shader2.color;
    returnshader.transparency = shader1.transparency + shader2.transparency;
}
void mx_luminance_color4(vec4 _in, vec3 lumacoeffs, out vec4 result)
{
    result = vec4(vec3(dot(_in.rgb, lumacoeffs)), _in.a);
}
({{mix}}*abs({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})
pow({{in1}}, vec3({{in2}}))
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_fractal3d_float(float amplitude, int octaves, float lacunarity, float diminish, vec3 position, out float result)
{
    float value = mx_fractal_noise_float(position, octaves, lacunarity, diminish);
    result = value * amplitude;
}
void mx_burn_float(float fg, float bg, float mixval, out float result)
{
    if (abs(fg) < M_FLOAT_EPS)
    {
        result = 0.0;
        return;
    }
    result = mixval*(1.0 - ((1.0 - bg) / fg)) + ((1.0-mixval)*bg);
}
void mx_ramptb_float(float valuet, float valueb, vec2 texcoord, out float result)
{
    result = mix (valuet, valueb, clamp(texcoord.y, 0.0, 1.0) );
}
sign({{in}})
ceil({{in}})
{{value}}
floor({{in}})
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_float(float amplitude, float pivot, vec3 position, out float result)
{
    float value = mx_perlin_noise_float(position);
    result = value * amplitude + pivot;
}
void mx_dodge_float(float fg, float bg, float mixval, out float result)
{
    if (abs(1.0 - fg) < M_FLOAT_EPS)
    {
        result = 0.0;
        return;
    }
    result = mixval*(bg / (1.0 - fg)) + ((1.0-mixval)*bg);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_fa_vector3(float amplitude, float pivot, vec3 position, out vec3 result)
{
    vec3 value = mx_perlin_noise_vec3(position);
    result = value * amplitude + pivot;
}
void mx_ramplr_vector3(vec3 valuel, vec3 valuer, vec2 texcoord, out vec3 result)
{
    result = mix (valuel, valuer, clamp(texcoord.x, 0.0, 1.0) );
}
tan({{in}})
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splitlr_float(float valuel, float valuer, float center, vec2 texcoord, out float result)
{
    result = mix(valuel, valuer, mx_aastep(center, texcoord.x));
}
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_g22_ap1_to_lin_rec709_color3(vec3 _in, out vec3 result)
{
    result = M_AP1_TO_REC709 * pow(max(vec3(0.0), _in), vec3(2.2));
}
#include "stdlib/genglsl/lib/mx_hsv.glsl"

void mx_rgbtohsv_color4(vec4 _in, out vec4 result)
{
    result = vec4(mx_rgbtohsv(_in.rgb), 1.0);
}
void mx_gamma22_to_linear_color4(vec4 _in, out vec4 result)
{
    vec4 gamma = vec4(2.2, 2.2, 2.2, 1.0);
    result = pow(max(vec4(0.0), _in), gamma);
}
void mx_gamma24_to_linear_color3(vec3 _in, out vec3 result)
{
    result = pow(max(vec3(0.0), _in), vec3(2.4));
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_vector2(vec2 amplitude, float pivot, vec3 position, out vec2 result)
{
    vec3 value = mx_perlin_noise_vec3(position);
    result = value.xy * amplitude + pivot;
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise3d_vector4(vec4 amplitude, float pivot, vec3 position, out vec4 result)
{
    vec3 xyz = mx_perlin_noise_vec3(position);
    float w = mx_perlin_noise_float(position + vec3(19, 73, 29));
    result = vec4(xyz, w) * amplitude + pivot;
}
#include "$fileTransformUv"

void mx_image_float(sampler2D tex_sampler, int layer, float defaultval, vec2 texcoord, int uaddressmode, int vaddressmode, int filtertype, int framerange, int frameoffset, int frameendaction, vec2 uv_scale, vec2 uv_offset, out float result)
{
    if (textureSize(tex_sampler, 0).x > 1)
    {
        vec2 uv = mx_transform_uv(texcoord, uv_scale, uv_offset);
        result = texture(tex_sampler, uv).r;
    }
    else
    {
        result = defaultval;
    }
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_cellnoise3d_float(vec3 position, out float result)
{
    result = mx_cell_noise_float(position);
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Unit System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_distance_unit_float_genglsl" target="genglsl" />
  <implementation name="IM_distance_unit_vector2_genglsl" target="genglsl" />
  <implementation name="IM_distance_unit_vector3_genglsl" target="genglsl" />
  <implementation name="IM_distance_unit_vector4_genglsl" target="genglsl" />

  <implementation name="IM_angle_unit_float_genglsl" target="genglsl" />
  <implementation name="IM_angle_unit_vector2_genglsl" target="genglsl" />
  <implementation name="IM_angle_unit_vector3_genglsl" target="genglsl" />
  <implementation name="IM_angle_unit_vector4_genglsl" target="genglsl" />

</materialx>
({{fg}}*(1.0-{{bg}}.a)  * {{mix}}) + ({{bg}} * (1.0-{{mix}}));
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splittb_vector3(vec3 valuet, vec3 valueb, float center, vec2 texcoord, out vec3 result)
{
    result = mix(valuet, valueb, mx_aastep(center, texcoord.y));
}
#include "stdlib/genglsl/lib/mx_hsv.glsl"

void mx_hsvtorgb_color3(vec3 _in, out vec3 result)
{
    result = mx_hsvtorgb(_in);
}
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splittb_float(float valuet, float valueb, float center, vec2 texcoord, out float result)
{
    result = mix(valuet, valueb, mx_aastep(center, texcoord.y));
}
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_ap1_to_rec709_color3(vec3 _in, out vec3 result)
{
    result = M_AP1_TO_REC709 * _in;
}
#include "stdlib/genglsl/lib/mx_transform_color.glsl"

void mx_g22_ap1_to_lin_rec709_color4(vec4 _in, out vec4 result)
{
    result = vec4(M_AP1_TO_REC709 * pow(max(vec3(0.0), _in.rgb), vec3(2.2)), _in.a);
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_vector3(vec3 amplitude, float pivot, vec2 texcoord, out vec3 result)
{
    vec3 value = mx_perlin_noise_vec3(texcoord);
    result = value * amplitude + pivot;
}
void mx_ramptb_vector3(vec3 valuet, vec3 valueb, vec2 texcoord, out vec3 result)
{
    result = mix (valuet, valueb, clamp(texcoord.y, 0.0, 1.0) );
}
#include "stdlib/genglsl/lib/mx_noise.glsl"

void mx_noise2d_fa_vector3(float amplitude, float pivot, vec2 texcoord, out vec3 result)
{
    vec3 value = mx_perlin_noise_vec3(texcoord);
    result = value * amplitude + pivot;
}
#include "stdlib/genglsl/mx_aastep.glsl"

void mx_splitlr_vector4(vec4 valuel, vec4 valuer, float center, vec2 texcoord, out vec4 result)
{
    result = mix(valuel, valuer, mx_aastep(center, texcoord.x));
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Color Management System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_g18_rec709_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_gamma18_to_linear_color3.glsl" function="mx_gamma18_to_linear_color3" target="genglsl" />
  <implementation name="IM_g18_rec709_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_gamma18_to_linear_color4.glsl" function="mx_gamma18_to_linear_color4" target="genglsl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_gamma22_to_linear_color3.glsl" function="mx_gamma22_to_linear_color3" target="genglsl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_gamma22_to_linear_color4.glsl" function="mx_gamma22_to_linear_color4" target="genglsl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_gamma24_to_linear_color3.glsl" function="mx_gamma24_to_linear_color3" target="genglsl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_gamma24_to_linear_color4.glsl" function="mx_gamma24_to_linear_color4" target="genglsl" />

  <implementation name="IM_acescg_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_ap1_to_rec709_color3.glsl" function="mx_ap1_to_rec709_color3" target="genglsl" />
  <implementation name="IM_acescg_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_ap1_to_rec709_color4.glsl" function="mx_ap1_to_rec709_color4" target="genglsl" />

  <implementation name="IM_g22_ap1_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_g22_ap1_to_lin_rec709_color3.glsl" function="mx_g22_ap1_to_lin_rec709_color3" target="genglsl" />
  <implementation name="IM_g22_ap1_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_g22_ap1_to_lin_rec709_color4.glsl" function="mx_g22_ap1_to_lin_rec709_color4" target="genglsl" />

  <implementation name="IM_srgb_texture_to_lin_rec709_color3_genglsl" file="stdlib/genglsl/mx_srgb_texture_to_lin_rec709_color3.glsl" function="mx_srgb_texture_to_lin_rec709_color3" target="genglsl" />
  <implementation name="IM_srgb_texture_to_lin_rec709_color4_genglsl" file="stdlib/genglsl/mx_srgb_texture_to_lin_rec709_color4.glsl" function="mx_srgb_texture_to_lin_rec709_color4" target="genglsl" />

</materialx>
float mx_overlay(float fg, float bg)
{
    return (fg < 0.5) ? (2.0 * fg * bg) : (1.0 - (1.0 - fg) * (1.0 - bg));
}

vec2 mx_overlay(vec2 fg, vec2 bg)
{
    return vec2(mx_overlay(fg.r, bg.r),
                mx_overlay(fg.g, bg.g));
}

vec3 mx_overlay(vec3 fg, vec3 bg)
{
    return vec3(mx_overlay(fg.r, bg.r),
                mx_overlay(fg.g, bg.g),
                mx_overlay(fg.b, bg.b));
}

vec4 mx_overlay(vec4 fg, vec4 bg)
{
    return vec4(mx_overlay(fg.r, bg.r),
                mx_overlay(fg.g, bg.g),
                mx_overlay(fg.b, bg.b),
                mx_overlay(fg.a, bg.a));
}
vec2 mx_transform_uv(vec2 uv, vec2 uv_scale, vec2 uv_offset)
{
    uv = uv * uv_scale + uv_offset;
    return vec2(uv.x, 1.0 - uv.y);
}
#define M_AP1_TO_REC709 mat3(1.705079555511475, -0.1297005265951157, -0.02416634373366833, -0.6242334842681885, 1.138468623161316, -0.1246141716837883, -0.0808461606502533, -0.008768022060394287, 1.148780584335327)

vec3 mx_srgb_texture_to_lin_rec709(vec3 color)
{
    vec3 breakPnt = vec3(0.03928571566939354, 0.03928571566939354, 0.03928571566939354);
    vec3 slope = vec3(0.07738015800714493, 0.07738015800714493, 0.07738015800714493);
    vec3 scale = vec3(0.9478672742843628, 0.9478672742843628, 0.9478672742843628);
    vec3 offset = vec3(0.05213269963860512, 0.05213269963860512, 0.05213269963860512);
    vec3 isAboveBreak = vec3(greaterThan(color, breakPnt));
    vec3 powSeg = pow(max(vec3(0.0), scale * color + offset), vec3(2.4));
    vec3 linSeg = color * slope;
    return isAboveBreak * powSeg + (vec3(1.0) - isAboveBreak) * linSeg;
}
// Restrict to 7x7 kernel size for performance reasons
#define MX_MAX_SAMPLE_COUNT 49
// Size of all weights for all levels (including level 1)
#define MX_WEIGHT_ARRAY_SIZE 84

//
// Function to compute the sample size relative to a texture coordinate
//
vec2 mx_compute_sample_size_uv(vec2 uv, float filterSize, float filterOffset)
{
   vec2 derivUVx = dFdx(uv) * 0.5f;
   vec2 derivUVy = dFdy(uv) * 0.5f;
   float derivX = abs(derivUVx.x) + abs(derivUVy.x);
   float derivY = abs(derivUVx.y) + abs(derivUVy.y);
   float sampleSizeU = 2.0f * filterSize * derivX + filterOffset;
   if (sampleSizeU < 1.0E-05f)
       sampleSizeU = 1.0E-05f;
   float sampleSizeV = 2.0f * filterSize * derivY + filterOffset;
   if (sampleSizeV < 1.0E-05f)
       sampleSizeV = 1.0E-05f;
   return vec2(sampleSizeU, sampleSizeV);
}

//
// Compute a normal mapped to 0..1 space based on a set of input
// samples using a Sobel filter.
//
vec3 mx_normal_from_samples_sobel(float S[9], float _scale)
{
    float nx = S[0] - S[2] + (2.0*S[3]) - (2.0*S[5]) + S[6] - S[8];
    float ny = S[0] + (2.0*S[1]) + S[2] - S[6] - (2.0*S[7]) - S[8];
    float nz = max(_scale, M_FLOAT_EPS) * sqrt(max(1.0 - nx * nx - ny * ny, M_FLOAT_EPS));
    vec3 norm = normalize(vec3(nx, ny, nz));
    return (norm + 1.0) * 0.5;
}

//
// Apply filter for float samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
float mx_convolution_float(float S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    float result = 0.0;
    for (int i = 0;  i < sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vec2 samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
vec2 mx_convolution_vec2(vec2 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vec2 result = vec2(0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vec3 samples S, using weights W.
// sampleCount should be a square of a odd number in the range { 1, 3, 5, 7 }
//
vec3 mx_convolution_vec3(vec3 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vec3 result = vec3(0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}

//
// Apply filter for vec4 samples S, using weights W.
// sampleCount should be a square of a odd number { 1, 3, 5, 7 }
//
vec4 mx_convolution_vec4(vec4 S[MX_MAX_SAMPLE_COUNT], float W[MX_WEIGHT_ARRAY_SIZE], int offset, int sampleCount)
{
    vec4 result = vec4(0.0);
    for (int i=0;  i<sampleCount; i++)
    {
        result += S[i]*W[i+offset];
    }
    return result;
}
/*
Color transform functions.

These funcions are modified versions of the color operators found in Open Shading Language:
github.com/imageworks/OpenShadingLanguage/blob/master/src/liboslexec/opcolor.cpp

It contains the subset of color operators needed to implement the MaterialX
standard library. The modifications are for conversions from C++ to GLSL.

Original copyright notice:
------------------------------------------------------------------------
Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of Sony Pictures Imageworks nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------
*/

vec3 mx_hsvtorgb(vec3 hsv)
{
    // Reference for this technique: Foley & van Dam
    float h = hsv.x; float s = hsv.y; float v = hsv.z;
    if (s < 0.0001f) {
      return vec3 (v, v, v);
    } else {
        h = 6.0f * (h - floor(h));  // expand to [0..6)
        int hi = int(trunc(h));
        float f = h - float(hi);
        float p = v * (1.0f-s);
        float q = v * (1.0f-s*f);
        float t = v * (1.0f-s*(1.0f-f));
        if (hi == 0)
            return vec3 (v, t, p);
        else if (hi == 1)
            return vec3 (q, v, p);
        else if (hi == 2)
            return vec3 (p, v, t);
        else if (hi == 3)
            return vec3 (p, q, v);
        else if (hi == 4)
            return vec3 (t, p, v);
        return vec3 (v, p, q);
    }
}


vec3 mx_rgbtohsv(vec3 c)
{
    // See Foley & van Dam
    float r = c.x; float g = c.y; float b = c.z;
    float mincomp = min (r, min(g, b));
    float maxcomp = max (r, max(g, b));
    float delta = maxcomp - mincomp;  // chroma
    float h, s, v;
    v = maxcomp;
    if (maxcomp > 0.0f)
        s = delta / maxcomp;
    else s = 0.0f;
    if (s <= 0.0f)
        h = 0.0f;
    else {
        if      (r >= maxcomp) h = (g-b) / delta;
        else if (g >= maxcomp) h = 2.0f + (b-r) / delta;
        else                   h = 4.0f + (r-g) / delta;
        h *= (1.0f/6.0f);
        if (h < 0.0f)
            h += 1.0f;
    }
    return vec3(h, s, v);
}
#define M_FLOAT_EPS 1e-8

float mx_square(float x)
{
    return x*x;
}

vec2 mx_square(vec2 x)
{
    return x*x;
}

vec3 mx_square(vec3 x)
{
    return x*x;
}
vec2 mx_transform_uv(vec2 uv, vec2 uv_scale, vec2 uv_offset)
{
    uv = uv * uv_scale + uv_offset;
    return uv;
}
/*
Noise Library.

This library is a modified version of the noise library found in
Open Shading Language:
github.com/imageworks/OpenShadingLanguage/blob/master/src/include/OSL/oslnoise.h

It contains the subset of noise types needed to implement the MaterialX
standard library. The modifications are mainly conversions from C++ to GLSL.
Produced results should be identical to the OSL noise functions.

Original copyright notice:
------------------------------------------------------------------------
Copyright (c) 2009-2010 Sony Pictures Imageworks Inc., et al.
All Rights Reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:
* Redistributions of source code must retain the above copyright
  notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
  notice, this list of conditions and the following disclaimer in the
  documentation and/or other materials provided with the distribution.
* Neither the name of Sony Pictures Imageworks nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------
*/

float mx_select(bool b, float t, float f)
{
    return b ? t : f;
}

float mx_negate_if(float val, bool b)
{
    return b ? -val : val;
}

int mx_floor(float x)
{
    return int(floor(x));
}

// return mx_floor as well as the fractional remainder
float mx_floorfrac(float x, out int i)
{
    i = mx_floor(x);
    return x - float(i);
}

float mx_bilerp(float v0, float v1, float v2, float v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
vec3 mx_bilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, float s, float t)
{
    float s1 = 1.0 - s;
    return (1.0 - t) * (v0*s1 + v1*s) + t * (v2*s1 + v3*s);
}
float mx_trilerp(float v0, float v1, float v2, float v3, float v4, float v5, float v6, float v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}
vec3 mx_trilerp(vec3 v0, vec3 v1, vec3 v2, vec3 v3, vec3 v4, vec3 v5, vec3 v6, vec3 v7, float s, float t, float r)
{
    float s1 = 1.0 - s;
    float t1 = 1.0 - t;
    float r1 = 1.0 - r;
    return (r1*(t1*(v0*s1 + v1*s) + t*(v2*s1 + v3*s)) +
            r*(t1*(v4*s1 + v5*s) + t*(v6*s1 + v7*s)));
}

// 2 and 3 dimensional gradient functions - perform a dot product against a
// randomly chosen vector. Note that the gradient vector is not normalized, but
// this only affects the overal "scale" of the result, so we simply account for
// the scale by multiplying in the corresponding "perlin" function.
float mx_gradient_float(uint hash, float x, float y)
{
    // 8 possible directions (+-1,+-2) and (+-2,+-1)
    uint h = hash & 7u;
    float u = mx_select(h<4u, x, y);
    float v = 2.0 * mx_select(h<4u, y, x);
    // compute the dot product with (x,y).
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
float mx_gradient_float(uint hash, float x, float y, float z)
{
    // use vectors pointing to the edges of the cube
    uint h = hash & 15u;
    float u = mx_select(h<8u, x, y);
    float v = mx_select(h<4u, y, mx_select((h==12u)||(h==14u), x, z));
    return mx_negate_if(u, bool(h&1u)) + mx_negate_if(v, bool(h&2u));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y)
{
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
}
vec3 mx_gradient_vec3(uvec3 hash, float x, float y, float z)
{
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
}
// Scaling factors to normalize the result of gradients above.
// These factors were experimentally calculated to be:
//    2D:   0.6616
//    3D:   0.9820
float mx_gradient_scale2d(float v) { return 0.6616 * v; }
float mx_gradient_scale3d(float v) { return 0.9820 * v; }
vec3 mx_gradient_scale2d(vec3 v) { return 0.6616 * v; }
vec3 mx_gradient_scale3d(vec3 v) { return 0.9820 * v; }

/// Bitwise circular rotation left by k bits (for 32 bit unsigned integers)
uint mx_rotl32(uint x, int k)
{
    return (x<<k) | (x>>(32-k));
}

void mx_bjmix(inout uint a, inout uint b, inout uint c)
{
    a -= c; a ^= mx_rotl32(c, 4); c += b;
    b -= a; b ^= mx_rotl32(a, 6); a += c;
    c -= b; c ^= mx_rotl32(b, 8); b += a;
    a -= c; a ^= mx_rotl32(c,16); c += b;
    b -= a; b ^= mx_rotl32(a,19); a += c;
    c -= b; c ^= mx_rotl32(b, 4); b += a;
}

// Mix up and combine the bits of a, b, and c (doesn't change them, but
// returns a hash of those three original values).
uint mx_bjfinal(uint a, uint b, uint c)
{
    c ^= b; c -= mx_rotl32(b,14);
    a ^= c; a -= mx_rotl32(c,11);
    b ^= a; b -= mx_rotl32(a,25);
    c ^= b; c -= mx_rotl32(b,16);
    a ^= c; a -= mx_rotl32(c,4);
    b ^= a; b -= mx_rotl32(a,14);
    c ^= b; c -= mx_rotl32(b,24);
    return c;
}

// Convert a 32 bit integer into a floating point number in [0,1]
float mx_bits_to_01(uint bits)
{
    return float(bits) / float(uint(0xffffffff));
}

float mx_fade(float t)
{
   return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

uint mx_hash_int(int x)
{
    uint len = 1u;
    uint seed = uint(0xdeadbeef) + (len << 2u) + 13u;
    return mx_bjfinal(seed+uint(x), seed, seed);
}

uint mx_hash_int(int x, int y)
{
    uint len = 2u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z)
{
    uint len = 3u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx)
{
    uint len = 4u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    return mx_bjfinal(a, b, c);
}

uint mx_hash_int(int x, int y, int z, int xx, int yy)
{
    uint len = 5u;
    uint a, b, c;
    a = b = c = uint(0xdeadbeef) + (len << 2u) + 13u;
    a += uint(x);
    b += uint(y);
    c += uint(z);
    mx_bjmix(a, b, c);
    a += uint(xx);
    b += uint(yy);
    return mx_bjfinal(a, b, c);
}

uvec3 mx_hash_vec3(int x, int y)
{
    uint h = mx_hash_int(x, y);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

uvec3 mx_hash_vec3(int x, int y, int z)
{
    uint h = mx_hash_int(x, y, z);
    // we only need the low-order bits to be random, so split out
    // the 32 bit result into 3 parts for each channel
    uvec3 result;
    result.x = (h      ) & 0xFFu;
    result.y = (h >> 8 ) & 0xFFu;
    result.z = (h >> 16) & 0xFFu;
    return result;
}

float mx_perlin_noise_float(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float result = mx_bilerp(
        mx_gradient_float(mx_hash_int(X  , Y  ), fx    , fy     ),
        mx_gradient_float(mx_hash_int(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_float(mx_hash_int(X  , Y+1), fx    , fy-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

float mx_perlin_noise_float(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    float result = mx_trilerp(
        mx_gradient_float(mx_hash_int(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_float(mx_hash_int(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_float(mx_hash_int(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_float(mx_hash_int(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

vec3 mx_perlin_noise_vec3(vec2 p)
{
    int X, Y;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    vec3 result = mx_bilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  ), fx    , fy     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  ), fx-1.0, fy     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1), fx    , fy-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1), fx-1.0, fy-1.0),
        u, v);
    return mx_gradient_scale2d(result);
}

vec3 mx_perlin_noise_vec3(vec3 p)
{
    int X, Y, Z;
    float fx = mx_floorfrac(p.x, X);
    float fy = mx_floorfrac(p.y, Y);
    float fz = mx_floorfrac(p.z, Z);
    float u = mx_fade(fx);
    float v = mx_fade(fy);
    float w = mx_fade(fz);
    vec3 result = mx_trilerp(
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z  ), fx    , fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z  ), fx-1.0, fy    , fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z  ), fx    , fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z  ), fx-1.0, fy-1.0, fz     ),
        mx_gradient_vec3(mx_hash_vec3(X  , Y  , Z+1), fx    , fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y  , Z+1), fx-1.0, fy    , fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X  , Y+1, Z+1), fx    , fy-1.0, fz-1.0),
        mx_gradient_vec3(mx_hash_vec3(X+1, Y+1, Z+1), fx-1.0, fy-1.0, fz-1.0),
        u, v, w);
    return mx_gradient_scale3d(result);
}

float mx_cell_noise_float(float p)
{
    int ix = mx_floor(p);
    return mx_bits_to_01(mx_hash_int(ix));
}

float mx_cell_noise_float(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return mx_bits_to_01(mx_hash_int(ix, iy));
}

float mx_cell_noise_float(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}

float mx_cell_noise_float(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}

vec3 mx_cell_noise_vec3(float p)
{
    int ix = mx_floor(p);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, 0)),
            mx_bits_to_01(mx_hash_int(ix, 1)),
            mx_bits_to_01(mx_hash_int(ix, 2))
    );
}

vec3 mx_cell_noise_vec3(vec2 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, 2))
    );
}

vec3 mx_cell_noise_vec3(vec3 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, 2))
    );
}

vec3 mx_cell_noise_vec3(vec4 p)
{
    int ix = mx_floor(p.x);
    int iy = mx_floor(p.y);
    int iz = mx_floor(p.z);
    int iw = mx_floor(p.w);
    return vec3(
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 0)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 1)),
            mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, 2))
    );
}

float mx_fractal_noise_float(vec3 p, int octaves, float lacunarity, float diminish)
{
    float result = 0.0;
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_float(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec3 mx_fractal_noise_vec3(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3 result = vec3(0.0);
    float amplitude = 1.0;
    for (int i = 0;  i < octaves; ++i)
    {
        result += amplitude * mx_perlin_noise_vec3(p);
        amplitude *= diminish;
        p *= lacunarity;
    }
    return result;
}

vec2 mx_fractal_noise_vec2(vec3 p, int octaves, float lacunarity, float diminish)
{
    return vec2(mx_fractal_noise_float(p, octaves, lacunarity, diminish),
                mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish));
}

vec4 mx_fractal_noise_vec4(vec3 p, int octaves, float lacunarity, float diminish)
{
    vec3  c = mx_fractal_noise_vec3(p, octaves, lacunarity, diminish);
    float f = mx_fractal_noise_float(p+vec3(19, 193, 17), octaves, lacunarity, diminish);
    return vec4(c, f);
}

float mx_worley_distance(vec2 p, int x, int y, int xoff, int yoff, float jitter, int metric)
{
    vec3  tmp = mx_cell_noise_vec3(vec2(x+xoff, y+yoff));
    vec2  off = vec2(tmp.x, tmp.y);

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec2 cellpos = vec2(float(x), float(y)) + off;
    vec2 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y);       // Manhattan distance
    if (metric == 3)
        return max(abs(diff.x), abs(diff.y));   // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_distance(vec3 p, int x, int y, int z, int xoff, int yoff, int zoff, float jitter, int metric)
{
    vec3  off = mx_cell_noise_vec3(vec3(x+xoff, y+yoff, z+zoff));

    off -= 0.5f;
    off *= jitter;
    off += 0.5f;

    vec3 cellpos = vec3(float(x), float(y), float(z)) + off;
    vec3 diff = cellpos - p;
    if (metric == 2)
        return abs(diff.x) + abs(diff.y) + abs(diff.z); // Manhattan distance
    if (metric == 3)
        return max(max(abs(diff.x), abs(diff.y)), abs(diff.z)); // Chebyshev distance
    // Either Euclidian or Distance^2
    return dot(diff, diff);
}

float mx_worley_noise_float(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    float sqdist = 1e6f;        // Some big number for jitter > 1 (not all GPUs may be IEEE)
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            sqdist = min(sqdist, dist);
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.y = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec2 p, float jitter, int metric)
{
    int X, Y;
    vec2 localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            float dist = mx_worley_distance(localpos, x, y, X, Y, jitter, metric);
            if (dist < sqdist.x)
            {
                sqdist.z = sqdist.y;
                sqdist.y = sqdist.x;
                sqdist.x = dist;
            }
            else if (dist < sqdist.y)
            {
                sqdist.z = sqdist.y;
                sqdist.y = dist;
            }
            else if (dist < sqdist.z)
            {
                sqdist.z = dist;
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

float mx_worley_noise_float(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    float sqdist = 1e6f;
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                sqdist = min(sqdist, dist);
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec2 mx_worley_noise_vec2(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec2 sqdist = vec2(1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.y = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}

vec3 mx_worley_noise_vec3(vec3 p, float jitter, int metric)
{
    int X, Y, Z;
    vec3 localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z));
    vec3 sqdist = vec3(1e6f, 1e6f, 1e6f);
    for (int x = -1; x <= 1; ++x)
    {
        for (int y = -1; y <= 1; ++y)
        {
            for (int z = -1; z <= 1; ++z)
            {
                float dist = mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric);
                if (dist < sqdist.x)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = sqdist.x;
                    sqdist.x = dist;
                }
                else if (dist < sqdist.y)
                {
                    sqdist.z = sqdist.y;
                    sqdist.y = dist;
                }
                else if (dist < sqdist.z)
                {
                    sqdist.z = dist;
                }
            }
        }
    }
    if (metric == 0)
        sqdist = sqrt(sqdist);
    return sqdist;
}
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Color Management System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_g18_rec709_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_gamma18_to_linear_color3({{in}})" target="genmdl" />
  <implementation name="IM_g18_rec709_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_gamma18_to_linear_color4({{in}})" target="genmdl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_gamma22_to_linear_color3({{in}})" target="genmdl" />
  <implementation name="IM_g22_rec709_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_gamma22_to_linear_color4({{in}})" target="genmdl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_gamma24_to_linear_color3({{in}})" target="genmdl" />
  <implementation name="IM_rec709_display_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_gamma24_to_linear_color4({{in}})" target="genmdl" />

  <implementation name="IM_acescg_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_ap1_to_rec709_color3({{in}})" target="genmdl" />
  <implementation name="IM_acescg_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_ap1_to_rec709_color4({{in}})" target="genmdl" />

  <implementation name="IM_srgb_texture_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_srgb_texture_to_lin_rec709_color3({{in}})" target="genmdl" />
  <implementation name="IM_srgb_texture_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_srgb_texture_to_lin_rec709_color4({{in}})" target="genmdl" />

  <implementation name="IM_g22_ap1_to_lin_rec709_color3_genmdl" sourcecode="mx::cm::mx_ap1_to_rec709_color3(mx::cm::mx_gamma22_to_linear_color3({{in}}))" target="genmdl" />
  <implementation name="IM_g22_ap1_to_lin_rec709_color4_genmdl" sourcecode="mx::cm::mx_ap1_to_rec709_color4(mx::cm::mx_gamma22_to_linear_color4({{in}}))" target="genmdl" />

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Unit System Implementations -->
  <!-- ======================================================================== -->

  <implementation name="IM_distance_unit_float_genmdl" target="genmdl" />
  <implementation name="IM_distance_unit_vector2_genmdl" target="genmdl" />
  <implementation name="IM_distance_unit_vector3_genmdl" target="genmdl" />
  <implementation name="IM_distance_unit_vector4_genmdl" target="genmdl" />

  <implementation name="IM_angle_unit_float_genmdl" target="genmdl" />
  <implementation name="IM_angle_unit_vector2_genmdl" target="genmdl" />
  <implementation name="IM_angle_unit_vector3_genmdl" target="genmdl" />
  <implementation name="IM_angle_unit_vector4_genmdl" target="genmdl" />

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    TM & (c) 2017 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
    All rights reserved.  See LICENSE.txt for license.

    Declarations for MDL implementations of standard nodes included in the MaterialX specification.
  -->

  <!-- ======================================================================== -->
  <!-- Shader nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <surface> -->
  <implementation name="IM_surface_unlit_genmdl" nodedef="ND_surface_unlit" sourcecode="mx::stdlib::mx_surface_unlit({{emission}}, {{emission_color}}, {{transmission}}, {{transmission_color}}, {{opacity}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Texture nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <image> -->
  <implementation name="IM_image_float_genmdl" nodedef="ND_image_float" sourcecode="mx::stdlib::mx_image_float({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="float" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color3_genmdl" nodedef="ND_image_color3" sourcecode="mx::stdlib::mx_image_color3({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="color3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_color4_genmdl" nodedef="ND_image_color4" sourcecode="mx::stdlib::mx_image_color4({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="color4" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector2_genmdl" nodedef="ND_image_vector2" sourcecode="mx::stdlib::mx_image_vector2({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="vector2" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector3_genmdl" nodedef="ND_image_vector3" sourcecode="mx::stdlib::mx_image_vector3({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="vector3" implname="default_value" />
  </implementation>
  <implementation name="IM_image_vector4_genmdl" nodedef="ND_image_vector4" sourcecode="mx::stdlib::mx_image_vector4({{file}}, {{layer}}, {{default}}, {{texcoord}}, {{uaddressmode}}, {{vaddressmode}}, {{filtertype}}, {{framerange}}, {{frameoffset}}, {{frameendaction}})" target="genmdl">
    <input name="default" type="vector4" implname="default_value" />
  </implementation>

  <!-- <triplanarprojection> -->

  <!-- <normalmap> -->
  <implementation name="IM_normalmap_genmdl" nodedef="ND_normalmap" sourcecode="mx::stdlib::mx_normalmap(mxp_in:{{in}}, mxp_space:{{space}}, mxp_scale:{{scale}}, mxp_normal:{{normal}}, mxp_tangent:{{tangent}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Procedural nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <constant> -->
  <implementation name="IM_constant_float_genmdl" nodedef="ND_constant_float" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_color3_genmdl" nodedef="ND_constant_color3" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_color4_genmdl" nodedef="ND_constant_color4" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_vector2_genmdl" nodedef="ND_constant_vector2" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_vector3_genmdl" nodedef="ND_constant_vector3" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_vector4_genmdl" nodedef="ND_constant_vector4" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_boolean_genmdl" nodedef="ND_constant_boolean" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_integer_genmdl" nodedef="ND_constant_integer" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_matrix33_genmdl" nodedef="ND_constant_matrix33" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_matrix44_genmdl" nodedef="ND_constant_matrix44" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_string_genmdl" nodedef="ND_constant_string" sourcecode="{{value}}" target="genmdl" />
  <implementation name="IM_constant_filename_genmdl" nodedef="ND_constant_filename" sourcecode="{{value}}" target="genmdl" />

  <!-- <ramplr> -->
  <implementation name="IM_ramplr_float_genmdl" nodedef="ND_ramplr_float" sourcecode="mx::stdlib::mx_ramplr_float(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramplr_color3_genmdl" nodedef="ND_ramplr_color3" sourcecode="mx::stdlib::mx_ramplr_color3(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramplr_color4_genmdl" nodedef="ND_ramplr_color4" sourcecode="mx::stdlib::mx_ramplr_color4(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramplr_vector2_genmdl" nodedef="ND_ramplr_vector2" sourcecode="mx::stdlib::mx_ramplr_vector2(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramplr_vector3_genmdl" nodedef="ND_ramplr_vector3" sourcecode="mx::stdlib::mx_ramplr_vector3(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramplr_vector4_genmdl" nodedef="ND_ramplr_vector4" sourcecode="mx::stdlib::mx_ramplr_vector4(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <ramptb> -->
  <implementation name="IM_ramptb_float_genmdl" nodedef="ND_ramptb_float" sourcecode="mx::stdlib::mx_ramptb_float(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramptb_color3_genmdl" nodedef="ND_ramptb_color3" sourcecode="mx::stdlib::mx_ramptb_color3(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramptb_color4_genmdl" nodedef="ND_ramptb_color4" sourcecode="mx::stdlib::mx_ramptb_color4(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramptb_vector2_genmdl" nodedef="ND_ramptb_vector2" sourcecode="mx::stdlib::mx_ramptb_vector2(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramptb_vector3_genmdl" nodedef="ND_ramptb_vector3" sourcecode="mx::stdlib::mx_ramptb_vector3(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_ramptb_vector4_genmdl" nodedef="ND_ramptb_vector4" sourcecode="mx::stdlib::mx_ramptb_vector4(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <splitlr> -->
  <implementation name="IM_splitlr_float_genmdl" nodedef="ND_splitlr_float" sourcecode="mx::stdlib::mx_splitlr_float(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splitlr_color3_genmdl" nodedef="ND_splitlr_color3" sourcecode="mx::stdlib::mx_splitlr_color3(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splitlr_color4_genmdl" nodedef="ND_splitlr_color4" sourcecode="mx::stdlib::mx_splitlr_color4(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splitlr_vector2_genmdl" nodedef="ND_splitlr_vector2" sourcecode="mx::stdlib::mx_splitlr_vector2(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splitlr_vector3_genmdl" nodedef="ND_splitlr_vector3" sourcecode="mx::stdlib::mx_splitlr_vector3(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splitlr_vector4_genmdl" nodedef="ND_splitlr_vector4" sourcecode="mx::stdlib::mx_splitlr_vector4(mxp_valuel:{{valuel}}, mxp_valuer:{{valuer}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <splittb> -->
  <implementation name="IM_splittb_float_genmdl" nodedef="ND_splittb_float" sourcecode="mx::stdlib::mx_splittb_float(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splittb_color3_genmdl" nodedef="ND_splittb_color3" sourcecode="mx::stdlib::mx_splittb_color3(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splittb_color4_genmdl" nodedef="ND_splittb_color4" sourcecode="mx::stdlib::mx_splittb_color4(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splittb_vector2_genmdl" nodedef="ND_splittb_vector2" sourcecode="mx::stdlib::mx_splittb_vector2(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splittb_vector3_genmdl" nodedef="ND_splittb_vector3" sourcecode="mx::stdlib::mx_splittb_vector3(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_splittb_vector4_genmdl" nodedef="ND_splittb_vector4" sourcecode="mx::stdlib::mx_splittb_vector4(mxp_valuet:{{valuet}}, mxp_valueb:{{valueb}}, mxp_center:{{center}}, mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <noise2d> -->
  <implementation name="IM_noise2d_float_genmdl" nodedef="ND_noise2d_float" sourcecode="mx::stdlib::mx_noise2d_float(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_color3_genmdl" nodedef="ND_noise2d_color3" sourcecode="mx::stdlib::mx_noise2d_color3(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_color4_genmdl" nodedef="ND_noise2d_color4" sourcecode="mx::stdlib::mx_noise2d_color4(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector2_genmdl" nodedef="ND_noise2d_vector2" sourcecode="mx::stdlib::mx_noise2d_float2(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector3_genmdl" nodedef="ND_noise2d_vector3" sourcecode="mx::stdlib::mx_noise2d_float3(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector4_genmdl" nodedef="ND_noise2d_vector4" sourcecode="mx::stdlib::mx_noise2d_float4(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_color3FA_genmdl" nodedef="ND_noise2d_color3FA" sourcecode="mx::stdlib::mx_noise2d_color3FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_color4FA_genmdl" nodedef="ND_noise2d_color4FA" sourcecode="mx::stdlib::mx_noise2d_color4FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector2FA_genmdl" nodedef="ND_noise2d_vector2FA" sourcecode="mx::stdlib::mx_noise2d_float2FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector3FA_genmdl" nodedef="ND_noise2d_vector3FA" sourcecode="mx::stdlib::mx_noise2d_float3FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />
  <implementation name="IM_noise2d_vector4FA_genmdl" nodedef="ND_noise2d_vector4FA" sourcecode="mx::stdlib::mx_noise2d_float4FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <noise3d> -->
  <implementation name="IM_noise3d_float_genmdl" nodedef="ND_noise3d_float" sourcecode="mx::stdlib::mx_noise3d_float(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_color3_genmdl" nodedef="ND_noise3d_color3" sourcecode="mx::stdlib::mx_noise3d_color3(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_color4_genmdl" nodedef="ND_noise3d_color4" sourcecode="mx::stdlib::mx_noise3d_color4(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector2_genmdl" nodedef="ND_noise3d_vector2" sourcecode="mx::stdlib::mx_noise3d_float2(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector3_genmdl" nodedef="ND_noise3d_vector3" sourcecode="mx::stdlib::mx_noise3d_float3(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector4_genmdl" nodedef="ND_noise3d_vector4" sourcecode="mx::stdlib::mx_noise3d_float4(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_color3FA_genmdl" nodedef="ND_noise3d_color3FA" sourcecode="mx::stdlib::mx_noise3d_color3FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_color4FA_genmdl" nodedef="ND_noise3d_color4FA" sourcecode="mx::stdlib::mx_noise3d_color4FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector2FA_genmdl" nodedef="ND_noise3d_vector2FA" sourcecode="mx::stdlib::mx_noise3d_float2FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector3FA_genmdl" nodedef="ND_noise3d_vector3FA" sourcecode="mx::stdlib::mx_noise3d_float3FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_noise3d_vector4FA_genmdl" nodedef="ND_noise3d_vector4FA" sourcecode="mx::stdlib::mx_noise3d_float4FA(mxp_amplitude:{{amplitude}}, mxp_pivot:{{pivot}}, mxp_position:{{position}})" target="genmdl" />

  <!-- <fractal3d> -->
  <implementation name="IM_fractal3d_float_genmdl" nodedef="ND_fractal3d_float" sourcecode="mx::stdlib::mx_fractal3d_float(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_color3_genmdl" nodedef="ND_fractal3d_color3" sourcecode="mx::stdlib::mx_fractal3d_color3(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_color4_genmdl" nodedef="ND_fractal3d_color4" sourcecode="mx::stdlib::mx_fractal3d_color4(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector2_genmdl" nodedef="ND_fractal3d_vector2" sourcecode="mx::stdlib::mx_fractal3d_float2(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector3_genmdl" nodedef="ND_fractal3d_vector3" sourcecode="mx::stdlib::mx_fractal3d_float3(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector4_genmdl" nodedef="ND_fractal3d_vector4" sourcecode="mx::stdlib::mx_fractal3d_float4(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_color3FA_genmdl" nodedef="ND_fractal3d_color3FA" sourcecode="mx::stdlib::mx_fractal3d_color3FA(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_color4FA_genmdl" nodedef="ND_fractal3d_color4FA" sourcecode="mx::stdlib::mx_fractal3d_color4FA(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector2FA_genmdl" nodedef="ND_fractal3d_vector2FA" sourcecode="mx::stdlib::mx_fractal3d_float2FA(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector3FA_genmdl" nodedef="ND_fractal3d_vector3FA" sourcecode="mx::stdlib::mx_fractal3d_float3FA(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />
  <implementation name="IM_fractal3d_vector4FA_genmdl" nodedef="ND_fractal3d_vector4FA" sourcecode="mx::stdlib::mx_fractal3d_float4FA(mxp_amplitude:{{amplitude}}, mxp_octaves:{{octaves}}, mxp_lacunarity:{{lacunarity}}, mxp_diminish:{{diminish}}, mxp_position:{{position}})" target="genmdl" />

  <!-- <cellnoise2d> -->
  <implementation name="IM_cellnoise2d_float_genmdl" nodedef="ND_cellnoise2d_float" sourcecode="mx::stdlib::mx_cellnoise2d_float(mxp_texcoord:{{texcoord}})" target="genmdl" />

  <!-- <cellnoise3d> -->
  <implementation name="IM_cellnoise3d_float_genmdl" nodedef="ND_cellnoise3d_float" sourcecode="mx::stdlib::mx_cellnoise3d_float(mxp_position:{{position}})" target="genmdl" />

  <!-- <worleynoise2d> -->
  <implementation name="IM_worleynoise2d_float_genmdl" nodedef="ND_worleynoise2d_float" sourcecode="mx::stdlib::mx_worleynoise2d_float(mxp_texcoord:{{texcoord}}, mxp_jitter:{{jitter}})" target="genmdl" />
  <implementation name="IM_worleynoise2d_vector2_genmdl" nodedef="ND_worleynoise2d_vector2" sourcecode="mx::stdlib::mx_worleynoise2d_float2(mxp_texcoord:{{texcoord}}, mxp_jitter:{{jitter}})" target="genmdl" />
  <implementation name="IM_worleynoise2d_vector3_genmdl" nodedef="ND_worleynoise2d_vector3" sourcecode="mx::stdlib::mx_worleynoise2d_float3(mxp_texcoord:{{texcoord}}, mxp_jitter:{{jitter}})" target="genmdl" />

  <!-- <worleynoise3d> -->
  <implementation name="IM_worleynoise3d_float_genmdl" nodedef="ND_worleynoise3d_float" sourcecode="mx::stdlib::mx_worleynoise3d_float(mxp_position:{{position}}, mxp_jitter:{{jitter}})" target="genmdl" />
  <implementation name="IM_worleynoise3d_vector2_genmdl" nodedef="ND_worleynoise3d_vector2" sourcecode="mx::stdlib::mx_worleynoise3d_float2(mxp_position:{{position}}, mxp_jitter:{{jitter}})" target="genmdl" />
  <implementation name="IM_worleynoise3d_vector3_genmdl" nodedef="ND_worleynoise3d_vector3" sourcecode="mx::stdlib::mx_worleynoise3d_float3(mxp_position:{{position}}, mxp_jitter:{{jitter}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Global nodes                                                             -->
  <!-- ======================================================================== -->

  <!-- <ambientocclusion> -->
  <implementation name="IM_ambientocclusion_float_genmdl" nodedef="ND_ambientocclusion_float" sourcecode="mx::stdlib::mx_ambientocclusion_float(mxp_coneangle:{{coneangle}}, mxp_maxdistance:{{maxdistance}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Geometric nodes                                                          -->
  <!-- ======================================================================== -->

  <!-- <position> -->
  <implementation name="IM_position_vector3_genmdl" nodedef="ND_position_vector3" sourcecode="mx::stdlib::mx_position_vector3(mxp_space:{{space}})" target="genmdl" />

  <!-- <normal> -->
  <implementation name="IM_normal_vector3_genmdl" nodedef="ND_normal_vector3" sourcecode="mx::stdlib::mx_normal_vector3(mxp_space:{{space}})" target="genmdl" />

  <!-- <tangent> -->
  <implementation name="IM_tangent_vector3_genmdl" nodedef="ND_tangent_vector3" sourcecode="mx::stdlib::mx_tangent_vector3(mxp_space:{{space}}, mxp_index:{{index}})" target="genmdl" />

  <!-- <bitangent> -->
  <implementation name="IM_bitangent_vector3_genmdl" nodedef="ND_bitangent_vector3" sourcecode="mx::stdlib::mx_bitangent_vector3(mxp_space:{{space}}, mxp_index:{{index}})" target="genmdl" />

  <!-- <texcoord> -->
  <implementation name="IM_texcoord_vector2_genmdl" nodedef="ND_texcoord_vector2" sourcecode="mx::stdlib::mx_texcoord_vector2(mxp_index:{{index}})" target="genmdl" />
  <implementation name="IM_texcoord_vector3_genmdl" nodedef="ND_texcoord_vector3" sourcecode="mx::stdlib::mx_texcoord_vector3(mxp_index:{{index}})" target="genmdl" />

  <!-- <geomcolor> -->
  <implementation name="IM_geomcolor_float_genmdl" nodedef="ND_geomcolor_float" sourcecode="mx::stdlib::mx_geomcolor_float(mxp_index:{{index}})" target="genmdl" />
  <implementation name="IM_geomcolor_color3_genmdl" nodedef="ND_geomcolor_color3" sourcecode="mx::stdlib::mx_geomcolor_color3(mxp_index:{{index}})" target="genmdl" />
  <implementation name="IM_geomcolor_color4_genmdl" nodedef="ND_geomcolor_color4" sourcecode="mx::stdlib::mx_geomcolor_color4(mxp_index:{{index}})" target="genmdl" />

  <!-- <geompropvalue> -->
  <implementation name="IM_geompropvalue_integer_genmdl" nodedef="ND_geompropvalue_integer" sourcecode="mx::stdlib::mx_geompropvalue_integer(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_boolean_genmdl" nodedef="ND_geompropvalue_boolean" sourcecode="mx::stdlib::mx_geompropvalue_boolean(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_string_genmdl" nodedef="ND_geompropvalue_string" sourcecode="mx::stdlib::mx_geompropvalue_string(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_float_genmdl" nodedef="ND_geompropvalue_float" sourcecode="mx::stdlib::mx_geompropvalue_float(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_color3_genmdl" nodedef="ND_geompropvalue_color3" sourcecode="mx::stdlib::mx_geompropvalue_color3(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_color4_genmdl" nodedef="ND_geompropvalue_color4" sourcecode="mx::stdlib::mx_geompropvalue_color4(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_vector2_genmdl" nodedef="ND_geompropvalue_vector2" sourcecode="mx::stdlib::mx_geompropvalue_vector2(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_vector3_genmdl" nodedef="ND_geompropvalue_vector3" sourcecode="mx::stdlib::mx_geompropvalue_vector3(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />
  <implementation name="IM_geompropvalue_vector4_genmdl" nodedef="ND_geompropvalue_vector4" sourcecode="mx::stdlib::mx_geompropvalue_vector4(mxp_geomprop:{{geomprop}}, mxp_default:{{default}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Application nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <frame> -->
  <implementation name="IM_frame_float_genmdl" nodedef="ND_frame_float" sourcecode="mx::stdlib::mx_frame_float()" target="genmdl" />

  <!-- <time> -->
  <implementation name="IM_time_float_genmdl" nodedef="ND_time_float" sourcecode="mx::stdlib::mx_time_float()" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Math nodes                                                               -->
  <!-- ======================================================================== -->

  <!-- <add> -->
  <implementation name="IM_add_float_genmdl" nodedef="ND_add_float" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_color3_genmdl" nodedef="ND_add_color3" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_color3FA_genmdl" nodedef="ND_add_color3FA" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_color4_genmdl" nodedef="ND_add_color4" sourcecode="mx_add({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_add_color4FA_genmdl" nodedef="ND_add_color4FA" sourcecode="mx_add({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_add_vector2_genmdl" nodedef="ND_add_vector2" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_vector2FA_genmdl" nodedef="ND_add_vector2FA" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_vector3_genmdl" nodedef="ND_add_vector3" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_vector3FA_genmdl" nodedef="ND_add_vector3FA" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_vector4_genmdl" nodedef="ND_add_vector4" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_vector4FA_genmdl" nodedef="ND_add_vector4FA" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_matrix33_genmdl" nodedef="ND_add_matrix33" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_matrix33FA_genmdl" nodedef="ND_add_matrix33FA" sourcecode="{{in1}} + float3x3({{in2}})" target="genmdl" />
  <implementation name="IM_add_matrix44_genmdl" nodedef="ND_add_matrix44" sourcecode="{{in1}} + {{in2}}" target="genmdl" />
  <implementation name="IM_add_matrix44FA_genmdl" nodedef="ND_add_matrix44FA" sourcecode="{{in1}} + float4x4({{in2}})" target="genmdl" />
  <implementation name="IM_add_surfaceshader_genmdl" nodedef="ND_add_surfaceshader" sourcecode="mx::stdlib::mx_add_surfaceshader({{in1}}, {{in2}})" target="genmdl" />

  <!-- <subtract> -->
  <implementation name="IM_subtract_float_genmdl" nodedef="ND_subtract_float" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_color3_genmdl" nodedef="ND_subtract_color3" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_color3FA_genmdl" nodedef="ND_subtract_color3FA" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_color4_genmdl" nodedef="ND_subtract_color4" sourcecode="mx_subtract({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_subtract_color4FA_genmdl" nodedef="ND_subtract_color4FA" sourcecode="mx_subtract({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_subtract_vector2_genmdl" nodedef="ND_subtract_vector2" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_vector2FA_genmdl" nodedef="ND_subtract_vector2FA" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_vector3_genmdl" nodedef="ND_subtract_vector3" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_vector3FA_genmdl" nodedef="ND_subtract_vector3FA" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_vector4_genmdl" nodedef="ND_subtract_vector4" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_vector4FA_genmdl" nodedef="ND_subtract_vector4FA" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_matrix33_genmdl" nodedef="ND_subtract_matrix33" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_matrix33FA_genmdl" nodedef="ND_subtract_matrix33FA" sourcecode="{{in1}} - float3x3({{in2}})" target="genmdl" />
  <implementation name="IM_subtract_matrix44_genmdl" nodedef="ND_subtract_matrix44" sourcecode="{{in1}} - {{in2}}" target="genmdl" />
  <implementation name="IM_subtract_matrix44FA_genmdl" nodedef="ND_subtract_matrix44FA" sourcecode="{{in1}} - float4x4({{in2}})" target="genmdl" />

  <!-- <multiply> -->
  <implementation name="IM_multiply_float_genmdl" nodedef="ND_multiply_float" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_color3_genmdl" nodedef="ND_multiply_color3" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_color3FA_genmdl" nodedef="ND_multiply_color3FA" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_color4_genmdl" nodedef="ND_multiply_color4" sourcecode="mx_multiply({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_multiply_color4FA_genmdl" nodedef="ND_multiply_color4FA" sourcecode="mx_multiply({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_multiply_vector2_genmdl" nodedef="ND_multiply_vector2" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_vector2FA_genmdl" nodedef="ND_multiply_vector2FA" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_vector3_genmdl" nodedef="ND_multiply_vector3" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_vector3FA_genmdl" nodedef="ND_multiply_vector3FA" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_vector4_genmdl" nodedef="ND_multiply_vector4" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_vector4FA_genmdl" nodedef="ND_multiply_vector4FA" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_matrix33_genmdl" nodedef="ND_multiply_matrix33" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_matrix44_genmdl" nodedef="ND_multiply_matrix44" sourcecode="{{in1}} * {{in2}}" target="genmdl" />
  <implementation name="IM_multiply_surfaceshaderF_genmdl" nodedef="ND_multiply_surfaceshaderF" sourcecode="mx::stdlib::mx_multiply_surfaceshaderF({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_multiply_surfaceshaderC_genmdl" nodedef="ND_multiply_surfaceshaderC" sourcecode="mx::stdlib::mx_multiply_surfaceshaderC({{in1}}, {{in2}})" target="genmdl" />

  <!-- <divide> -->
  <implementation name="IM_divide_float_genmdl" nodedef="ND_divide_float" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_color3_genmdl" nodedef="ND_divide_color3" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_color3FA_genmdl" nodedef="ND_divide_color3FA" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_color4_genmdl" nodedef="ND_divide_color4" sourcecode="mx_divide({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_divide_color4FA_genmdl" nodedef="ND_divide_color4FA" sourcecode="mx_divide({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_divide_vector2_genmdl" nodedef="ND_divide_vector2" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_vector2FA_genmdl" nodedef="ND_divide_vector2FA" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_vector3_genmdl" nodedef="ND_divide_vector3" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_vector3FA_genmdl" nodedef="ND_divide_vector3FA" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_vector4_genmdl" nodedef="ND_divide_vector4" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_vector4FA_genmdl" nodedef="ND_divide_vector4FA" sourcecode="{{in1}} / {{in2}}" target="genmdl" />
  <implementation name="IM_divide_matrix33_genmdl" nodedef="ND_divide_matrix33" sourcecode="{{in1}}" target="genmdl" /> <!-- TODO: Implement properly -->
  <implementation name="IM_divide_matrix44_genmdl" nodedef="ND_divide_matrix44" sourcecode="{{in1}}" target="genmdl" /> <!-- TODO: Implement properly -->

  <!-- <modulo> -->
  <implementation name="IM_modulo_float_genmdl" nodedef="ND_modulo_float" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_color3_genmdl" nodedef="ND_modulo_color3" sourcecode="mx::stdlib::mx_modulo_color3({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_color3FA_genmdl" nodedef="ND_modulo_color3FA" sourcecode="mx::stdlib::mx_modulo_color3FA({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_color4_genmdl" nodedef="ND_modulo_color4" sourcecode="mx::stdlib::mx_modulo_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_color4FA_genmdl" nodedef="ND_modulo_color4FA" sourcecode="mx::stdlib::mx_modulo_color4FA({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector2_genmdl" nodedef="ND_modulo_vector2" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector2FA_genmdl" nodedef="ND_modulo_vector2FA" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector3_genmdl" nodedef="ND_modulo_vector3" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector3FA_genmdl" nodedef="ND_modulo_vector3FA" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector4_genmdl" nodedef="ND_modulo_vector4" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_modulo_vector4FA_genmdl" nodedef="ND_modulo_vector4FA" sourcecode="mx_mod({{in1}}, {{in2}})" target="genmdl" />

  <!-- <invert> -->
  <implementation name="IM_invert_float_genmdl" nodedef="ND_invert_float" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_color3_genmdl" nodedef="ND_invert_color3" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_color3FA_genmdl" nodedef="ND_invert_color3FA" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_color4_genmdl" nodedef="ND_invert_color4" sourcecode="mx::stdlib::mx_invert_color4({{in}}, {{amount}})" target="genmdl" />
  <implementation name="IM_invert_color4FA_genmdl" nodedef="ND_invert_color4FA" sourcecode="mx::stdlib::mx_invert_color4FA({{in}}, {{amount}})" target="genmdl" />
  <implementation name="IM_invert_vector2_genmdl" nodedef="ND_invert_vector2" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_vector2FA_genmdl" nodedef="ND_invert_vector2FA" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_vector3_genmdl" nodedef="ND_invert_vector3" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_vector3FA_genmdl" nodedef="ND_invert_vector3FA" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_vector4_genmdl" nodedef="ND_invert_vector4" sourcecode="{{amount}} - {{in}}" target="genmdl" />
  <implementation name="IM_invert_vector4FA_genmdl" nodedef="ND_invert_vector4FA" sourcecode="{{amount}} - {{in}}" target="genmdl" />

  <!-- <absval> -->
  <implementation name="IM_absval_float_genmdl" nodedef="ND_absval_float" sourcecode="math::abs({{in}})" target="genmdl" />
  <implementation name="IM_absval_color3_genmdl" nodedef="ND_absval_color3" sourcecode="math::abs({{in}})" target="genmdl" />
  <implementation name="IM_absval_color4_genmdl" nodedef="ND_absval_color4" sourcecode="mx::stdlib::mx_absval_color4({{in}})" target="genmdl" />
  <implementation name="IM_absval_vector2_genmdl" nodedef="ND_absval_vector2" sourcecode="math::abs({{in}})" target="genmdl" />
  <implementation name="IM_absval_vector3_genmdl" nodedef="ND_absval_vector3" sourcecode="math::abs({{in}})" target="genmdl" />
  <implementation name="IM_absval_vector4_genmdl" nodedef="ND_absval_vector4" sourcecode="math::abs({{in}})" target="genmdl" />

  <!-- <floor> -->
  <implementation name="IM_floor_float_genmdl" nodedef="ND_floor_float" sourcecode="math::floor({{in}})" target="genmdl" />
  <implementation name="IM_floor_color3_genmdl" nodedef="ND_floor_color3" sourcecode="mx::stdlib::mx_floor_color3({{in}})" target="genmdl" />
  <implementation name="IM_floor_color4_genmdl" nodedef="ND_floor_color4" sourcecode="mx::stdlib::mx_floor_color4({{in}})" target="genmdl" />
  <implementation name="IM_floor_vector2_genmdl" nodedef="ND_floor_vector2" sourcecode="math::floor({{in}})" target="genmdl" />
  <implementation name="IM_floor_vector3_genmdl" nodedef="ND_floor_vector3" sourcecode="math::floor({{in}})" target="genmdl" />
  <implementation name="IM_floor_vector4_genmdl" nodedef="ND_floor_vector4" sourcecode="math::floor({{in}})" target="genmdl" />

  <!-- <ceil> -->
  <implementation name="IM_ceil_float_genmdl" nodedef="ND_ceil_float" sourcecode="math::ceil({{in}})" target="genmdl" />
  <implementation name="IM_ceil_color3_genmdl" nodedef="ND_ceil_color3" sourcecode="mx::stdlib::mx_ceil_color3({{in}})" target="genmdl" />
  <implementation name="IM_ceil_color4_genmdl" nodedef="ND_ceil_color4" sourcecode="mx::stdlib::mx_ceil_color4({{in}})" target="genmdl" />
  <implementation name="IM_ceil_vector2_genmdl" nodedef="ND_ceil_vector2" sourcecode="math::ceil({{in}})" target="genmdl" />
  <implementation name="IM_ceil_vector3_genmdl" nodedef="ND_ceil_vector3" sourcecode="math::ceil({{in}})" target="genmdl" />
  <implementation name="IM_ceil_vector4_genmdl" nodedef="ND_ceil_vector4" sourcecode="math::ceil({{in}})" target="genmdl" />

  <!-- <power> -->
  <implementation name="IM_power_float_genmdl" nodedef="ND_power_float" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_color3_genmdl" nodedef="ND_power_color3" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_color3FA_genmdl" nodedef="ND_power_color3FA" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_color4_genmdl" nodedef="ND_power_color4" sourcecode="mx::stdlib::mx_power_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_color4FA_genmdl" nodedef="ND_power_color4FA" sourcecode="mx::stdlib::mx_power_color4FA({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector2_genmdl" nodedef="ND_power_vector2" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector2FA_genmdl" nodedef="ND_power_vector2FA" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector3_genmdl" nodedef="ND_power_vector3" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector3FA_genmdl" nodedef="ND_power_vector3FA" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector4_genmdl" nodedef="ND_power_vector4" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_power_vector4FA_genmdl" nodedef="ND_power_vector4FA" sourcecode="math::pow({{in1}}, {{in2}})" target="genmdl" />

  <!-- <sin>, <cos>, <tan>, <asin>, <acos>, <atan2> -->
  <implementation name="IM_sin_float_genmdl" nodedef="ND_sin_float" sourcecode="math::sin({{in}})" target="genmdl" />
  <implementation name="IM_cos_float_genmdl" nodedef="ND_cos_float" sourcecode="math::cos({{in}})" target="genmdl" />
  <implementation name="IM_tan_float_genmdl" nodedef="ND_tan_float" sourcecode="math::tan({{in}})" target="genmdl" />
  <implementation name="IM_asin_float_genmdl" nodedef="ND_asin_float" sourcecode="math::asin({{in}})" target="genmdl" />
  <implementation name="IM_acos_float_genmdl" nodedef="ND_acos_float" sourcecode="math::acos({{in}})" target="genmdl" />
  <implementation name="IM_atan2_float_genmdl" nodedef="ND_atan2_float" sourcecode="math::atan2({{in1}}, {{in2}})" target="genmdl" />

  <implementation name="IM_sin_vector2_genmdl" nodedef="ND_sin_vector2" sourcecode="math::sin({{in}})" target="genmdl" />
  <implementation name="IM_cos_vector2_genmdl" nodedef="ND_cos_vector2" sourcecode="math::cos({{in}})" target="genmdl" />
  <implementation name="IM_tan_vector2_genmdl" nodedef="ND_tan_vector2" sourcecode="math::tan({{in}})" target="genmdl" />
  <implementation name="IM_asin_vector2_genmdl" nodedef="ND_asin_vector2" sourcecode="math::asin({{in}})" target="genmdl" />
  <implementation name="IM_acos_vector2_genmdl" nodedef="ND_acos_vector2" sourcecode="math::acos({{in}})" target="genmdl" />
  <implementation name="IM_atan2_vector2_genmdl" nodedef="ND_atan2_vector2" sourcecode="math::atan2({{in1}}, {{in2}})" target="genmdl" />

  <implementation name="IM_sin_vector3_genmdl" nodedef="ND_sin_vector3" sourcecode="math::sin({{in}})" target="genmdl" />
  <implementation name="IM_cos_vector3_genmdl" nodedef="ND_cos_vector3" sourcecode="math::cos({{in}})" target="genmdl" />
  <implementation name="IM_tan_vector3_genmdl" nodedef="ND_tan_vector3" sourcecode="math::tan({{in}})" target="genmdl" />
  <implementation name="IM_asin_vector3_genmdl" nodedef="ND_asin_vector3" sourcecode="math::asin({{in}})" target="genmdl" />
  <implementation name="IM_acos_vector3_genmdl" nodedef="ND_acos_vector3" sourcecode="math::acos({{in}})" target="genmdl" />
  <implementation name="IM_atan2_vector3_genmdl" nodedef="ND_atan2_vector3" sourcecode="math::atan2({{in1}}, {{in2}})" target="genmdl" />

  <implementation name="IM_sin_vector4_genmdl" nodedef="ND_sin_vector4" sourcecode="math::sin({{in}})" target="genmdl" />
  <implementation name="IM_cos_vector4_genmdl" nodedef="ND_cos_vector4" sourcecode="math::cos({{in}})" target="genmdl" />
  <implementation name="IM_tan_vector4_genmdl" nodedef="ND_tan_vector4" sourcecode="math::tan({{in}})" target="genmdl" />
  <implementation name="IM_asin_vector4_genmdl" nodedef="ND_asin_vector4" sourcecode="math::asin({{in}})" target="genmdl" />
  <implementation name="IM_acos_vector4_genmdl" nodedef="ND_acos_vector4" sourcecode="math::acos({{in}})" target="genmdl" />
  <implementation name="IM_atan2_vector4_genmdl" nodedef="ND_atan2_vector4" sourcecode="math::atan2({{in1}}, {{in2}})" target="genmdl" />

  <!-- <sqrt> -->
  <implementation name="IM_sqrt_float_genmdl" nodedef="ND_sqrt_float" sourcecode="math::sqrt({{in}})" target="genmdl" />
  <implementation name="IM_sqrt_vector2_genmdl" nodedef="ND_sqrt_vector2" sourcecode="math::sqrt({{in}})" target="genmdl" />
  <implementation name="IM_sqrt_vector3_genmdl" nodedef="ND_sqrt_vector3" sourcecode="math::sqrt({{in}})" target="genmdl" />
  <implementation name="IM_sqrt_vector4_genmdl" nodedef="ND_sqrt_vector4" sourcecode="math::sqrt({{in}})" target="genmdl" />

  <!-- <ln> -->
  <implementation name="IM_ln_float_genmdl" nodedef="ND_ln_float" sourcecode="math::log({{in}})" target="genmdl" />
  <implementation name="IM_ln_vector2_genmdl" nodedef="ND_ln_vector2" sourcecode="math::log({{in}})" target="genmdl" />
  <implementation name="IM_ln_vector3_genmdl" nodedef="ND_ln_vector3" sourcecode="math::log({{in}})" target="genmdl" />
  <implementation name="IM_ln_vector4_genmdl" nodedef="ND_ln_vector4" sourcecode="math::log({{in}})" target="genmdl" />

  <!-- <exp> -->
  <implementation name="IM_exp_float_genmdl" nodedef="ND_exp_float" sourcecode="math::exp({{in}})" target="genmdl" />
  <implementation name="IM_exp_vector2_genmdl" nodedef="ND_exp_vector2" sourcecode="math::exp({{in}})" target="genmdl" />
  <implementation name="IM_exp_vector3_genmdl" nodedef="ND_exp_vector3" sourcecode="math::exp({{in}})" target="genmdl" />
  <implementation name="IM_exp_vector4_genmdl" nodedef="ND_exp_vector4" sourcecode="math::exp({{in}})" target="genmdl" />

  <!-- sign -->
  <implementation name="IM_sign_float_genmdl" nodedef="ND_sign_float" sourcecode="math::sign({{in}})" target="genmdl" />
  <implementation name="IM_sign_color3_genmdl" nodedef="ND_sign_color3" sourcecode="mx::stdlib::mx_sign_color3({{in}})" target="genmdl" />
  <implementation name="IM_sign_color4_genmdl" nodedef="ND_sign_color4" sourcecode="mx::stdlib::mx_sign_color4({{in}})" target="genmdl" />
  <implementation name="IM_sign_vector2_genmdl" nodedef="ND_sign_vector2" sourcecode="math::sign({{in}})" target="genmdl" />
  <implementation name="IM_sign_vector3_genmdl" nodedef="ND_sign_vector3" sourcecode="math::sign({{in}})" target="genmdl" />
  <implementation name="IM_sign_vector4_genmdl" nodedef="ND_sign_vector4" sourcecode="math::sign({{in}})" target="genmdl" />

  <!-- <clamp> -->
  <implementation name="IM_clamp_float_genmdl" nodedef="ND_clamp_float" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_color3_genmdl" nodedef="ND_clamp_color3" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_color3FA_genmdl" nodedef="ND_clamp_color3FA" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_color4_genmdl" nodedef="ND_clamp_color4" sourcecode="mx::stdlib::mx_clamp_color4({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_color4FA_genmdl" nodedef="ND_clamp_color4FA" sourcecode="mx::stdlib::mx_clamp_color4FA({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector2_genmdl" nodedef="ND_clamp_vector2" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector2FA_genmdl" nodedef="ND_clamp_vector2FA" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector3_genmdl" nodedef="ND_clamp_vector3" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector3FA_genmdl" nodedef="ND_clamp_vector3FA" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector4_genmdl" nodedef="ND_clamp_vector4" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_clamp_vector4FA_genmdl" nodedef="ND_clamp_vector4FA" sourcecode="math::clamp({{in}}, {{low}}, {{high}})" target="genmdl" />

  <!-- <min> -->
  <implementation name="IM_min_float_genmdl" nodedef="ND_min_float" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_color3_genmdl" nodedef="ND_min_color3" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_color3FA_genmdl" nodedef="ND_min_color3FA" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_color4_genmdl" nodedef="ND_min_color4" sourcecode="mx::stdlib::mx_min_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_color4FA_genmdl" nodedef="ND_min_color4FA" sourcecode="mx::stdlib::mx_min_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector2_genmdl" nodedef="ND_min_vector2" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector2FA_genmdl" nodedef="ND_min_vector2FA" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector3_genmdl" nodedef="ND_min_vector3" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector3FA_genmdl" nodedef="ND_min_vector3FA" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector4_genmdl" nodedef="ND_min_vector4" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_min_vector4FA_genmdl" nodedef="ND_min_vector4FA" sourcecode="math::min({{in1}}, {{in2}})" target="genmdl" />

  <!-- <max> -->
  <implementation name="IM_max_float_genmdl" nodedef="ND_max_float" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_color3_genmdl" nodedef="ND_max_color3" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_color3FA_genmdl" nodedef="ND_max_color3FA" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_color4_genmdl" nodedef="ND_max_color4" sourcecode="mx::stdlib::mx_max_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_color4FA_genmdl" nodedef="ND_max_color4FA" sourcecode="mx::stdlib::mx_max_color4({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector2_genmdl" nodedef="ND_max_vector2" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector2FA_genmdl" nodedef="ND_max_vector2FA" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector3_genmdl" nodedef="ND_max_vector3" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector3FA_genmdl" nodedef="ND_max_vector3FA" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector4_genmdl" nodedef="ND_max_vector4" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_max_vector4FA_genmdl" nodedef="ND_max_vector4FA" sourcecode="math::max({{in1}}, {{in2}})" target="genmdl" />

  <!-- <normalize> -->
  <implementation name="IM_normalize_vector2_genmdl" nodedef="ND_normalize_vector2" sourcecode="math::normalize({{in}})" target="genmdl" />
  <implementation name="IM_normalize_vector3_genmdl" nodedef="ND_normalize_vector3" sourcecode="math::normalize({{in}})" target="genmdl" />
  <implementation name="IM_normalize_vector4_genmdl" nodedef="ND_normalize_vector4" sourcecode="math::normalize({{in}})" target="genmdl" />

  <!-- <magnitude> -->
  <implementation name="IM_magnitude_vector2_genmdl" nodedef="ND_magnitude_vector2" sourcecode="math::length({{in}})" target="genmdl" />
  <implementation name="IM_magnitude_vector3_genmdl" nodedef="ND_magnitude_vector3" sourcecode="math::length({{in}})" target="genmdl" />
  <implementation name="IM_magnitude_vector4_genmdl" nodedef="ND_magnitude_vector4" sourcecode="math::length({{in}})" target="genmdl" />

  <!-- <dotproduct> -->
  <implementation name="IM_dotproduct_vector2_genmdl" nodedef="ND_dotproduct_vector2" sourcecode="math::dot({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_dotproduct_vector3_genmdl" nodedef="ND_dotproduct_vector3" sourcecode="math::dot({{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_dotproduct_vector4_genmdl" nodedef="ND_dotproduct_vector4" sourcecode="math::dot({{in1}}, {{in2}})" target="genmdl" />

  <!-- <crossproduct> -->
  <implementation name="IM_crossproduct_vector3_genmdl" nodedef="ND_crossproduct_vector3" sourcecode="math::cross({{in1}}, {{in2}})" target="genmdl" />

  <!-- <transformpoint> -->
  <implementation name="IM_transformpoint_vector3_genmdl" nodedef="ND_transformpoint_vector3" sourcecode="mx::stdlib::mx_transformpoint_vector3({{in}}, {{fromspace}}, {{tospace}})" target="genmdl" />

  <!-- <transformvector> -->
  <implementation name="IM_transformvector_vector3_genmdl" nodedef="ND_transformvector_vector3" sourcecode="mx::stdlib::mx_transformvector_vector3({{in}}, {{fromspace}}, {{tospace}})" target="genmdl" />

  <!-- <transformnormal> -->
  <implementation name="IM_transformnormal_vector3_genmdl" nodedef="ND_transformnormal_vector3" sourcecode="mx::stdlib::mx_transformnormal_vector3({{in}}, {{fromspace}}, {{tospace}})" target="genmdl" />

  <!-- <transformmatrix> -->
  <implementation name="IM_transformmatrix_vector2M3_genmdl" nodedef="ND_transformmatrix_vector2M3" sourcecode="mx::stdlib::mx_transformmatrix_vector2M3({{in}}, {{mat}})" target="genmdl" />
  <implementation name="IM_transformmatrix_vector3_genmdl" nodedef="ND_transformmatrix_vector3" sourcecode="mx::stdlib::mx_transformmatrix_vector3({{in}}, {{mat}})" target="genmdl" />
  <implementation name="IM_transformmatrix_vector3M4_genmdl" nodedef="ND_transformmatrix_vector3M4" sourcecode="mx::stdlib::mx_transformmatrix_vector3M4({{in}}, {{mat}})" target="genmdl" />
  <implementation name="IM_transformmatrix_vector4_genmdl" nodedef="ND_transformmatrix_vector4" sourcecode="mx::stdlib::mx_transformmatrix_vector4({{in}}, {{mat}})" target="genmdl" />

  <!-- <transpose> -->
  <implementation name="IM_transpose_matrix33_genmdl" nodedef="ND_transpose_matrix33" sourcecode="math::transpose({{in}})" target="genmdl" />
  <implementation name="IM_transpose_matrix44_genmdl" nodedef="ND_transpose_matrix44" sourcecode="math::transpose({{in}})" target="genmdl" />

  <!-- <determinant> -->
  <implementation name="IM_determinant_matrix33_genmdl" nodedef="ND_determinant_matrix33" sourcecode="mx::stdlib::mx_determinant_matrix33({{in}})" target="genmdl" />
  <implementation name="IM_determinant_matrix44_genmdl" nodedef="ND_determinant_matrix44" sourcecode="mx::stdlib::mx_determinant_matrix44({{in}})" target="genmdl" />

  <!-- <invertmatrix> -->
  <implementation name="IM_invertmatrix_matrix33_genmdl" nodedef="ND_invertmatrix_matrix33" sourcecode="mx::stdlib::mx_invertmatrix_matrix33({{in}})" target="genmdl" />
  <implementation name="IM_invertmatrix_matrix44_genmdl" nodedef="ND_invertmatrix_matrix44" sourcecode="mx::stdlib::mx_invertmatrix_matrix44({{in}})" target="genmdl" />

  <!-- <rotate2d> -->
  <implementation name="IM_rotate2d_vector2_genmdl" nodedef="ND_rotate2d_vector2" sourcecode="mx::stdlib::mx_rotate2d_vector2(mxp_in:{{in}}, mxp_amount:{{amount}})" target="genmdl" />

  <!-- <rotate3d> -->
  <implementation name="IM_rotate3d_vector3_genmdl" nodedef="ND_rotate3d_vector3" sourcecode="mx::stdlib::mx_rotate3d_vector3(mxp_in:{{in}}, mxp_amount:{{amount}}, mxp_axis:{{axis}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Adjustment nodes                                                         -->
  <!-- ======================================================================== -->

  <!-- <contrast> implemented by nodegraph -->

  <!-- <remap> implemented -->
  <implementation name="IM_remap_float_genmdl" nodedef="ND_remap_float" sourcecode="mx::stdlib::mx_remap_float({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_color3_genmdl" nodedef="ND_remap_color3" sourcecode="mx::stdlib::mx_remap_color3({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_color4_genmdl" nodedef="ND_remap_color4" sourcecode="mx::stdlib::mx_remap_color4({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector2_genmdl" nodedef="ND_remap_vector2" sourcecode="mx::stdlib::mx_remap_vector2({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector3_genmdl" nodedef="ND_remap_vector3" sourcecode="mx::stdlib::mx_remap_vector3({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector4_genmdl" nodedef="ND_remap_vector4" sourcecode="mx::stdlib::mx_remap_vector4({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_color3FA_genmdl" nodedef="ND_remap_color3FA" sourcecode="mx::stdlib::mx_remap_color3FA({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_color4FA_genmdl" nodedef="ND_remap_color4FA" sourcecode="mx::stdlib::mx_remap_color4FA({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector2FA_genmdl" nodedef="ND_remap_vector2FA" sourcecode="mx::stdlib::mx_remap_vector2FA({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector3FA_genmdl" nodedef="ND_remap_vector3FA" sourcecode="mx::stdlib::mx_remap_vector3FA({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />
  <implementation name="IM_remap_vector4FA_genmdl" nodedef="ND_remap_vector4FA" sourcecode="mx::stdlib::mx_remap_vector4FA({{in}}, {{inlow}}, {{inhigh}}, {{outlow}}, {{outhigh}})" target="genmdl" />

  <!-- <smoothstep> -->
  <implementation name="IM_smoothstep_float_genmdl" nodedef="ND_smoothstep_float" sourcecode="mx::stdlib::mx_smoothstep_float({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_color3_genmdl" nodedef="ND_smoothstep_color3" sourcecode="mx::stdlib::mx_smoothstep_color3({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_color4_genmdl" nodedef="ND_smoothstep_color4" sourcecode="mx::stdlib::mx_smoothstep_color4({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector2_genmdl" nodedef="ND_smoothstep_vector2" sourcecode="mx::stdlib::mx_smoothstep_vector2({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector3_genmdl" nodedef="ND_smoothstep_vector3" sourcecode="mx::stdlib::mx_smoothstep_vector3({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector4_genmdl" nodedef="ND_smoothstep_vector4" sourcecode="mx::stdlib::mx_smoothstep_vector4({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_color3FA_genmdl" nodedef="ND_smoothstep_color3FA" sourcecode="mx::stdlib::mx_smoothstep_color3FA({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_color4FA_genmdl" nodedef="ND_smoothstep_color4FA" sourcecode="mx::stdlib::mx_smoothstep_color4FA({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector2FA_genmdl" nodedef="ND_smoothstep_vector2FA" sourcecode="mx::stdlib::mx_smoothstep_vector2FA({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector3FA_genmdl" nodedef="ND_smoothstep_vector3FA" sourcecode="mx::stdlib::mx_smoothstep_vector3FA({{in}}, {{low}}, {{high}})" target="genmdl" />
  <implementation name="IM_smoothstep_vector4FA_genmdl" nodedef="ND_smoothstep_vector4FA" sourcecode="mx::stdlib::mx_smoothstep_vector4FA({{in}}, {{low}}, {{high}})" target="genmdl" />

  <!-- <saturate> implemented by nodegraph -->

  <!-- <luminance>  -->
  <implementation name="IM_luminance_color3_genmdl" nodedef="ND_luminance_color3" sourcecode="mx::stdlib::mx_luminance_color3({{in}})" target="genmdl" />
  <implementation name="IM_luminance_color4_genmdl" nodedef="ND_luminance_color4" sourcecode="mx::stdlib::mx_luminance_color4({{in}})" target="genmdl" />

  <!-- <rgbtohsv> -->
  <implementation name="IM_rgbtohsv_color3_genmdl" nodedef="ND_rgbtohsv_color3" sourcecode="mx::stdlib::mx_rgbtohsv_color3({{in}})" target="genmdl" />
  <implementation name="IM_rgbtohsv_color4_genmdl" nodedef="ND_rgbtohsv_color4" sourcecode="mx::stdlib::mx_rgbtohsv_color4({{in}})" target="genmdl" />

  <!-- <hsvtorgb> -->
  <implementation name="IM_hsvtorgb_color3_genmdl" nodedef="ND_hsvtorgb_color3" sourcecode="mx::stdlib::mx_hsvtorgb_color3({{in}})" target="genmdl" />
  <implementation name="IM_hsvtorgb_color4_genmdl" nodedef="ND_hsvtorgb_color4" sourcecode="mx::stdlib::mx_hsvtorgb_color4({{in}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Compositing nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <premult> -->
  <implementation name="IM_premult_color4_genmdl" nodedef="ND_premult_color4" sourcecode="mx::stdlib::mx_premult_color4({{in}})" target="genmdl" />

  <!-- <unpremult> -->
  <implementation name="IM_unpremult_color4_genmdl" nodedef="ND_unpremult_color4" sourcecode="mx::stdlib::mx_unpremult_color4({{in}})" target="genmdl" />

  <!-- <plus> -->
  <implementation name="IM_plus_float_genmdl" nodedef="ND_plus_float" sourcecode="({{mix}}*({{bg}} + {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_plus_color3_genmdl" nodedef="ND_plus_color3" sourcecode="({{mix}}*({{bg}} + {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_plus_color4_genmdl" nodedef="ND_plus_color4" sourcecode="mx::stdlib::mx_plus_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <minus> -->
  <implementation name="IM_minus_float_genmdl" nodedef="ND_minus_float" sourcecode="({{mix}}*({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_minus_color3_genmdl" nodedef="ND_minus_color3" sourcecode="({{mix}}*({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_minus_color4_genmdl" nodedef="ND_minus_color4" sourcecode="mx::stdlib::mx_minus_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <difference> -->
  <implementation name="IM_difference_float_genmdl" nodedef="ND_difference_float" sourcecode="({{mix}}*math::abs({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_difference_color3_genmdl" nodedef="ND_difference_color3" sourcecode="({{mix}}*math::abs({{bg}} - {{fg}})) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_difference_color4_genmdl" nodedef="ND_difference_color4" sourcecode="mx::stdlib::mx_difference_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <burn> -->
  <implementation name="IM_burn_float_genmdl" nodedef="ND_burn_float" sourcecode="mx::stdlib::mx_burn_float({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_burn_color3_genmdl" nodedef="ND_burn_color3" sourcecode="mx::stdlib::mx_burn_color3({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_burn_color4_genmdl" nodedef="ND_burn_color4" sourcecode="mx::stdlib::mx_burn_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <dodge> -->
  <implementation name="IM_dodge_float_genmdl" nodedef="ND_dodge_float" sourcecode="mx::stdlib::mx_dodge_float({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_dodge_color3_genmdl" nodedef="ND_dodge_color3" sourcecode="mx::stdlib::mx_dodge_color3({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_dodge_color4_genmdl" nodedef="ND_dodge_color4" sourcecode="mx::stdlib::mx_dodge_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <screen> -->
  <implementation name="IM_screen_float_genmdl" nodedef="ND_screen_float" sourcecode="({{mix}}*((1.0 - (1.0 - {{fg}})) * (1 - {{bg}}))) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_screen_color3_genmdl" nodedef="ND_screen_color3" sourcecode="({{mix}}*((1.0 - (1.0 - {{fg}})) * (1 - {{bg}}))) + ((1.0-{{mix}})*{{bg}})" target="genmdl" />
  <implementation name="IM_screen_color4_genmdl" nodedef="ND_screen_color4" sourcecode="mx::stdlib::mx_screen_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <overlay> -->
  <implementation name="IM_overlay_float_genmdl" nodedef="ND_overlay_float" sourcecode="mx::stdlib::mx_overlay_float({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_overlay_color3_genmdl" nodedef="ND_overlay_color3" sourcecode="mx::stdlib::mx_overlay_color3({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_overlay_color4_genmdl" nodedef="ND_overlay_color4" sourcecode="mx::stdlib::mx_overlay_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <disjointover> -->
  <implementation name="IM_disjointover_color4_genmdl" nodedef="ND_disjointover_color4" sourcecode="mx::stdlib::mx_disjointover_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <in> -->
  <implementation name="IM_in_color4_genmdl" nodedef="ND_in_color4" sourcecode="mx::stdlib::mx_in_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <mask> -->
  <implementation name="IM_mask_color4_genmdl" nodedef="ND_mask_color4" sourcecode="mx::stdlib::mx_mask_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <matte> -->
  <implementation name="IM_matte_color4_genmdl" nodedef="ND_matte_color4" sourcecode="mx::stdlib::mx_matte_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <out> -->
  <implementation name="IM_out_color4_genmdl" nodedef="ND_out_color4" sourcecode="mx::stdlib::mx_out_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <over> -->
  <implementation name="IM_over_color4_genmdl" nodedef="ND_over_color4" sourcecode="mx::stdlib::mx_over_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- <inside> -->
  <implementation name="IM_inside_float_genmdl" nodedef="ND_inside_float" sourcecode="{{in}} * {{mask}}" target="genmdl" />
  <implementation name="IM_inside_color3_genmdl" nodedef="ND_inside_color3" sourcecode="{{in}} * {{mask}}" target="genmdl" />
  <implementation name="IM_inside_color4_genmdl" nodedef="ND_inside_color4" sourcecode="mx_multiply({{in}}, {{mask}})" target="genmdl" />

  <!-- <outside> -->
  <implementation name="IM_outside_float_genmdl" nodedef="ND_outside_float" sourcecode="{{in}} * (1.0 - {{mask}})" target="genmdl" />
  <implementation name="IM_outside_color3_genmdl" nodedef="ND_outside_color3" sourcecode="{{in}} * (1.0 - {{mask}})" target="genmdl" />
  <implementation name="IM_outside_color4_genmdl" nodedef="ND_outside_color4" sourcecode="mx_multiply({{in}}, 1.0 - {{mask}})" target="genmdl" />

  <!-- <mix> -->
  <implementation name="IM_mix_float_genmdl" nodedef="ND_mix_float" sourcecode="math::lerp({{bg}}, {{fg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_color3_genmdl" nodedef="ND_mix_color3" sourcecode="math::lerp({{bg}}, {{fg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_color4_genmdl" nodedef="ND_mix_color4" sourcecode="mx::stdlib::mx_mix_color4({{fg}}, {{bg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_vector2_genmdl" nodedef="ND_mix_vector2" sourcecode="math::lerp({{bg}}, {{fg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_vector3_genmdl" nodedef="ND_mix_vector3" sourcecode="math::lerp({{bg}}, {{fg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_vector4_genmdl" nodedef="ND_mix_vector4" sourcecode="math::lerp({{bg}}, {{fg}}, {{mix}})" target="genmdl" />
  <implementation name="IM_mix_surfaceshader_genmdl" nodedef="ND_mix_surfaceshader" sourcecode="mx::pbrlib::mx_mix_bsdf({{fg}}, {{bg}}, {{mix}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Conditional nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <ifgreater> -->
  <implementation name="IM_ifgreater_float_genmdl" nodedef="ND_ifgreater_float" sourcecode="mx::stdlib::mx_ifgreater_float({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_color3_genmdl" nodedef="ND_ifgreater_color3" sourcecode="mx::stdlib::mx_ifgreater_color3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_color4_genmdl" nodedef="ND_ifgreater_color4" sourcecode="mx::stdlib::mx_ifgreater_color4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector2_genmdl" nodedef="ND_ifgreater_vector2" sourcecode="mx::stdlib::mx_ifgreater_vector2({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector3_genmdl" nodedef="ND_ifgreater_vector3" sourcecode="mx::stdlib::mx_ifgreater_vector3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector4_genmdl" nodedef="ND_ifgreater_vector4" sourcecode="mx::stdlib::mx_ifgreater_vector4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_floatI_genmdl" nodedef="ND_ifgreater_floatI" sourcecode="mx::stdlib::mx_ifgreater_floatI({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_color3I_genmdl" nodedef="ND_ifgreater_color3I" sourcecode="mx::stdlib::mx_ifgreater_color3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_color4I_genmdl" nodedef="ND_ifgreater_color4I" sourcecode="mx::stdlib::mx_ifgreater_color4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector2I_genmdl" nodedef="ND_ifgreater_vector2I" sourcecode="mx::stdlib::mx_ifgreater_vector2I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector3I_genmdl" nodedef="ND_ifgreater_vector3I" sourcecode="mx::stdlib::mx_ifgreater_vector3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreater_vector4I_genmdl" nodedef="ND_ifgreater_vector4I" sourcecode="mx::stdlib::mx_ifgreater_vector4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />

  <!-- <ifgreatereq> -->
  <implementation name="IM_ifgreatereq_float_genmdl" nodedef="ND_ifgreatereq_float" sourcecode="mx::stdlib::mx_ifgreatereq_float({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_color3_genmdl" nodedef="ND_ifgreatereq_color3" sourcecode="mx::stdlib::mx_ifgreatereq_color3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_color4_genmdl" nodedef="ND_ifgreatereq_color4" sourcecode="mx::stdlib::mx_ifgreatereq_color4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector2_genmdl" nodedef="ND_ifgreatereq_vector2" sourcecode="mx::stdlib::mx_ifgreatereq_vector2({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector3_genmdl" nodedef="ND_ifgreatereq_vector3" sourcecode="mx::stdlib::mx_ifgreatereq_vector3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector4_genmdl" nodedef="ND_ifgreatereq_vector4" sourcecode="mx::stdlib::mx_ifgreatereq_vector4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_floatI_genmdl" nodedef="ND_ifgreatereq_floatI" sourcecode="mx::stdlib::mx_ifgreatereq_floatI({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_color3I_genmdl" nodedef="ND_ifgreatereq_color3I" sourcecode="mx::stdlib::mx_ifgreatereq_color3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_color4I_genmdl" nodedef="ND_ifgreatereq_color4I" sourcecode="mx::stdlib::mx_ifgreatereq_color4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector2I_genmdl" nodedef="ND_ifgreatereq_vector2I" sourcecode="mx::stdlib::mx_ifgreatereq_vector2I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector3I_genmdl" nodedef="ND_ifgreatereq_vector3I" sourcecode="mx::stdlib::mx_ifgreatereq_vector3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifgreatereq_vector4I_genmdl" nodedef="ND_ifgreatereq_vector4I" sourcecode="mx::stdlib::mx_ifgreatereq_vector4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />

  <!-- <ifequal> -->
  <implementation name="IM_ifequal_float_genmdl" nodedef="ND_ifequal_float" sourcecode="mx::stdlib::mx_ifequal_float({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color3_genmdl" nodedef="ND_ifequal_color3" sourcecode="mx::stdlib::mx_ifequal_color3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color4_genmdl" nodedef="ND_ifequal_color4" sourcecode="mx::stdlib::mx_ifequal_color4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector2_genmdl" nodedef="ND_ifequal_vector2" sourcecode="mx::stdlib::mx_ifequal_vector2({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector3_genmdl" nodedef="ND_ifequal_vector3" sourcecode="mx::stdlib::mx_ifequal_vector3({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector4_genmdl" nodedef="ND_ifequal_vector4" sourcecode="mx::stdlib::mx_ifequal_vector4({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_floatI_genmdl" nodedef="ND_ifequal_floatI" sourcecode="mx::stdlib::mx_ifequal_floatI({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color3I_genmdl" nodedef="ND_ifequal_color3I" sourcecode="mx::stdlib::mx_ifequal_color3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color4I_genmdl" nodedef="ND_ifequal_color4I" sourcecode="mx::stdlib::mx_ifequal_color4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector2I_genmdl" nodedef="ND_ifequal_vector2I" sourcecode="mx::stdlib::mx_ifequal_vector2I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector3I_genmdl" nodedef="ND_ifequal_vector3I" sourcecode="mx::stdlib::mx_ifequal_vector3I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector4I_genmdl" nodedef="ND_ifequal_vector4I" sourcecode="mx::stdlib::mx_ifequal_vector4I({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_floatB_genmdl" nodedef="ND_ifequal_floatB" sourcecode="mx::stdlib::mx_ifequal_floatB({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color3B_genmdl" nodedef="ND_ifequal_color3B" sourcecode="mx::stdlib::mx_ifequal_color3B({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_color4B_genmdl" nodedef="ND_ifequal_color4B" sourcecode="mx::stdlib::mx_ifequal_color4B({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector2B_genmdl" nodedef="ND_ifequal_vector2B" sourcecode="mx::stdlib::mx_ifequal_vector2B({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector3B_genmdl" nodedef="ND_ifequal_vector3B" sourcecode="mx::stdlib::mx_ifequal_vector3B({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />
  <implementation name="IM_ifequal_vector4B_genmdl" nodedef="ND_ifequal_vector4B" sourcecode="mx::stdlib::mx_ifequal_vector4B({{value1}}, {{value2}}, {{in1}}, {{in2}})" target="genmdl" />

  <!-- <switch> -->
  <!-- 'which' type : float -->
  <implementation name="IM_switch_float_genmdl" nodedef="ND_switch_float" sourcecode="mx::stdlib::mx_switch_float({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_color3_genmdl" nodedef="ND_switch_color3" sourcecode="mx::stdlib::mx_switch_color3({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_color4_genmdl" nodedef="ND_switch_color4" sourcecode="mx::stdlib::mx_switch_color4({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector2_genmdl" nodedef="ND_switch_vector2" sourcecode="mx::stdlib::mx_switch_vector2({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector3_genmdl" nodedef="ND_switch_vector3" sourcecode="mx::stdlib::mx_switch_vector3({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector4_genmdl" nodedef="ND_switch_vector4" sourcecode="mx::stdlib::mx_switch_vector4({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <!-- 'which' type : integer -->
  <implementation name="IM_switch_floatI_genmdl" nodedef="ND_switch_floatI" sourcecode="mx::stdlib::mx_switch_floatI({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_color3I_genmdl" nodedef="ND_switch_color3I" sourcecode="mx::stdlib::mx_switch_color3I({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_color4I_genmdl" nodedef="ND_switch_color4I" sourcecode="mx::stdlib::mx_switch_color4I({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector2I_genmdl" nodedef="ND_switch_vector2I" sourcecode="mx::stdlib::mx_switch_vector2I({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector3I_genmdl" nodedef="ND_switch_vector3I" sourcecode="mx::stdlib::mx_switch_vector3I({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />
  <implementation name="IM_switch_vector4I_genmdl" nodedef="ND_switch_vector4I" sourcecode="mx::stdlib::mx_switch_vector4I({{in1}}, {{in2}}, {{in3}}, {{in4}}, {{in5}}, {{which}})" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Channel nodes                                                            -->
  <!-- ======================================================================== -->

  <!-- <convert> -->
  <implementation name="IM_convert_float_color3_genmdl" nodedef="ND_convert_float_color3" target="genmdl" />
  <implementation name="IM_convert_float_color4_genmdl" nodedef="ND_convert_float_color4" target="genmdl" />
  <implementation name="IM_convert_float_vector2_genmdl" nodedef="ND_convert_float_vector2" target="genmdl" />
  <implementation name="IM_convert_float_vector3_genmdl" nodedef="ND_convert_float_vector3" target="genmdl" />
  <implementation name="IM_convert_float_vector4_genmdl" nodedef="ND_convert_float_vector4" target="genmdl" />
  <implementation name="IM_convert_vector2_vector3_genmdl" nodedef="ND_convert_vector2_vector3" target="genmdl" />
  <implementation name="IM_convert_vector3_color3_genmdl" nodedef="ND_convert_vector3_color3" target="genmdl" />
  <implementation name="IM_convert_vector3_vector2_genmdl" nodedef="ND_convert_vector3_vector2" target="genmdl" />
  <implementation name="IM_convert_vector3_vector4_genmdl" nodedef="ND_convert_vector3_vector4" target="genmdl" />
  <implementation name="IM_convert_vector4_color4_genmdl" nodedef="ND_convert_vector4_color4" target="genmdl" />
  <implementation name="IM_convert_vector4_vector3_genmdl" nodedef="ND_convert_vector4_vector3" target="genmdl" />
  <implementation name="IM_convert_color3_vector3_genmdl" nodedef="ND_convert_color3_vector3" target="genmdl" />
  <implementation name="IM_convert_color4_vector4_genmdl" nodedef="ND_convert_color4_vector4" target="genmdl" />
  <implementation name="IM_convert_color3_color4_genmdl" nodedef="ND_convert_color3_color4" target="genmdl" />
  <implementation name="IM_convert_color4_color3_genmdl" nodedef="ND_convert_color4_color3" target="genmdl" />
  <implementation name="IM_convert_boolean_float_genmdl" nodedef="ND_convert_boolean_float" target="genmdl" />
  <implementation name="IM_convert_integer_float_genmdl" nodedef="ND_convert_integer_float" target="genmdl" />

  <!-- <swizzle> -->
  <implementation name="IM_swizzle_float_color3_genmdl" nodedef="ND_swizzle_float_color3" target="genmdl" />
  <implementation name="IM_swizzle_float_color4_genmdl" nodedef="ND_swizzle_float_color4" target="genmdl" />
  <implementation name="IM_swizzle_float_vector2_genmdl" nodedef="ND_swizzle_float_vector2" target="genmdl" />
  <implementation name="IM_swizzle_float_vector3_genmdl" nodedef="ND_swizzle_float_vector3" target="genmdl" />
  <implementation name="IM_swizzle_float_vector4_genmdl" nodedef="ND_swizzle_float_vector4" target="genmdl" />
  <implementation name="IM_swizzle_color3_float_genmdl" nodedef="ND_swizzle_color3_float" target="genmdl" />
  <implementation name="IM_swizzle_color3_color3_genmdl" nodedef="ND_swizzle_color3_color3" target="genmdl" />
  <implementation name="IM_swizzle_color3_color4_genmdl" nodedef="ND_swizzle_color3_color4" target="genmdl" />
  <implementation name="IM_swizzle_color3_vector2_genmdl" nodedef="ND_swizzle_color3_vector2" target="genmdl" />
  <implementation name="IM_swizzle_color3_vector3_genmdl" nodedef="ND_swizzle_color3_vector3" target="genmdl" />
  <implementation name="IM_swizzle_color3_vector4_genmdl" nodedef="ND_swizzle_color3_vector4" target="genmdl" />
  <implementation name="IM_swizzle_color4_float_genmdl" nodedef="ND_swizzle_color4_float" target="genmdl" />
  <implementation name="IM_swizzle_color4_color3_genmdl" nodedef="ND_swizzle_color4_color3" target="genmdl" />
  <implementation name="IM_swizzle_color4_color4_genmdl" nodedef="ND_swizzle_color4_color4" target="genmdl" />
  <implementation name="IM_swizzle_color4_vector2_genmdl" nodedef="ND_swizzle_color4_vector2" target="genmdl" />
  <implementation name="IM_swizzle_color4_vector3_genmdl" nodedef="ND_swizzle_color4_vector3" target="genmdl" />
  <implementation name="IM_swizzle_color4_vector4_genmdl" nodedef="ND_swizzle_color4_vector4" target="genmdl" />
  <implementation name="IM_swizzle_vector2_float_genmdl" nodedef="ND_swizzle_vector2_float" target="genmdl" />
  <implementation name="IM_swizzle_vector2_color3_genmdl" nodedef="ND_swizzle_vector2_color3" target="genmdl" />
  <implementation name="IM_swizzle_vector2_color4_genmdl" nodedef="ND_swizzle_vector2_color4" target="genmdl" />
  <implementation name="IM_swizzle_vector2_vector2_genmdl" nodedef="ND_swizzle_vector2_vector2" target="genmdl" />
  <implementation name="IM_swizzle_vector2_vector3_genmdl" nodedef="ND_swizzle_vector2_vector3" target="genmdl" />
  <implementation name="IM_swizzle_vector2_vector4_genmdl" nodedef="ND_swizzle_vector2_vector4" target="genmdl" />
  <implementation name="IM_swizzle_vector3_float_genmdl" nodedef="ND_swizzle_vector3_float" target="genmdl" />
  <implementation name="IM_swizzle_vector3_color3_genmdl" nodedef="ND_swizzle_vector3_color3" target="genmdl" />
  <implementation name="IM_swizzle_vector3_color4_genmdl" nodedef="ND_swizzle_vector3_color4" target="genmdl" />
  <implementation name="IM_swizzle_vector3_vector2_genmdl" nodedef="ND_swizzle_vector3_vector2" target="genmdl" />
  <implementation name="IM_swizzle_vector3_vector3_genmdl" nodedef="ND_swizzle_vector3_vector3" target="genmdl" />
  <implementation name="IM_swizzle_vector3_vector4_genmdl" nodedef="ND_swizzle_vector3_vector4" target="genmdl" />
  <implementation name="IM_swizzle_vector4_float_genmdl" nodedef="ND_swizzle_vector4_float" target="genmdl" />
  <implementation name="IM_swizzle_vector4_color3_genmdl" nodedef="ND_swizzle_vector4_color3" target="genmdl" />
  <implementation name="IM_swizzle_vector4_color4_genmdl" nodedef="ND_swizzle_vector4_color4" target="genmdl" />
  <implementation name="IM_swizzle_vector4_vector2_genmdl" nodedef="ND_swizzle_vector4_vector2" target="genmdl" />
  <implementation name="IM_swizzle_vector4_vector3_genmdl" nodedef="ND_swizzle_vector4_vector3" target="genmdl" />
  <implementation name="IM_swizzle_vector4_vector4_genmdl" nodedef="ND_swizzle_vector4_vector4" target="genmdl" />

  <!-- <combine2> -->
  <implementation name="IM_combine2_vector2_genmdl" nodedef="ND_combine2_vector2" target="genmdl" />
  <implementation name="IM_combine2_color4CF_genmdl" nodedef="ND_combine2_color4CF" target="genmdl" />
  <implementation name="IM_combine2_vector4VF_genmdl" nodedef="ND_combine2_vector4VF" target="genmdl" />
  <implementation name="IM_combine2_vector4VV_genmdl" nodedef="ND_combine2_vector4VV" target="genmdl" />

  <!-- <combine3> -->
  <implementation name="IM_combine3_color3_genmdl" nodedef="ND_combine3_color3" target="genmdl" />
  <implementation name="IM_combine3_vector3_genmdl" nodedef="ND_combine3_vector3" target="genmdl" />

  <!-- <combine4> -->
  <implementation name="IM_combine4_color4_genmdl" nodedef="ND_combine4_color4" target="genmdl" />
  <implementation name="IM_combine4_vector4_genmdl" nodedef="ND_combine4_vector4" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Convolution nodes                                                        -->
  <!-- ======================================================================== -->

  <!-- <blur> -->
  <implementation name="IM_blur_float_genmdl" nodedef="ND_blur_float" target="genmdl" />
  <implementation name="IM_blur_color3_genmdl" nodedef="ND_blur_color3" target="genmdl" />
  <implementation name="IM_blur_color4_genmdl" nodedef="ND_blur_color4" target="genmdl" />
  <implementation name="IM_blur_vector2_genmdl" nodedef="ND_blur_vector2" target="genmdl" />
  <implementation name="IM_blur_vector3_genmdl" nodedef="ND_blur_vector3" target="genmdl" />
  <implementation name="IM_blur_vector4_genmdl" nodedef="ND_blur_vector4" target="genmdl" />

  <!-- <heighttonormal> -->
  <implementation name="IM_heighttonormal_vector3_genmdl" nodedef="ND_heighttonormal_vector3" target="genmdl" />

  <!-- ======================================================================== -->
  <!-- Organization nodes                                                       -->
  <!-- ======================================================================== -->

  <!-- <dot> -->
  <implementation name="IM_dot_float_genmdl" nodedef="ND_dot_float" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_color3_genmdl" nodedef="ND_dot_color3" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_color4_genmdl" nodedef="ND_dot_color4" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_vector2_genmdl" nodedef="ND_dot_vector2" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_vector3_genmdl" nodedef="ND_dot_vector3" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_vector4_genmdl" nodedef="ND_dot_vector4" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_boolean_genmdl" nodedef="ND_dot_boolean" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_integer_genmdl" nodedef="ND_dot_integer" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_matrix33_genmdl" nodedef="ND_dot_matrix33" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_matrix44_genmdl" nodedef="ND_dot_matrix44" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_string_genmdl" nodedef="ND_dot_string" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_filename_genmdl" nodedef="ND_dot_filename" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_surfaceshader_genmdl" nodedef="ND_dot_surfaceshader" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_displacementshader_genmdl" nodedef="ND_dot_displacementshader" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_volumeshader_genmdl" nodedef="ND_dot_volumeshader" sourcecode="{{in}}" target="genmdl" />
  <implementation name="IM_dot_lightshader_genmdl" nodedef="ND_dot_lightshader" sourcecode="{{in}}" target="genmdl" />

</materialx>
<?xml version="1.0" encoding="UTF-8"?>
<!--
  TM & (c) 2020 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
  All rights reserved.  See LICENSE.txt for license.
-->

<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Base target definition for MDL targets using shader generation.          -->
  <!-- ======================================================================== -->
  <targetdef name="genmdl" />

</materialx>
<?xml version="1.0" encoding="UTF-8"?>
<!--
  TM & (c) 2021 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
  All rights reserved.  See LICENSE.txt for license.
-->

<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Target definition for ESSL target. Derives from base GLSL target         -->
  <!-- ======================================================================== -->
  <targetdef name="essl" inherit="genglsl" />

</materialx>
<?xml version="1.0" encoding="UTF-8"?>
<!--
  TM & (c) 2020 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
  All rights reserved.  See LICENSE.txt for license.
-->

<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Base target definition for OSL targets using shader generation.          -->
  <!-- ======================================================================== -->
  <targetdef name="genosl" />

</materialx>
<?xml version="1.0" encoding="UTF-8"?>
<!--
  TM & (c) 2020 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
  All rights reserved.  See LICENSE.txt for license.
-->

<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- Base target definition for GLSL targets using shader generation.         -->
  <!-- ======================================================================== -->
  <targetdef name="genglsl" />

</materialx>
<?xml version="1.0"?>
<materialx version="1.38">

  <!-- ======================================================================== -->
  <!-- USD Preview Surface node definitions                                     -->
  <!-- ======================================================================== -->

  <!-- Node: UsdPreviewSurface -->
  <nodedef name="ND_UsdPreviewSurface_surfaceshader" node="UsdPreviewSurface" nodegroup="pbr" doc="USD preview surface shader" version="2.3" isdefaultversion="true">
    <input name="diffuseColor" type="color3" value="0.18, 0.18, 0.18" uimin="0,0,0" uimax="1,1,1" />
    <input name="emissiveColor" type="color3" value="0, 0, 0" uimin="0,0,0" uisoftmax="1,1,1" />
    <input name="useSpecularWorkflow" type="integer" value="0" />
    <input name="specularColor" type="color3" value="0, 0, 0" uimin="0,0,0" uimax="1,1,1" />
    <input name="metallic" type="float" value="0" uimin="0.0" uimax="1.0" />
    <input name="roughness" type="float" value="0.5" uimin="0.0" uimax="1.0" />
    <input name="clearcoat" type="float" value="0" uimin="0.0" uimax="1.0" />
    <input name="clearcoatRoughness" type="float" value="0.01" uimin="0.0" uimax="1.0" />
    <input name="opacity" type="float" value="1" uimin="0.0" uimax="1.0" />
    <input name="opacityThreshold" type="float" value="0" uimin="0.0" uimax="1.0" />
    <input name="ior" type="float" value="1.5" uimin="0.0" uisoftmax="3.0" />
    <input name="normal" type="vector3" value="0, 0, 1" />
    <input name="displacement" type="float" value="0" />
    <input name="occlusion" type="float" value="1" uimin="0.0" uimax="1.0" />
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!-- Node: UsdUVTexture -->
  <nodedef name="ND_UsdUVTexture" node="UsdUVTexture">
    <input name="file" type="filename" uniform="true" />
    <input name="st" type="vector2" defaultgeomprop="UV0" />
    <input name="wrapS" type="string" value="periodic" enum="black,clamp,periodic" uniform="true" />
    <input name="wrapT" type="string" value="periodic" enum="black,clamp,periodic" uniform="true" />
    <input name="fallback" type="color4" value="0, 0, 0, 1" />
    <input name="scale" type="color4" value="1, 1, 1, 1" uniform="true" />
    <input name="bias" type="color4" value="0, 0, 0, 0" uniform="true" />
    <output name="r" type="float" />
    <output name="g" type="float" />
    <output name="b" type="float" />
    <output name="a" type="float" />
    <output name="rgb" type="color3" />
    <output name="rgba" type="color4" />
  </nodedef>

  <!-- Node: UsdPrimvarReader -->
  <nodedef name="ND_UsdPrimvarReader_integer" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="integer" value="0" />
    <output name="out" type="integer" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_boolean" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="boolean" value="false" />
    <output name="out" type="boolean" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_string" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="string" value="" />
    <output name="out" type="string" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_float" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="float" value="0" />
    <output name="out" type="float" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector2" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector2" value="0, 0" />
    <output name="out" type="vector2" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector3" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector3" value="0, 0, 0" />
    <output name="out" type="vector3" />
  </nodedef>
  <nodedef name="ND_UsdPrimvarReader_vector4" node="UsdPrimvarReader">
    <input name="varname" type="string" uniform="true" />
    <input name="fallback" type="vector4" value="0, 0, 0, 0" />
    <output name="out" type="vector4" />
  </nodedef>
  <!-- TODO: Getting primvar of matrix type is not supported in MaterialX standard library.
  <nodedef name="ND_UsdPrimvarReader_matrix44" node="UsdPrimvarReader">
    <input name="varname" type="string" />
    <input name="fallback" type="matrix44" value="1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1" />
    <output name="out" type="matrix44" />
  </nodedef>
  -->

  <!-- Node: UsdTransform2d -->
  <nodedef name="ND_UsdTransform2d" node="UsdTransform2d">
    <input name="in" type="vector2" />
    <input name="rotation" type="float" value="0" />
    <input name="scale" type="vector2" value="1, 1" />
    <input name="translation" type="vector2" value="0, 0" />
    <output name="out" type="vector2" />
  </nodedef>

  <!-- ======================================================================== -->
  <!-- USD Preview Surface nodegraph implementations                            -->
  <!-- ======================================================================== -->

  <!-- Node: UsdPreviewSurface -->
  <nodegraph name="IMP_UsdPreviewSurface_surfaceshader" nodedef="ND_UsdPreviewSurface_surfaceshader">

    <!-- Compute the per-pixel surface normal -->
    <multiply name="scale_normal" type="vector3">
      <input name="in1" type="vector3" interfacename="normal" />
      <input name="in2" type="float" value="0.5" />
    </multiply>
    <add name="bias_normal" type="vector3">
      <input name="in1" type="vector3" nodename="scale_normal" />
      <input name="in2" type="float" value="0.5" />
    </add>
    <normalmap name="surface_normal" type="vector3">
      <input name="in" type="vector3" nodename="bias_normal" />
    </normalmap>

    <!-- Diffuse Layer -->
    <oren_nayar_diffuse_bsdf name="diffuse_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color" type="color3" interfacename="diffuseColor" />
      <input name="roughness" type="float" value="0" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </oren_nayar_diffuse_bsdf>

    <!-- Transmission Layer -->
    <dielectric_bsdf name="transmission_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="tint" type="color3" value="1, 1, 1" />
      <input name="ior" type="float" interfacename="ior" />
      <input name="roughness" type="vector2" value="0.0, 0.0" />
      <input name="normal" type="vector3" nodename="surface_normal" />
      <input name="scatter_mode" type="string" value="T" />
    </dielectric_bsdf>
    <mix name="transmission_mix" type="BSDF">
      <input name="fg" type="BSDF" nodename="diffuse_bsdf" />
      <input name="bg" type="BSDF" nodename="transmission_bsdf" />
      <input name="mix" type="float" interfacename="opacity" />
    </mix>

    <!-- Specular Workflow -->
    <roughness_anisotropy name="specular_roughness" type="vector2">
      <input name="roughness" type="float" interfacename="roughness" />
      <input name="anisotropy" type="float" value="0" />
    </roughness_anisotropy>
    <generalized_schlick_bsdf name="specular_bsdf1" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color0" type="color3" interfacename="specularColor" />
      <input name="color90" type="color3" value="1, 1, 1" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </generalized_schlick_bsdf>
    <layer name="specular_workflow_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="specular_bsdf1" />
      <input name="base" type="BSDF" nodename="transmission_mix" />
    </layer>

    <!-- Metalness Workflow -->
    <subtract name="one_minus_ior" type="float">
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" interfacename="ior" />
    </subtract>
    <add name="one_plus_ior" type="float">
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" interfacename="ior" />
    </add>
    <divide name="div_ior" type="float">
      <input name="in1" type="float" nodename="one_minus_ior" />
      <input name="in2" type="float" nodename="one_plus_ior" />
    </divide>
    <multiply name="F0" type="float">
      <input name="in1" type="float" nodename="div_ior" />
      <input name="in2" type="float" nodename="div_ior" />
    </multiply>
    <generalized_schlick_bsdf name="specular_bsdf2" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="color0" type="color3" nodename="F0" channels="rrr" />
      <input name="color90" type="color3" value="1, 1, 1" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </generalized_schlick_bsdf>
    <layer name="metalness_specular_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="specular_bsdf2" />
      <input name="base" type="BSDF" nodename="transmission_mix" />
    </layer>
    <artistic_ior name="artistic_ior" type="multioutput">
      <input name="reflectivity" type="color3" interfacename="diffuseColor" />
      <input name="edge_color" type="color3" interfacename="diffuseColor" />
    </artistic_ior>
    <conductor_bsdf name="metalness_metal_bsdf" type="BSDF">
      <input name="weight" type="float" value="1" />
      <input name="ior" type="color3" nodename="artistic_ior" output="ior" />
      <input name="extinction" type="color3" nodename="artistic_ior" output="extinction" />
      <input name="roughness" type="vector2" nodename="specular_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </conductor_bsdf>
    <mix name="metalness_workflow_bsdf" type="BSDF">
      <input name="fg" type="BSDF" nodename="metalness_metal_bsdf" />
      <input name="bg" type="BSDF" nodename="metalness_specular_bsdf" />
      <input name="mix" type="float" interfacename="metallic" />
    </mix>

    <!-- Select Specular/Metalness workflow -->
    <convert name="use_specular_workflow_float" type="float">
      <input name="in" type="integer" interfacename="useSpecularWorkflow" />
    </convert>
    <mix name="workflow_selector_bsdf" type="BSDF">
      <input name="fg" type="BSDF" nodename="specular_workflow_bsdf" />
      <input name="bg" type="BSDF" nodename="metalness_workflow_bsdf" />
      <input name="mix" type="float" nodename="use_specular_workflow_float" />
    </mix>

    <!-- Clearcoat Layer -->
    <roughness_anisotropy name="coat_roughness" type="vector2">
      <input name="roughness" type="float" interfacename="clearcoatRoughness" />
      <input name="anisotropy" type="float" value="0" />
    </roughness_anisotropy>
    <dielectric_bsdf name="coat_dielectric_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="clearcoat" />
      <input name="tint" type="color3" value="1, 1, 1" />
      <input name="ior" type="float" value="1.5" />
      <input name="roughness" type="vector2" nodename="coat_roughness" />
      <input name="normal" type="vector3" nodename="surface_normal" />
    </dielectric_bsdf>
    <layer name="coat_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="coat_dielectric_bsdf" />
      <input name="base" type="BSDF" nodename="workflow_selector_bsdf" />
    </layer>

    <!-- Emission Layer -->
    <uniform_edf name="emission_edf" type="EDF">
      <input name="color" type="color3" interfacename="emissiveColor" />
    </uniform_edf>

    <!-- Surface Shader Constructor -->
    <clamp name="opacity_clamped" type="float">
      <input name="in" type="float" interfacename="opacity" />
      <input name="low" type="float" value="0.00001" />
      <input name="high" type="float" value="1.0" />
    </clamp>
    <ifgreater name="cutout_opacity" type="float">
      <input name="value1" type="float" nodename="opacity_clamped" />
      <input name="value2" type="float" interfacename="opacityThreshold" />
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" value="0" />
    </ifgreater>
    <surface name="surface_constructor" type="surfaceshader">
      <input name="bsdf" type="BSDF" nodename="coat_bsdf" />
      <input name="edf" type="EDF" nodename="emission_edf" />
      <input name="opacity" type="float" nodename="cutout_opacity" />
    </surface>

    <!-- Output -->
    <output name="out" type="surfaceshader" nodename="surface_constructor" />
  </nodegraph>

  <!-- Node: UsdUVTexture -->
  <nodegraph name="IMP_UsdUVTexture" nodedef="ND_UsdUVTexture">
    <image name="image_reader" type="color4">
      <input name="file" type="filename" interfacename="file" />
      <input name="default" type="color4" interfacename="fallback" />
      <input name="texcoord" type="vector2" interfacename="st" />
      <input name="uaddressmode" type="string" interfacename="wrapS" />
      <input name="vaddressmode" type="string" interfacename="wrapT" />
    </image>
    <multiply name="image_scale" type="color4">
      <input name="in1" type="color4" nodename="image_reader" />
      <input name="in2" type="color4" interfacename="scale" />
    </multiply>
    <add name="image_bias" type="color4">
      <input name="in1" type="color4" nodename="image_scale" />
      <input name="in2" type="color4" interfacename="bias" />
    </add>
    <output name="r" type="float" nodename="image_bias" channels="r" />
    <output name="g" type="float" nodename="image_bias" channels="g" />
    <output name="b" type="float" nodename="image_bias" channels="b" />
    <output name="a" type="float" nodename="image_bias" channels="a" />
    <output name="rgb" type="color3" nodename="image_bias" channels="rgb" />
    <output name="rgba" type="color4" nodename="image_bias" />
  </nodegraph>

  <!-- Node: UsdPrimvarReader -->
  <nodegraph name="IMP_UsdPrimvarReader_integer" nodedef="ND_UsdPrimvarReader_integer">
    <geompropvalue name="primvar" type="integer">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="integer" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_boolean" nodedef="ND_UsdPrimvarReader_boolean">
    <geompropvalue name="primvar" type="boolean">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="boolean" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_string" nodedef="ND_UsdPrimvarReader_string">
    <geompropvalue name="primvar" type="string">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="string" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_float" nodedef="ND_UsdPrimvarReader_float">
    <geompropvalue name="primvar" type="float">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="float" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector2" nodedef="ND_UsdPrimvarReader_vector2">
    <geompropvalue name="primvar" type="vector2">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="vector2" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector3" nodedef="ND_UsdPrimvarReader_vector3">
    <geompropvalue name="primvar" type="vector3">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="vector3" nodename="primvar" />
  </nodegraph>
  <nodegraph name="IMP_UsdPrimvarReader_vector4" nodedef="ND_UsdPrimvarReader_vector4">
    <geompropvalue name="primvar" type="vector4">
      <input name="geomprop" type="string" interfacename="varname" />
    </geompropvalue>
    <output name="out" type="vector4" nodename="primvar" />
  </nodegraph>

  <!-- Node: UsdTransform2d -->
  <nodegraph name="IMP_UsdTransform2d" nodedef="ND_UsdTransform2d">
    <place2d name="placement" type="vector2">
      <input name="texcoord" type="vector2" interfacename="in" />
      <input name="scale" type="vector2" interfacename="scale" />
      <input name="rotate" type="float" interfacename="rotation" />
      <input name="offset" type="vector2" interfacename="translation" />
    </place2d>
    <output name="out" type="vector2" nodename="placement" />
  </nodegraph>

</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="lin_rec709">
  <nodedef name="ND_disney_bsdf_2015_surface" node="disney_bsdf_2015">
    <input name="baseColor" type="color3" value="0.16, 0.16, 0.16" />
    <input name="metallic" type="float" value="0" />
    <input name="roughness" type="float" value="0.5" />
    <input name="anisotropic" type="float" value="0" />
    <input name="specularTint" type="float" value="0" />
    <input name="sheen" type="float" value="0" />
    <input name="sheenTint" type="float" value="0.5" />
    <input name="clearcoat" type="float" value="0" />
    <input name="clearcoatGloss" type="float" value="1" />
    <input name="specTrans" type="float" value="0" />
    <input name="ior" type="float" value="1.5" />
    <input name="scatterDistance" type="vector3" value="0, 0, 0" />
    <input name="flatness" type="float" value="0" />
    <input name="diffTrans" type="float" value="0" />
    <input name="thin" type="boolean" value="false" uniform="true" />
    <output name="out" type="surfaceshader" />
  </nodedef>
  <implementation name="IM_disney_bsdf_2015_surface_pbrt" nodedef="ND_disney_bsdf_2015_surface" target="pbrt" file="https://github.com/mmp/pbrt-v3/blob/master/src/materials/disney.cpp" function="DisneyMaterial::DisneyMaterial">
    <input name="baseColor" type="color3" implname="color" />
    <input name="ior" type="float" implname="eta" />
  </implementation>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38">
  <!--
    Autodesk Standard Surface node definition.
  -->
  <nodedef name="ND_standard_surface_surfaceshader" node="standard_surface" nodegroup="pbr" version="1.0.1" isdefaultversion="true" inherit="ND_standard_surface_surfaceshader_100"
           doc="Autodesk standard surface shader">
    <input name="base" type="float" value="1.0" uimin="0.0" uimax="1.0" uiname="Base" uifolder="Base"
           doc="Multiplier on the intensity of the diffuse reflection." />
    <input name="base_color" type="color3" value="0.8, 0.8, 0.8" uimin="0,0,0" uimax="1,1,1" uiname="Base Color" uifolder="Base"
           doc="Color of the diffuse reflection." />    
  </nodedef>

  <nodedef name="ND_standard_surface_surfaceshader_100" node="standard_surface" nodegroup="pbr" version="1.0.0" doc="Autodesk standard surface shader">
    <input name="base" type="float" value="0.8" uimin="0.0" uimax="1.0" uiname="Base" uifolder="Base"
           doc="Multiplier on the intensity of the diffuse reflection." />
    <input name="base_color" type="color3" value="1.0, 1.0, 1.0" uimin="0,0,0" uimax="1,1,1" uiname="Base Color" uifolder="Base"
           doc="Color of the diffuse reflection." />
    <input name="diffuse_roughness" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Diffuse Roughness" uifolder="Base" uiadvanced="true"
           doc="Roughness of the diffuse reflection. Higher values cause the surface to appear flatter and darker." />
    <input name="metalness" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Metalness" uifolder="Base"
           doc="Specifies how metallic the material appears. At its maximum, the surface behaves like a metal, using fully specular reflection and complex fresnel." />
    <input name="specular" type="float" value="1" uimin="0.0" uimax="1.0" uiname="Specular" uifolder="Specular"
           doc="Multiplier on the intensity of the specular reflection." />
    <input name="specular_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Specular Color" uifolder="Specular"
           doc="Color tint on the specular reflection." />
    <input name="specular_roughness" type="float" value="0.2" uimin="0.0" uimax="1.0" uiname="Specular Roughness" uifolder="Specular"
           doc="The roughness of the specular reflection. Lower numbers produce sharper reflections, higher numbers produce blurrier reflections." />
    <input name="specular_IOR" type="float" value="1.5" uimin="0.0" uisoftmax="3.0" uiname="Index of Refraction" uifolder="Specular"
           doc="Index of refraction for specular reflection." />
    <input name="specular_anisotropy" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Specular Anisotropy" uifolder="Specular" uiadvanced="true"
           doc="The directional bias of reflected and transmitted light resulting in materials appearing rougher or glossier in certain directions." />
    <input name="specular_rotation" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Specular Rotation" uifolder="Specular" uiadvanced="true"
           doc="Rotation of the axis of specular anisotropy around the surface normal." />
    <input name="transmission" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Transmission" uifolder="Transmission" uiadvanced="true"
           doc="Transmission of light through the surface for materials such as glass or water. The greater the value the more transparent the material." />
    <input name="transmission_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Transmission Color" uifolder="Transmission" uiadvanced="true"
           doc="Color tint on the transmitted light." />
    <input name="transmission_depth" type="float" value="0" uimin="0.0" uisoftmax="100.0" uiname="Transmission Depth" uifolder="Transmission" uiadvanced="true"
           doc="Specifies the distance light travels inside the material before its becomes exactly the transmission color according to Beer's law." />
    <input name="transmission_scatter" type="color3" value="0, 0, 0" uimin="0,0,0" uimax="1,1,1" uiname="Transmission Scatter" uifolder="Transmission" uiadvanced="true"
           doc="Scattering coefficient of the interior medium. Suitable for a large body of liquid or one that is fairly thick, such as an ocean, honey, ice, or frosted glass." />
    <input name="transmission_scatter_anisotropy" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Transmission Anisotropy" uifolder="Transmission" uiadvanced="true"
           doc="The amount of directional bias, or anisotropy, of the scattering." />
    <input name="transmission_dispersion" type="float" value="0" uimin="0.0" uisoftmax="100.0" uiname="Transmission Dispersion" uifolder="Transmission" uiadvanced="true"
           doc="Dispersion amount, describing how much the index of refraction varies across wavelengths." />
    <input name="transmission_extra_roughness" type="float" value="0" uimin="-1.0" uisoftmin="0.0" uimax="1.0" uiname="Transmission Roughness" uifolder="Transmission" uiadvanced="true"
           doc="Additional roughness on top of specular roughness. Positive values blur refractions more than reflections, and negative values blur refractions less." />
    <input name="subsurface" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Subsurface" uifolder="Subsurface" uiadvanced="true"
           doc="The blend between diffuse reflection and subsurface scattering. A value of 1.0 indicates full subsurface scattering and a value 0 for diffuse reflection only." />
    <input name="subsurface_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Subsurface Color" uifolder="Subsurface" uiadvanced="true"
           doc="The color of the subsurface scattering effect." />
    <input name="subsurface_radius" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Subsurface Radius" uifolder="Subsurface" uiadvanced="true"
           doc="The mean free path. The distance which light can travel before being scattered inside the surface." />
    <input name="subsurface_scale" type="float" value="1" uimin="0.0" uisoftmax="10.0" uiname="Subsurface Scale" uifolder="Subsurface" uiadvanced="true"
           doc="Scalar weight for the subsurface radius value." />
    <input name="subsurface_anisotropy" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Subsurface Anisotropy" uifolder="Subsurface" uiadvanced="true"
           doc="The direction of subsurface scattering. 0 scatters light evenly, positive values scatter forward and negative values scatter backward." />
    <input name="sheen" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Sheen" uifolder="Sheen" uiadvanced="true"
           doc="The weight of a sheen layer that can be used to approximate microfibers or fabrics such as velvet and satin." />
    <input name="sheen_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Sheen Color" uifolder="Sheen" uiadvanced="true"
           doc="The color of the sheen layer." />
    <input name="sheen_roughness" type="float" value="0.3" uimin="0.0" uimax="1.0" uiname="Sheen Roughness" uifolder="Sheen" uiadvanced="true"
           doc="The roughness of the sheen layer." />
    <input name="coat" type="float" value="0" uimin="0.0" uimax="1.0" uiname="Coat" uifolder="Coat"
           doc="The weight of a reflective clear-coat layer on top of the material. Use for materials such as car paint or an oily layer." />
    <input name="coat_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Coat Color" uifolder="Coat"
           doc="The color of the clear-coat layer's transparency." />
    <input name="coat_roughness" type="float" value="0.1" uimin="0.0" uimax="1.0" uiname="Coat Roughness" uifolder="Coat"
           doc="The roughness of the clear-coat reflections. The lower the value, the sharper the reflection." />
    <input name="coat_anisotropy" type="float" value="0.0" uimin="0.0" uimax="1.0" uiname="Coat Anisotropy" uifolder="Coat" uiadvanced="true"
           doc="The amount of directional bias, or anisotropy, of the clear-coat layer." />
    <input name="coat_rotation" type="float" value="0.0" uimin="0.0" uimax="1.0" uiname="Coat Rotation" uifolder="Coat" uiadvanced="true"
           doc="The rotation of the anisotropic effect of the clear-coat layer." />
    <input name="coat_IOR" type="float" value="1.5" uimin="0.0" uisoftmax="3.0" uiname="Coat Index of Refraction" uifolder="Coat"
           doc="The index of refraction of the clear-coat layer." />
    <input name="coat_normal" type="vector3" defaultgeomprop="Nworld" uiname="Coat normal" uifolder="Coat"
           doc="Input normal for clear-coat layer" />
    <input name="coat_affect_color" type="float" value="0" uimin="0" uimax="1" uiname="Coat Affect Color" uifolder="Coat" uiadvanced="true"
           doc="Controls the saturation of diffuse reflection and subsurface scattering below the clear-coat." />
    <input name="coat_affect_roughness" type="float" value="0" uimin="0" uimax="1" uiname="Coat Affect Roughness" uifolder="Coat" uiadvanced="true"
           doc="Controls the roughness of the specular reflection in the layers below the clear-coat." />
    <input name="thin_film_thickness" type="float" value="0" uimin="0.0" uisoftmax="2000.0" uiname="Thin Film Thickness" uifolder="Thin Film" uiadvanced="true"
           doc="The thickness of the thin film layer on a surface. Use for materials such as multitone car paint or soap bubbles." />
    <input name="thin_film_IOR" type="float" value="1.5" uimin="0.0" uisoftmax="3.0" uiname="Thin Film Index of Refraction" uifolder="Thin Film" uiadvanced="true"
           doc="The index of refraction of the medium surrounding the material." />
    <input name="emission" type="float" value="0" uimin="0.0" uisoftmax="1.0" uiname="Emission" uifolder="Emission"
           doc="The amount of emitted incandescent light." />
    <input name="emission_color" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Emission Color" uifolder="Emission"
           doc="The color of the emitted light." />
    <input name="opacity" type="color3" value="1, 1, 1" uimin="0,0,0" uimax="1,1,1" uiname="Opacity" uifolder="Geometry"
           doc="The opacity of the entire material." />
    <input name="thin_walled" type="boolean" value="false" uiname="Thin Walled" uifolder="Geometry" uiadvanced="true"
           doc="If true the surface is double-sided and represents an infinitely thin shell. Suitable for thin objects such as tree leaves or paper." />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" uiname="Normal" uifolder="Geometry"
           doc="Input geometric normal" />
    <input name="tangent" type="vector3" defaultgeomprop="Tworld" uiname="Tangent Input" uifolder="Geometry"
           doc="Input geometric tangent" />
    <output name="out" type="surfaceshader" />
  </nodedef>

  <!--
    Association between implementation and definition.
    Note that version 1.0.1 only changes default values and thus reuses the same 1.0.0 nodegraph implementation.
  -->
  <implementation name="IMPL_standard_surface_surfaceshader_101" nodedef="ND_standard_surface_surfaceshader" nodegraph="NG_standard_surface_surfaceshader_100" />
  <implementation name="IMPL_standard_surface_surfaceshader_100" nodedef="ND_standard_surface_surfaceshader_100" nodegraph="NG_standard_surface_surfaceshader_100" />

  <!--
    Autodesk Standard Surface nodegraph implementation.
  -->
  <nodegraph name="NG_standard_surface_surfaceshader_100">

    <!-- Roughness influence by coat-->
    <multiply name="coat_affect_roughness_multiply1" type="float">
      <input name="in1" type="float" interfacename="coat_affect_roughness" />
      <input name="in2" type="float" interfacename="coat" />
    </multiply>
    <multiply name="coat_affect_roughness_multiply2" type="float">
      <input name="in1" type="float" nodename="coat_affect_roughness_multiply1" />
      <input name="in2" type="float" interfacename="coat_roughness" />
    </multiply>
    <mix name="coat_affected_roughness" type="float">
      <input name="fg" type="float" value="1.0" />
      <input name="bg" type="float" interfacename="specular_roughness" />
      <input name="mix" type="float" nodename="coat_affect_roughness_multiply2" />
    </mix>
    <roughness_anisotropy name="main_roughness" type="vector2">
      <input name="roughness" type="float" nodename="coat_affected_roughness" />
      <input name="anisotropy" type="float" interfacename="specular_anisotropy" />
    </roughness_anisotropy>

    <!-- Tangent rotation -->
    <multiply name="tangent_rotate_degree" type="float">
      <input name="in1" type="float" interfacename="specular_rotation" />
      <input name="in2" type="float" value="360" />
    </multiply>
    <rotate3d name="tangent_rotate" type="vector3">
      <input name="in" type="vector3" interfacename="tangent" />
      <input name="amount" type="float" nodename="tangent_rotate_degree" />
      <input name="axis" type="vector3" interfacename="normal" />
    </rotate3d>
    <normalize name="tangent_rotate_normalize" type="vector3">
      <input name="in" type="vector3" nodename="tangent_rotate" />
    </normalize>
    <ifgreater name="main_tangent" type="vector3">
      <input name="value1" type="float" interfacename="specular_anisotropy" />
      <input name="value2" type="float" value="0.0" />
      <input name="in1" type="vector3" nodename="tangent_rotate_normalize" />
      <input name="in2" type="vector3" interfacename="tangent" />
    </ifgreater>

    <!-- Coat tangent rotation -->
    <multiply name="coat_tangent_rotate_degree" type="float">
      <input name="in1" type="float" interfacename="coat_rotation" />
      <input name="in2" type="float" value="360" />
    </multiply>
    <rotate3d name="coat_tangent_rotate" type="vector3">
      <input name="in" type="vector3" interfacename="tangent" />
      <input name="amount" type="float" nodename="coat_tangent_rotate_degree" />
      <input name="axis" type="vector3" interfacename="coat_normal" />
    </rotate3d>
    <normalize name="coat_tangent_rotate_normalize" type="vector3">
      <input name="in" type="vector3" nodename="coat_tangent_rotate" />
    </normalize>
    <ifgreater name="coat_tangent" type="vector3">
      <input name="value1" type="float" interfacename="coat_anisotropy" />
      <input name="value2" type="float" value="0.0" />
      <input name="in1" type="vector3" nodename="coat_tangent_rotate_normalize" />
      <input name="in2" type="vector3" interfacename="tangent" />
    </ifgreater>

    <!-- Colors influenced by coat ("coat gamma") -->
    <clamp name="coat_clamped" type="float">
      <input name="in" type="float" interfacename="coat" />
    </clamp>
    <multiply name="coat_gamma_multiply" type="float">
      <input name="in1" type="float" nodename="coat_clamped" />
      <input name="in2" type="float" interfacename="coat_affect_color" />
    </multiply>
    <add name="coat_gamma" type="float">
      <input name="in1" type="float" nodename="coat_gamma_multiply" />
      <input name="in2" type="float" value="1.0" />
    </add>
    <power name="coat_affected_diffuse_color" type="color3">
      <input name="in1" type="color3" interfacename="base_color" />
      <input name="in2" type="float" nodename="coat_gamma" />
    </power>
    <power name="coat_affected_subsurface_color" type="color3">
      <input name="in1" type="color3" interfacename="subsurface_color" />
      <input name="in2" type="float" nodename="coat_gamma" />
    </power>

    <!-- Diffuse/Subsurface Layer -->
    <oren_nayar_diffuse_bsdf name="diffuse_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="base" />
      <input name="color" type="color3" nodename="coat_affected_diffuse_color" />
      <input name="roughness" type="float" interfacename="diffuse_roughness" />
      <input name="normal" type="vector3" interfacename="normal" />
    </oren_nayar_diffuse_bsdf>
    <translucent_bsdf name="translucent_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="color" type="color3" nodename="coat_affected_subsurface_color" />
      <input name="normal" type="vector3" interfacename="normal" />
    </translucent_bsdf>
    <convert name="subsurface_radius_vector" type="vector3">
      <input name="in" type="color3" interfacename="subsurface_radius" />
    </convert>
    <multiply name="subsurface_radius_scaled" type="vector3">
      <input name="in1" type="vector3" nodename="subsurface_radius_vector" />
      <input name="in2" type="float" interfacename="subsurface_scale" />
    </multiply>
    <subsurface_bsdf name="subsurface_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="color" type="color3" nodename="coat_affected_subsurface_color" />
      <input name="radius" type="vector3" nodename="subsurface_radius_scaled" />
      <input name="anisotropy" type="float" interfacename="subsurface_anisotropy" />
      <input name="normal" type="vector3" interfacename="normal" />
    </subsurface_bsdf>
    <convert name="subsurface_selector" type="float">
      <input name="in" type="boolean" interfacename="thin_walled" />
    </convert>
    <mix name="selected_subsurface_bsdf" type="BSDF">
      <input name="fg" type="BSDF" nodename="translucent_bsdf" />
      <input name="bg" type="BSDF" nodename="subsurface_bsdf" />
      <input name="mix" type="float" nodename="subsurface_selector" />
    </mix>
    <mix name="subsurface_mix" type="BSDF">
      <input name="fg" type="BSDF" nodename="selected_subsurface_bsdf" />
      <input name="bg" type="BSDF" nodename="diffuse_bsdf" />
      <input name="mix" type="float" interfacename="subsurface" />
    </mix>

    <!-- Sheen Layer -->
    <sheen_bsdf name="sheen_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="sheen" />
      <input name="color" type="color3" interfacename="sheen_color" />
      <input name="roughness" type="float" interfacename="sheen_roughness" />
      <input name="normal" type="vector3" interfacename="normal" />
    </sheen_bsdf>
    <layer name="sheen_layer" type="BSDF">
      <input name="top" type="BSDF" nodename="sheen_bsdf" />
      <input name="base" type="BSDF" nodename="subsurface_mix" />
    </layer>

    <!-- Transmission Layer -->
    <dielectric_bsdf name="transmission_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="tint" type="color3" interfacename="transmission_color" />
      <input name="ior" type="float" interfacename="specular_IOR" />
      <input name="roughness" type="vector2" nodename="main_roughness" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="main_tangent" />
      <input name="distribution" type="string" value="ggx" />
      <input name="scatter_mode" type="string" value="T" />
    </dielectric_bsdf>
    <mix name="transmission_mix" type="BSDF">
      <input name="fg" type="BSDF" nodename="transmission_bsdf" />
      <input name="bg" type="BSDF" nodename="sheen_layer" />
      <input name="mix" type="float" interfacename="transmission" />
    </mix>

    <!-- Thin-film -->
    <thin_film_bsdf name="thin_film_bsdf" type="BSDF">
      <input name="thickness" type="float" interfacename="thin_film_thickness" />
      <input name="ior" type="float" interfacename="thin_film_IOR" />
    </thin_film_bsdf>

    <!-- Specular Layer -->
    <dielectric_bsdf name="specular_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="specular" />
      <input name="tint" type="color3" interfacename="specular_color" />
      <input name="ior" type="float" interfacename="specular_IOR" />
      <input name="roughness" type="vector2" nodename="main_roughness" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="main_tangent" />
      <input name="distribution" type="string" value="ggx" />
      <input name="scatter_mode" type="string" value="R" />
    </dielectric_bsdf>
    <layer name="specular_layer" type="BSDF">
      <input name="top" type="BSDF" nodename="specular_bsdf" />
      <input name="base" type="BSDF" nodename="transmission_mix" />
    </layer>
    <layer name="specular_layer_with_thin_film" type="BSDF">
      <input name="top" type="BSDF" nodename="thin_film_bsdf" />
      <input name="base" type="BSDF" nodename="specular_layer" />
    </layer>

    <!-- Metal Layer -->
    <multiply name="metal_reflectivity" type="color3">
      <input name="in1" type="color3" interfacename="base_color" />
      <input name="in2" type="float" interfacename="base" />
    </multiply>
    <multiply name="metal_edgecolor" type="color3">
      <input name="in1" type="color3" interfacename="specular_color" />
      <input name="in2" type="float" interfacename="specular" />
    </multiply>
    <artistic_ior name="artistic_ior" type="multioutput">
      <input name="reflectivity" type="color3" nodename="metal_reflectivity" />
      <input name="edge_color" type="color3" nodename="metal_edgecolor" />
    </artistic_ior>
    <conductor_bsdf name="metal_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="ior" type="color3" nodename="artistic_ior" output="ior" />
      <input name="extinction" type="color3" nodename="artistic_ior" output="extinction" />
      <input name="roughness" type="vector2" nodename="main_roughness" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="main_tangent" />
      <input name="distribution" type="string" value="ggx" />
    </conductor_bsdf>
    <mix name="metalness_mix" type="BSDF">
      <input name="fg" type="BSDF" nodename="metal_bsdf" />
      <input name="bg" type="BSDF" nodename="specular_layer_with_thin_film" />
      <input name="mix" type="float" interfacename="metalness" />
    </mix>

    <!-- Coat Layer -->
    <mix name="coat_attenuation" type="color3">
      <input name="fg" type="color3" interfacename="coat_color" />
      <input name="bg" type="color3" value="1.0, 1.0, 1.0" />
      <input name="mix" type="float" interfacename="coat" />
    </mix>
    <multiply name="metalness_mix_attenuated" type="BSDF">
      <input name="in1" type="BSDF" nodename="metalness_mix" />
      <input name="in2" type="color3" nodename="coat_attenuation" />
    </multiply>
    <roughness_anisotropy name="coat_roughness_vector" type="vector2">
      <input name="roughness" type="float" interfacename="coat_roughness" />
      <input name="anisotropy" type="float" interfacename="coat_anisotropy" />
    </roughness_anisotropy>
    <dielectric_bsdf name="coat_bsdf" type="BSDF">
      <input name="weight" type="float" interfacename="coat" />
      <input name="tint" type="color3" value="1.0, 1.0, 1.0" />
      <input name="ior" type="float" interfacename="coat_IOR" />
      <input name="roughness" type="vector2" nodename="coat_roughness_vector" />
      <input name="normal" type="vector3" interfacename="coat_normal" />
      <input name="tangent" type="vector3" nodename="coat_tangent" />
      <input name="distribution" type="string" value="ggx" />
      <input name="scatter_mode" type="string" value="R" />
    </dielectric_bsdf>
    <layer name="coat_layer" type="BSDF">
      <input name="top" type="BSDF" nodename="coat_bsdf" />
      <input name="base" type="BSDF" nodename="metalness_mix_attenuated" />
    </layer>

    <!-- Emission Layer -->
    <multiply name="emission_weight" type="color3">
      <input name="in1" type="color3" interfacename="emission_color" />
      <input name="in2" type="float" interfacename="emission" />
    </multiply>
    <mix name="coat_emission_attenuation" type="color3">
      <input name="fg" type="color3" interfacename="coat_color" />
      <input name="bg" type="color3" value="1.0, 1.0, 1.0" />
      <input name="mix" type="float" interfacename="coat" />
    </mix>
    <multiply name="emission_weight_attenuated" type="color3">
      <input name="in1" type="color3" nodename="emission_weight" />
      <input name="in2" type="color3" nodename="coat_emission_attenuation" />
    </multiply>
    <uniform_edf name="emission_edf" type="EDF">
      <input name="color" type="color3" nodename="emission_weight_attenuated" />
    </uniform_edf>

    <!-- Surface construction with opacity -->
    <!-- Node <surface> only supports monochromatic opacity so use the luminance of input opacity color -->
    <luminance name="opacity_luminance" type="color3">
      <input name="in" type="color3" interfacename="opacity" />
    </luminance>
    <surface name="shader_constructor" type="surfaceshader">
      <input name="bsdf" type="BSDF" nodename="coat_layer" />
      <input name="edf" type="EDF" nodename="emission_edf" />
      <input name="opacity" type="float" nodename="opacity_luminance" channels="r" />
    </surface>

    <!-- Output -->
    <output name="out" type="surfaceshader" nodename="shader_constructor" />

  </nodegraph>

</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="lin_rec709">
  <nodedef name="ND_disney_brdf_2012_surface" node="disney_brdf_2012">
    <input name="baseColor" type="color3" value="0.16, 0.16, 0.16" />
    <input name="metallic" type="float" value="0" />
    <input name="subsurface" type="float" value="0" />
    <input name="specular" type="float" value="0.5" />
    <input name="roughness" type="float" value="0.5" />
    <input name="specularTint" type="float" value="0" />
    <input name="anisotropic" type="float" value="0" />
    <input name="sheen" type="float" value="0" />
    <input name="sheenTint" type="float" value="0.5" />
    <input name="clearcoat" type="float" value="0" />
    <input name="clearcoatGloss" type="float" value="1" />
    <output name="out" type="surfaceshader" />
  </nodedef>
  <implementation name="IM_disney_brdf_2012_surface_brdf_explorer" nodedef="ND_disney_brdf_2012_surface" target="brdf_explorer" file="https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf" />
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_sss" node="LamaSSS" doc="Lama SSS" version="1.0" isdefaultversion="true">
    <input name="color" type="color3" value="0.18, 0.18, 0.18" uiname="Color" uifolder="Main"
           doc="Diffuse color (aka albedo), defining what ratio of light is reflected -- or transmitted -- for each color channel." />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" uiname="Normal" uifolder="Main"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <input name="sssRadius" type="color3" value="0.0, 0.0, 0.0" uiname="Radius" uifolder="SSS"
           doc="Diffuse Mean Free Path, expressed for each color channel in mm. Indicates on average how much the light travels under the surface before being scattered. The higher the value, the softer the result will be. If null, the computation simplifies to a Lambertian lobe." />
    <input name="sssScale" type="float" value="1.0" uiname="Scale" uifolder="SSS"
           doc="Multiplies the radius, to adjust its scale to the scene at hand. If null, the computation simplifies to a Lambertian lobe." />
    <input name="sssMode" type="integer" enum="Path-traced Davis,Path-traced exponential,Diffusion Burley,Diffusion Burley (mean free path)" enumvalues="0,1,2,3" value="0" uiname="Mode" uifolder="Main"
           doc="Selects what method should be used to compute sub-surface scattering. Proposes two path-traced variants, and a more traditional approximate diffusion model." />
    <input name="sssIOR" type="float" value="1.0" uimin="1.0" uimax="2.0" uiname="IOR" uifolder="SSS"
           doc="Index of refraction use to trigger cases of total internal reflections, when the paths are reaching the surface after having travelled under it. Can be used to avoid excessive glow in highly curved regions (corners, creases, ...)." />
    <input name="sssAnisotropy" type="float" value="0.0" uimin="-1.0" uimax="1.0" uiname="Anisotropy" uifolder="SSS"
           doc="Higher values makes light scatter predominantly forward under the surface, making the object look less diffuse and more transparent." />
    <input name="sssBleed" type="float" value="0.0" uimin="0.0" uimax="1.0" uiname="Bleed" uifolder="SSS"
           doc="Controls the depth of light bleed in the subsurface medium. Has the effect of increasing the distance light travels in the medium while preserving fine detail, compared to increasing the Mean Free Path." />
    <input name="sssFollowTopology" type="float" value="0.0" uimin="0.0" uimax="1.0" uiname="Follow Topology" uifolder="SSS"
           doc="Controls how strongly normals are considered in the subsurface computation." />
    <input name="sssSubset" type="string" uniform="true" value="" uiname="Subset" uifolder="SSS"
           doc="Specifies trace subset for inclusion/exclusion when struck by a ray indirectly." />
    <input name="sssContinuationRays" type="integer" value="0" uiname="Continuation Rays" uifolder="SSS"
           doc="When enabled, ignores internal geometry and jumps to the last surface." />
    <input name="sssUnitLength" type="float" value="0.00328" uiname="Unit Length" uifolder="SSS"
           doc="Specifies what unit length the scene is using. It is a multiplier on the mean free path or diffuse mean free path which is expressed in mm. The default value of 0.00328 converts between feet and mm." />
    <input name="mode" type="integer" enum="Reflection,Transmission,Reflection(with direct illumination)" enumvalues="0,1,2" value="0" uiname="Mode" uifolder="Advanced"
           doc="If the subsurface is enabled, Reflection: should be used when both the camera and the light are outside of the object. Reflection(with direct illumination): should be used when both the camera and the light are outside of the object. This mode also computes the direct illumination at the sss ray exit point. Transmission: should be used when the light is inside the object while the camera is outside. " />
    <input name="albedoInversionMethod" type="integer" enum="Pixar,Chiang" enumvalues="0,1" value="0" uiname="Albedo Inversion Method" uifolder="Advanced"
           doc="Decides which albedo inversion methods is used. Pixar: Does the Pixar Path Traced SSS default albedo inversion. Chiang: Does Chiang's albedo inversion (with no dmfp remapping). The look is closer to Arnold Standard Surface randomwalk." />
    <input name="diffuseLobeName" type="string" uniform="true" value="diffuse" uiname="Diffuse Lobe Name" uifolder="Advanced"
           doc="Defines the name that can be used in LPE AOVs for the diffuse lobe (when the SSS radius is null)." />
    <input name="sssEntryLobeName" type="string" uniform="true" value="irradiance" uiname="SSS Entry Lobe Name" uifolder="Advanced"
           doc="Defines the name that can be used in LPE AOVs for the SSS Entry lobe." />
    <input name="sssExitLobeName" type="string" uniform="true" value="" uiname="SSS Exit Lobe Name" uifolder="Advanced"
           doc="Defines the name that can be used in LPE AOVs for the SSS Exit lobe." />
    <input name="sssId" type="integer" uniform="true" value="0" enum="0, 1" enumvalues="0, 1" uiname="SSS Id" uifolder="Advanced"
           doc="SSS ID" />
    <input name="matte" type="string" uniform="true" value="" uiname="Matte" uifolder="Advanced"
           doc="Defines the name that can be used by the matte system, to output the weight of this lobe in the final material as an AOV." />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="IMPL_lama_sss" nodedef="ND_lama_sss">

    <!-- DMFP -->
    <convert name="subsurface_radius_vector" type="vector3">
      <input name="in" type="color3" interfacename="sssRadius" />
    </convert>
    <multiply name="subsurface_radius_scaled" type="vector3">
      <input name="in1" type="vector3" nodename="subsurface_radius_vector" />
      <input name="in2" type="float" interfacename="sssScale" />
    </multiply>
    <multiply name="subsurface_multiply_unitlength" type="vector3">
      <input name="in1" type="vector3" nodename="subsurface_radius_scaled" />
      <input name="in2" type="float" interfacename="sssUnitLength" />
    </multiply>

    <!-- BRDF -->
    <subsurface_bsdf name="subsurface_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="color" type="color3" interfacename="color" />
      <input name="radius" type="vector3" nodename="subsurface_multiply_unitlength" />
      <input name="anisotropy" type="float" interfacename="sssAnisotropy" />
      <input name="normal" type="vector3" interfacename="normal" />
    </subsurface_bsdf>

    <!-- Output -->
    <output name="out" type="BSDF" nodename="subsurface_bsdf" />

  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_sheen" node="LamaSheen" nodegroup="pbr" doc="Lama sheen" version="1.0" isdefaultversion="true">
    <input name="color" type="color3" value="1, 1, 1" uiname="Color" uifolder="Main"
           doc="Amount of sheen to add, per channel. When this node is used as top material in a stack, the more sheen is added, the less energy will be transmitted to the base material." />
    <input name="roughness" type="float" value="0.1" uimin="0.0" uimax="1.0" uiname="Roughness" uifolder="Main"
           doc="Roughness of the sheen effect. Very rough sheen can be used to create a rough diffuse look (when combined with a diffuse node by a stack or mix)." />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" uiname="Normal" uifolder="Main"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="IMPL_lama_sheen" nodedef="ND_lama_sheen">

    <!-- Roughness -->
    <multiply name="roughness_compressed" type="float">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" value="0.9" />
    </multiply>
    <add name="roughness_remapped" type="float">
      <input name="in1" type="float" nodename="roughness_compressed" />
      <input name="in2" type="float" value="0.1" />
    </add>
    <power name="roughness_squared" type="float">
      <input name="in1" type="float" nodename="roughness_remapped" />
      <input name="in2" type="float" value="2" />
    </power>

    <!-- BRDF -->
    <sheen_bsdf name="sheen_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="color" type="color3" interfacename="color" />
      <input name="roughness" type="float" nodename="roughness_squared" />
      <input name="normal" type="vector3" interfacename="normal" />
    </sheen_bsdf>

    <!-- Output -->
    <output name="out" type="BSDF" nodename="sheen_bsdf" />

  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">

  <!-- LamaAdd for BSDFs -->
  <nodedef name="ND_lama_add_bsdf" node="LamaAdd" version="1.0" isdefaultversion="true">
    <input name="material1" uiname="Material 1" type="BSDF" doc="First material to add." />
    <input name="material2" uiname="Material 2" type="BSDF" doc="Second material to add." />
    <input name="weight1" uiname="Weight 1" type="float" uimin="0.0" uimax="1.0" value="1.0" doc="Weight of the first material." />
    <input name="weight2" uiname="Weight 2" type="float" uimin="0.0" uimax="1.0" value="0.0" doc="Weight of the second material." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodegraph name="NG_lama_add_bsdf" nodedef="ND_lama_add_bsdf">
    <multiply name="mul1" type="BSDF">
      <input name="in1" type="BSDF" interfacename="material1" />
      <input name="in2" type="float" interfacename="weight1" />
    </multiply>
    <multiply name="mul2" type="BSDF">
      <input name="in1" type="BSDF" interfacename="material2" />
      <input name="in2" type="float" interfacename="weight2" />
    </multiply>
    <add name="add1" type="BSDF">
      <input name="in1" type="BSDF" nodename="mul1" />
      <input name="in2" type="BSDF" nodename="mul2" />
    </add>
    <output name="out" type="BSDF" nodename="add1" />
  </nodegraph>

  <!-- LamaAdd for EDFs -->
  <nodedef name="ND_lama_add_edf" node="LamaAdd" version="1.0" isdefaultversion="true">
    <input name="material1" uiname="Material 1" type="EDF" doc="First material to add." />
    <input name="material2" uiname="Material 2" type="EDF" doc="Second material to add." />
    <input name="weight1" uiname="Weight 1" type="float" uimin="0.0" uimax="1.0" value="1.0" doc="Weight of the first material." />
    <input name="weight2" uiname="Weight 2" type="float" uimin="0.0" uimax="1.0" value="0.0" doc="Weight of the second material." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodegraph name="NG_lama_add_edf" nodedef="ND_lama_add_edf">
    <multiply name="mul1" type="EDF">
      <input name="in1" type="EDF" interfacename="material1" />
      <input name="in2" type="float" interfacename="weight1" />
    </multiply>
    <multiply name="mul2" type="EDF">
      <input name="in1" type="EDF" interfacename="material2" />
      <input name="in2" type="float" interfacename="weight2" />
    </multiply>
    <add name="add1" type="EDF">
      <input name="in1" type="EDF" nodename="mul1" />
      <input name="in2" type="EDF" nodename="mul2" />
    </add>
    <output name="out" type="EDF" nodename="add1" />
  </nodegraph>

</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_conductor" node="LamaConductor" nodegroup="pbr" doc="Lama conductor" version="1.0" isdefaultversion="true">
    <input name="tint" type="color3" value="1, 1, 1" uiname="Tint" uifolder="Main"
           doc="Overall color multiplier. It should be used with parcimony, as a non-white value breaks physicality. The prefered way to define the color of a conductor is through the Fresnel attributes right below." />
    <input name="fresnelMode" type="integer" uniform="true" enum="Scientific,Artistic" enumvalues="0,1" value="0" uiname="Fresnel Mode" uifolder="Main"
           doc="Fresnel mode" />
    <input name="IOR" type="vector3" value="0.180000007153,0.419999986887,1.37000000477" uiname="IOR" uifolder="Main"
           doc="Index of refraction (often denoted by eta), defining the color reflected by the surface in the normal direction." />
    <input name="extinction" type="vector3" value="3.42000007629,2.34999990463,1.76999998093" uiname="Extinction" uifolder="Main"
           doc="Extinction coefficient (often denoted by kappa), influencing how the reflected color curve evolves between its value in the normal direction (or 0 degree), and 1 when reaching 90 degrees. A null value does not deviate the curve at all." />
    <input name="reflectivity" type="color3" value="0.9450, 0.7772, 0.3737" uiname="Reflectivity" uifolder="Main"
           doc="Color reflected by the surface in the normal direction." />
    <input name="edgeColor" type="color3" value="0.9979, 0.9813, 0.7523" uiname="Edge Color" uifolder="Main"
           doc="Indicates how the reflected color curve evolves between its value in the normal direction (or 0 degree), and 1 when reaching 90 degrees. Note that this color is unlikely to be reached, and just bends the curve towards it when reaching grazing angles. A null value does not deviate the curve at all." />
    <input name="roughness" type="float" value="0.1" uimin="0.0" uimax="1.0" uiname="Roughness" uifolder="Main"
           doc="Micro-facet distribution roughness." />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" uiname="Normal" uifolder="Main"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <input name="anisotropy" type="float" value="0.0" uimin="-1.0" uimax="1.0" uiname="Anisotropy" uifolder="Anisotropy"
           doc="Defines the amount of anisotropy, changing the co-tangent axis roughness from the original value to 1 (or to 0 with a negative value)." />
    <input name="anisotropyDirection" type="vector3" defaultgeomprop="Tworld" uiname="Direction" uifolder="Anisotropy"
           doc="Overrides the surface tangent as the anisotropy direction." />
    <input name="anisotropyRotation" type="float" value="0.0" uiname="Rotation" uifolder="Anisotropy"
           doc="Rotates the anisotropy direction (possibly overriden by the previous attribute) around the normal, from 0 to 360 degrees." />
    <input name="iridescenceThickness" type="float" value="0.0" uimin="0.0" uisoftmax="200.0" uiname="Thickness" uifolder="Iridescence"
           doc="Thin film thickness in nanometers, driving the iridescent effect." />
    <input name="iridescenceIOR" type="float" value="1.5" uimin="1.0" uimax="3.0" uiname="IOR" uifolder="Iridescence"
           doc="Thin film index of refraction, driving the iridescent effect." />
    <input name="exteriorIOR" type="float" value="1.0" uimin="1.0" uimax="3.0" uiname="Exterior IOR" uifolder="Advanced"
           doc="Defines what the IOR of the exterior medium is (can be either the outside medium, eg. air or water, or in case of a layered material, the top layer medium, like plexiglass or varnish)." />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="IMPL_lama_conductor" nodedef="ND_lama_conductor">

    <!-- IOR -->
    <ifgreater name="exterior_ior_switch" type="float">
      <input name="in1" type="float" interfacename="iridescenceIOR" />
      <input name="in2" type="float" interfacename="exteriorIOR" />
      <input name="value1" type="float" interfacename="iridescenceThickness" />
      <input name="value2" type="float" value="0" />
    </ifgreater>
    <artistic_ior name="artistic_ior" type="multioutput">
      <input name="reflectivity" type="color3" interfacename="reflectivity" />
      <input name="edge_color" type="color3" interfacename="edgeColor" />
    </artistic_ior>
    <convert name="convert_ior" type="color3">
      <input name="in" type="vector3" interfacename="IOR" />
    </convert>
    <convert name="convert_extinction" type="color3">
      <input name="in" type="vector3" interfacename="extinction" />
    </convert>
    <switch name="eta_switch" type="color3">
      <input name="in1" type="color3" nodename="convert_ior" />
      <input name="in2" type="color3" nodename="artistic_ior" output="ior" />
      <input name="which" type="integer" interfacename="fresnelMode" />
    </switch>
    <switch name="kappa_switch" type="color3">
      <input name="in1" type="color3" nodename="convert_extinction" />
      <input name="in2" type="color3" nodename="artistic_ior" output="extinction" />
      <input name="which" type="integer" interfacename="fresnelMode" />
    </switch>
    <divide name="relative_eta" type="color3">
      <input name="in1" type="color3" nodename="eta_switch" />
      <input name="in2" type="float" nodename="exterior_ior_switch" />
    </divide>
    <divide name="relative_kappa" type="color3">
      <input name="in1" type="color3" nodename="kappa_switch" />
      <input name="in2" type="float" nodename="exterior_ior_switch" />
    </divide>

    <!-- Roughness -->
    <subtract name="roughness_inverse" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="roughness" />
    </subtract>
    <ifgreatereq name="delta" type="float">
      <input name="in1" type="float" nodename="roughness_inverse" />
      <input name="in2" type="float" interfacename="roughness" />
      <input name="value1" type="float" interfacename="anisotropy" />
      <input name="value2" type="float" value="0" />
    </ifgreatereq>
    <multiply name="roughness_additional" type="float">
      <input name="in1" type="float" interfacename="anisotropy" />
      <input name="in2" type="float" nodename="delta" />
    </multiply>
    <add name="roughness_bitangent" type="float">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" nodename="roughness_additional" />
    </add>
    <clamp name="roughness_bitangent_clamped" type="float">
      <input name="in" type="float" nodename="roughness_bitangent" />
    </clamp>
    <combine2 name="roughness_linear" type="vector2">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" nodename="roughness_bitangent_clamped" />
    </combine2>
    <power name="roughness_anisotropic_squared" type="vector2">
      <input name="in1" type="vector2" nodename="roughness_linear" />
      <input name="in2" type="float" value="2" />
    </power>
    <max name="roughness_anisotropic_squared_clamped" type="vector2">
      <input name="in1" type="vector2" nodename="roughness_anisotropic_squared" />
      <input name="in2" type="float" value="0.000001" />
    </max>

    <!-- Tangent -->
    <multiply name="tangent_rotate_degree" type="float">
      <input name="in1" type="float" interfacename="anisotropyRotation" />
      <input name="in2" type="float" value="-360" />
    </multiply>
    <rotate3d name="tangent_rotate" type="vector3">
      <input name="in" type="vector3" interfacename="anisotropyDirection" />
      <input name="amount" type="float" nodename="tangent_rotate_degree" />
      <input name="axis" type="vector3" interfacename="normal" />
    </rotate3d>
    <normalize name="tangent_rotate_normalize" type="vector3">
      <input name="in" type="vector3" nodename="tangent_rotate" />
    </normalize>

    <!-- BRDF -->
    <conductor_bsdf name="conductor_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="ior" type="color3" nodename="relative_eta" />
      <input name="extinction" type="color3" nodename="relative_kappa" />
      <input name="roughness" type="vector2" nodename="roughness_anisotropic_squared_clamped" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="tangent_rotate_normalize" />
      <input name="distribution" type="string" value="ggx" />
    </conductor_bsdf>

    <!-- BRDF + Thin film -->
    <divide name="iridescence_relative_ior" type="float">
      <input name="in1" type="float" interfacename="iridescenceIOR" />
      <input name="in2" type="float" interfacename="exteriorIOR" />
    </divide>
    <thin_film_bsdf name="thin_film_bsdf" type="BSDF">
      <input name="thickness" type="float" interfacename="iridescenceThickness" />
      <input name="ior" type="float" nodename="iridescence_relative_ior" />
    </thin_film_bsdf>

    <!-- Layered BRDF -->
    <layer name="thin_film_conductor_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="thin_film_bsdf" />
      <input name="base" type="BSDF" nodename="conductor_bsdf" />
    </layer>

    <!-- Tinted BRDF -->
    <multiply name="tinted_bsdf" type="BSDF">
      <input name="in1" type="BSDF" nodename="thin_film_conductor_bsdf" />
      <input name="in2" type="color3" interfacename="tint" />
    </multiply>

    <!-- Output -->
    <output name="out" type="BSDF" nodename="tinted_bsdf" />

  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_dielectric" node="LamaDielectric" nodegroup="pbr" doc="Lama dielectric" version="1.0" isdefaultversion="true">
    <input name="reflectionTint" type="color3" value="1.0, 1.0, 1.0" uiname="Reflection Tint" uifolder="Main"
           doc="Color multiplier for external reflection. It should be used with parcimony, as a non-white value breaks physicality." />
    <input name="transmissionTint" type="color3" value="1.0, 1.0, 1.0" uiname="Transmission Tint" uifolder="Main"
           doc="Color multiplier for rays going inside the medium (covers external transmission and internal reflection). It should be used with parcimony, as a non-white value breaks physicality. The prefered way to define the color of a dielectric is through the Interior attributes right below." />
    <input name="fresnelMode" type="integer" uniform="true" enum="Scientific,Artistic" enumvalues="0,1" value="0" uiname="Fresnel Mode" uifolder="Main"
           doc="Fresnel mode" />
    <input name="IOR" type="float" value="1.5" uimin="1.0" uimax="3.0" uiname="IOR" uifolder="Main"
           doc="Index of refraction (often denoted by eta), defining the amount reflected by the surface in the normal direction, and how the rays are bent by refraction." />
    <input name="reflectivity" type="float" value="0.04" uiname="Reflectivity" uifolder="Main"
           doc="Reflectivity" />
    <input name="roughness" type="float" value="0.1" uimin="0.0" uimax="1.0" uiname="Roughness" uifolder="Main"
           doc="Micro-facet distribution roughness." />
    <input name="normal" type="vector3" defaultgeomprop="Nworld" uiname="Normal" uifolder="Main"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <input name="anisotropy" type="float" value="0.0" uimin="-1.0" uimax="1.0" uiname="Anisotropy" uifolder="Anisotropy"
           doc="Defines the amount of anisotropy, changing the co-tangent axis roughness from the original value to 1 (or to 0 with a negative value)." />
    <input name="direction" type="vector3" defaultgeomprop="Tworld" uiname="Direction" uifolder="Anisotropy"
           doc="Overrides the surface tangent as the anisotropy direction." />
    <input name="rotation" type="float" value="0.0" uiname="Rotation" uifolder="Anisotropy"
           doc="Rotates the anisotropy direction (possibly overriden by the previous attribute) around the normal, from 0 to 360 degrees." />
    <input name="exteriorIOR" type="float" value="1.0" uimin="1.0" uimax="3.0" uiname="Exterior IOR" uifolder="Advanced"
           doc="Defines what the IOR of the exterior medium is (can be either the outside medium, eg. air or water, or in case of a layered material, the top layer medium, like plexiglass or varnish)." />
    <input name="absorptionColor" type="color3" value="1.0, 1.0, 1.0" uiname="Absorption Color" uifolder="Interior"
           doc="Absorption color" />
    <input name="absorptionRadius" type="float" value="1.0" uiname="Absorption Radius" uifolder="Interior"
           doc="Absorption radius" />
    <input name="scatterColor" type="color3" value="0.0, 0.0, 0.0" uiname="Scatter Color" uifolder="Interior"
           doc="Scatter color" />
    <input name="scatterAnisotropy" type="float" value="0.0" uimin="-1.0" uimax="1.0" uiname="Scatter Anisotropy" uifolder="Interior" 
           doc="Scatter anisotropy" />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="IMPL_lama_dielectric" nodedef="ND_lama_dielectric">

    <!-- IOR -->
    <convert name="reflectivity_color" type="color3">
      <input name="in" type="float" interfacename="reflectivity" uivisible="false" />
    </convert>
    <artistic_ior name="artistic_ior" type="multioutput">
      <input name="reflectivity" type="color3" nodename="reflectivity_color" />
      <input name="edge_color" type="color3" value="0.0, 0.0, 0.0" />
    </artistic_ior>
    <switch name="fresnel_mode_switch" type="float">
      <input name="in1" type="float" interfacename="IOR" />
      <input name="in2" type="float" nodename="artistic_ior" output="ior" channels="r" />
      <input name="which" type="integer" interfacename="fresnelMode" />
    </switch>
    <divide name="relative_ior" type="float">
      <input name="in1" type="float" nodename="fresnel_mode_switch" />
      <input name="in2" type="float" interfacename="exteriorIOR" />
    </divide>

    <!-- Roughness -->
    <subtract name="roughness_inverse" type="float">
      <input name="in1" type="float" value="1.0" />
      <input name="in2" type="float" interfacename="roughness" />
    </subtract>
    <ifgreatereq name="delta" type="float">
      <input name="in1" type="float" nodename="roughness_inverse" />
      <input name="in2" type="float" interfacename="roughness" />
      <input name="value1" type="float" interfacename="anisotropy" />
      <input name="value2" type="float" value="0" />
    </ifgreatereq>
    <multiply name="roughness_additional" type="float">
      <input name="in1" type="float" interfacename="anisotropy" />
      <input name="in2" type="float" nodename="delta" />
    </multiply>
    <add name="roughness_bitangent" type="float">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" nodename="roughness_additional" />
    </add>
    <clamp name="roughness_bitangent_clamped" type="float">
      <input name="in" type="float" nodename="roughness_bitangent" />
    </clamp>
    <combine2 name="roughness_linear" type="vector2">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" nodename="roughness_bitangent_clamped" />
    </combine2>
    <power name="roughness_anisotropic_squared" type="vector2">
      <input name="in1" type="vector2" nodename="roughness_linear" />
      <input name="in2" type="float" value="2" />
    </power>
    <max name="roughness_anisotropic_squared_clamped" type="vector2">
      <input name="in1" type="vector2" nodename="roughness_anisotropic_squared" />
      <input name="in2" type="float" value="0.000001" />
    </max>

    <!-- Tangent -->
    <multiply name="tangent_rotate_degree" type="float">
      <input name="in1" type="float" interfacename="rotation" />
      <input name="in2" type="float" value="-360" />
    </multiply>
    <subtract name="tangent_rotate_degree_offset" type="float">
      <input name="in1" type="float" nodename="tangent_rotate_degree" />
      <input name="in2" type="float" value="0" />
    </subtract>
    <rotate3d name="tangent_rotate" type="vector3">
      <input name="in" type="vector3" interfacename="direction" />
      <input name="amount" type="float" nodename="tangent_rotate_degree_offset" />
      <input name="axis" type="vector3" interfacename="normal" />
    </rotate3d>
    <normalize name="tangent_rotate_normalize" type="vector3">
      <input name="in" type="vector3" nodename="tangent_rotate" />
    </normalize>

    <!-- Interior -->
    <divide name="absorption" type="color3">
      <input name="in1" type="color3" interfacename="absorptionColor" />
      <input name="in2" type="float" interfacename="absorptionRadius" />
    </divide>
    <convert name="absorption_vector" type="vector3">
      <input name="in" type="color3" nodename="absorption" />
    </convert>
    <convert name="scatter_vector" type="vector3">
      <input name="in" type="color3" interfacename="scatterColor" />
    </convert>
    <anisotropic_vdf name="interior_vdf" type="VDF">
      <input name="absorption" type="vector3" nodename="absorption_vector" />
      <input name="scattering" type="vector3" nodename="scatter_vector" />
      <input name="anisotropy" type="float" interfacename="scatterAnisotropy" />
    </anisotropic_vdf>

    <!-- BTDF -->
    <dielectric_bsdf name="transmission_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="tint" type="color3" interfacename="transmissionTint" />
      <input name="ior" type="float" nodename="relative_ior" />
      <input name="roughness" type="vector2" nodename="roughness_anisotropic_squared_clamped" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="tangent_rotate_normalize" />
      <input name="distribution" type="string" value="ggx" />
      <input name="scatter_mode" type="string" value="T" />
    </dielectric_bsdf>
    <layer name="transmission_layer" type="BSDF">
      <input name="top" type="BSDF" nodename="transmission_bsdf" />
      <input name="base" type="VDF" nodename="interior_vdf" />
    </layer>

    <!-- BRDF -->
    <dielectric_bsdf name="reflection_bsdf" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="tint" type="color3" interfacename="reflectionTint" />
      <input name="ior" type="float" nodename="relative_ior" />
      <input name="roughness" type="vector2" nodename="roughness_anisotropic_squared_clamped" />
      <input name="normal" type="vector3" interfacename="normal" />
      <input name="tangent" type="vector3" nodename="tangent_rotate_normalize" />
      <input name="distribution" type="string" value="ggx" />
      <input name="scatter_mode" type="string" value="R" />
    </dielectric_bsdf>

    <!-- BSDF -->
    <layer name="dielectric_bsdf" type="BSDF">
      <input name="top" type="BSDF" nodename="reflection_bsdf" />
      <input name="base" type="BSDF" nodename="transmission_layer" />
    </layer>

    <!-- Output -->
    <output name="out" type="BSDF" nodename="dielectric_bsdf" />

  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_emission" node="LamaEmission" nodegroup="pbr" doc="Lama emission" version="1.0" isdefaultversion="true">
    <input name="color" type="color3" value="1.0, 1.0, 1.0" uiname="Color" uifolder="Main"
           doc="Color being uniformly emitted in all directions above the surface." />
    <output name="out" type="EDF" />
  </nodedef>

  <nodegraph name="IMPL_lama_emission" nodedef="ND_lama_emission">

    <!-- EDF -->
    <uniform_edf name="emission" type="EDF">
      <input name="color" type="color3" interfacename="color" />
    </uniform_edf>

    <!-- Output -->
    <output name="out" type="EDF" nodename="emission" />

  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <!-- LamaLayer for BSDFs -->
  <nodedef name="ND_lama_layer_bsdf" node="LamaLayer" version="1.0" isdefaultversion="true">
    <input name="materialTop" uiname="Material Top" type="BSDF" 
           doc="Material used for the top slab. If not set, the base material will be used by itself." />
    <input name="materialBase" uiname="Material Base" type="BSDF" 
           doc="Base material, right under the top one." />
    <input name="topMix" uiname="Top Mix" type="float" uimin="0.0" uimax="1.0" value="1.0"
           doc="Defines how visible the top material is." />
    <!-- NOTE: The topThickness feature isn't supported by the MaterialX definitions of the nodes right now. -->
    <input name="topThickness" uiname="Top Thickness" type="float" uimin="0.0" value="0.0"
           doc="Thickness of the top slab. It is only relevant for interior effects associated with the top material, such as absorption. If the top material is itself a layer node, this value is passed on to its base component. And if the top material is a mix or add, this value is passed on to both child materials." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodegraph name="NG_lama_layer_bsdf" nodedef="ND_lama_layer_bsdf">
    <multiply name="mul" type="BSDF">
      <input name="in1" type="BSDF" interfacename="materialTop" />
      <input name="in2" type="float" interfacename="topMix" />
    </multiply>
    <layer name="layer" type="BSDF">
      <input name="top" type="BSDF" nodename="mul" />
      <input name="base" type="BSDF" interfacename="materialBase" />
    </layer>
    <output name="out" type="BSDF" nodename="layer" />
  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_translucent" node="LamaTranslucent" version="1.0" isdefaultversion="true">
    <input name="color" uiname="Color" type="color3" value="0.18, 0.18, 0.18"
           doc="Translucent color (aka albedo), defining what ratio of light is transmitted for each color channel." />
    <input name="roughness" uiname="Roughness" type="float" uimin="0.0" uimax="1.0" value="0.0"
           doc="Micro-facet distribution (Oren-Nayar) roughness." />
    <input name="normal" uiname="Normal" type="vector3" defaultgeomprop="Nworld"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <input name="energyCompensation" uiname="Energy Compensation" uifolder="Advanced" type="float" uniform="true" uimin="0.0" uimax="1.0" value="1.0"
           doc="Indicates how much energy should be added to compensate for the loss inherent to the Oren-Nayar model, ranging from no compensation at all, to the expected energy from multiple scattering between the micro-facets. This prevents overly dark results when roughness is high." />
    <input name="lobeName" uiname="Lobe Name" uifolder="Advanced" type="string" uniform="true" value="diffuse"
           doc="Defines the name that can be used in LPE AOVs for this lobe." />
    <input name="matte" uiname="Matte" uifolder="Advanced" type="string" uniform="true" value=""
           doc="Defines the name that can be used by the matte system, to output the weight of this lobe in the final material as an AOV." />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="NG_lama_translucent" nodedef="ND_lama_translucent">
    <translucent_bsdf name="translucent_bsdf1" type="BSDF">
      <input name="color" type="color3" interfacename="color" />
      <input name="normal" type="vector3" interfacename="normal" />
    </translucent_bsdf>
    <output name="out" type="BSDF" nodename="translucent_bsdf1" />
  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">
  <nodedef name="ND_lama_diffuse" node="LamaDiffuse" version="1.0" isdefaultversion="true">
    <input name="color" uiname="Color" type="color3" value="0.18, 0.18, 0.18"
           doc="Diffuse color (aka albedo), defining what ratio of light is reflected for each color channel." />
    <input name="roughness" uiname="Roughness" type="float" uimin="0.0" uimax="1.0" value="0.0" doc="Micro-facet distribution (Oren-Nayar) roughness." />
    <input name="normal" uiname="Normal" type="vector3" defaultgeomprop="Nworld"
           doc="Shading normal, typically defined by bump or normal mapping. Defaults to the smooth surface normal if not set." />
    <input name="energyCompensation" uiname="Energy Compensation" uifolder="Advanced" type="float" uniform="true" uimin="0.0" uimax="1.0" value="1.0"
           doc="Indicates how much energy should be added to compensate for the loss inherent to the Oren-Nayar model, ranging from no compensation at all, to the expected energy from multiple scattering between the micro-facets. This prevents overly dark results when roughness is high." />
    <input name="lobeName" uiname="Lobe Name" uifolder="Advanced" type="string" uniform="true" value="diffuse"
           doc="Defines the name that can be used in LPE AOVs for this lobe." />
    <input name="matte" uiname="Matte" uifolder="Advanced" type="string" uniform="true" value=""
           doc="Defines the name that can be used by the matte system, to output the weight of this lobe in the final material as an AOV." />
    <output name="out" type="BSDF" />
  </nodedef>

  <nodegraph name="NG_lama_diffuse" nodedef="ND_lama_diffuse">
    <multiply name="roughness_squared" type="float">
      <input name="in1" type="float" interfacename="roughness" />
      <input name="in2" type="float" interfacename="roughness" />
    </multiply>
    <multiply name="half_roughness_squared" type="float">
      <input name="in1" type="float" nodename="roughness_squared" />
      <input name="in2" type="float" value="0.5" />
    </multiply>
    <oren_nayar_diffuse_bsdf name="oren_nayar" type="BSDF">
      <input name="weight" type="float" value="1.0" />
      <input name="color" type="color3" interfacename="color" />
      <input name="roughness" type="float" nodename="half_roughness_squared" />
      <input name="normal" type="vector3" interfacename="normal" />
    </oren_nayar_diffuse_bsdf>
    <output name="out" type="BSDF" nodename="oren_nayar" />
  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38" colorspace="acescg">

  <!-- LamaMix for BSDFs -->
  <nodedef name="ND_lama_mix_bsdf" node="LamaMix" version="1.0" isdefaultversion="true">
    <input name="material1" uiname="Material 1" type="BSDF"
           doc="First material to mix." />
    <input name="material2" uiname="Material 2" type="BSDF"
           doc="Second material to mix." />
    <input name="mix" type="float" uimin="0.0" uimax="1.0" value="0.0"
           doc="Defines the balance between the two materials, ranging from 0 (Material 1 only) to 1 (Material 2 only). Can also be seen as a Material 2 over Material 1 mask." />
    <output name="out" type="BSDF" />
  </nodedef>
  <nodegraph name="NG_lama_mix_bsdf" nodedef="ND_lama_mix_bsdf">
    <mix name="mix" type="BSDF">
      <input name="fg" type="BSDF" interfacename="material2" />
      <input name="bg" type="BSDF" interfacename="material1" />
      <input name="mix" type="float" interfacename="mix" />
    </mix>
    <output name="out" type="BSDF" nodename="mix" />
  </nodegraph>

  <!-- LamaMix for EDFs -->
  <nodedef name="ND_lama_mix_edf" node="LamaMix">
    <input name="material1" uiname="Material 1" type="EDF"
           doc="First material to mix." />
    <input name="material2" uiname="Material 2" type="EDF"
           doc="Second material to mix." />
    <input name="mix" type="float" uimin="0.0" uimax="1.0" value="0.0"
           doc="Defines the balance between the two materials, ranging from 0 (Material 1 only) to 1 (Material 2 only). Can also be seen as a Material 2 over Material 1 mask." />
    <output name="out" type="EDF" />
  </nodedef>
  <nodegraph name="NG_lama_mix_edf" nodedef="ND_lama_mix_edf">
    <mix name="mix" type="EDF">
      <input name="fg" type="EDF" interfacename="material2" />
      <input name="bg" type="EDF" interfacename="material1" />
      <input name="mix" type="float" interfacename="mix" />
    </mix>
    <output name="out" type="EDF" nodename="mix" />
  </nodegraph>
</materialx>
<?xml version="1.0"?>
<materialx version="1.38">

  <nodedef name="ND_standard_surface_to_UsdPreviewSurface" node="standard_surface_to_UsdPreviewSurface">
    <input name="metalness" type="float" value="0" />
    <input name="base" type="float" value="1" />
    <input name="base_color" type="color3" value="0.8, 0.8, 0.8" />
    <input name="specular" type="float" value="1" />
    <input name="specular_color" type="color3" value="1, 1, 1" />
    <input name="specular_IOR" type="float" value="1.5" />
    <input name="specular_roughness" type="float" value="0.2" />
    <input name="coat" type="float" value="0" />
    <input name="coat_color" type="color3" value="1, 1, 1" />
    <input name="coat_roughness" type="float" value="0.1" />
    <input name="emission" type="float" value="0" />
    <input name="emission_color" type="color3" value="1, 1, 1" />
    <input name="opacity" type="color3" value="1, 1, 1" />
    <input name="normal" type="vector3" value="0.5, 0.5, 1.0" />

    <output name="diffuseColor_out" type="color3" />
    <output name="emissiveColor_out" type="color3" />
    <output name="metallic_out" type="float" />
    <output name="roughness_out" type="float" />
    <output name="clearcoat_out" type="float" />
    <output name="clearcoatRoughness_out" type="float" />
    <output name="opacity_out" type="float" />
    <output name="ior_out" type="float" />
    <output name="normal_out" type="vector3" />
  </nodedef>

  <nodegraph name="NG_standard_surface_to_UsdPreviewSurface" nodedef="ND_standard_surface_to_UsdPreviewSurface">

    <!-- Constants -->
    <divide name="constantOneThird" type="float">
      <input name="in1" type="float" value="1" />
      <input name="in2" type="float" value="3" />
    </divide>

    <!-- Diffuse/Specular -->
    <dot name="metallic" type="float">
      <input name="in" type="float" interfacename="metalness" />
    </dot>
    <multiply name="scaledBaseColor" type="color3">
      <input name="in1" type="color3" interfacename="base_color" />
      <input name="in2" type="float" interfacename="base" />
    </multiply>
    <mix name="coatAttenuation" type="color3">
      <input name="fg" type="color3" interfacename="coat_color" />
      <input name="bg" type="color3" value="1.0, 1.0, 1.0" />
      <input name="mix" type="float" interfacename="coat" />
    </mix>
    <multiply name="diffuseColor" type="color3">
      <input name="in1" type="color3" nodename="scaledBaseColor" />
      <input name="in2" type="color3" nodename="coatAttenuation" />
    </multiply>
    <dot name="roughness" type="float">
      <input name="in" type="float" interfacename="specular_roughness" />
    </dot>
    <dot name="ior" type="float">
      <input name="in" type="float" interfacename="specular_IOR" />
    </dot>

    <!-- Clearcoat -->
    <multiply name="coatColor" type="color3">
      <input name="in1" type="color3" interfacename="coat_color" />
      <input name="in2" type="float" interfacename="coat" />
    </multiply>
    <dotproduct name="clearcoat" type="float">
      <input name="in1" type="vector3" nodename="coatColor" channels="rgb" />
      <input name="in2" type="vector3" nodename="constantOneThird" channels="xxx" />
    </dotproduct>
    <dot name="clearcoatRoughness" type="float">
      <input name="in" type="float" interfacename="coat_roughness" />
    </dot>

    <!-- Emissive -->
    <multiply name="emissiveColor" type="color3">
      <input name="in1" type="color3" interfacename="emission_color" />
      <input name="in2" type="float" interfacename="emission" />
    </multiply>

    <!-- Opacity -->
    <dotproduct name="opacity" type="float">
      <input name="in1" type="vector3" interfacename="opacity" channels="rgb" />
      <input name="in2" type="vector3" nodename="constantOneThird" channels="xxx" />
    </dotproduct>

    <!-- Normal Map -->
    <subtract name="biasNormal" type="vector3">
      <input name="in1" type="vector3" interfacename="normal" />
      <input name="in2" type="float" value="0.5" />
    </subtract>
    <multiply name="normal" type="vector3">
      <input name="in1" type="vector3" nodename="biasNormal" />
      <input name="in2" type="float" value="2" />
    </multiply>

    <output name="diffuseColor_out" type="color3" nodename="diffuseColor" />
    <output name="emissiveColor_out" type="color3" nodename="emissiveColor" />
    <output name="metallic_out" type="float" nodename="metallic" />
    <output name="roughness_out" type="float" nodename="roughness" />
    <output name="clearcoat_out" type="float" nodename="clearcoat" />
    <output name="clearcoatRoughness_out" type="float" nodename="clearcoatRoughness" />
    <output name="opacity_out" type="float" nodename="opacity" />
    <output name="ior_out" type="float" nodename="ior" />
    <output name="normal_out" type="vector3" nodename="normal" />
  </nodegraph>
</materialx>
<?xml version="1.0" encoding="UTF-8"?>
<!--
  TM & (c) 2019 Lucasfilm Entertainment Company Ltd. and Lucasfilm Ltd.
  All rights reserved.  See LICENSE.txt for license.

  Declarations of example light shader nodes.

  DISCLAIMER: These nodes are only to serve as examples of light shader nodes.
  They are not standardized members of MaterialX's standard libraries, and they
  may change in future revisions.
-->

<materialx version="1.37">

  <!-- ======================================================================== -->
  <!-- Light shader nodes                                                       -->
  <!-- ======================================================================== -->

  <!--
    Node: <point_light>
  -->
  <nodedef name="ND_point_light" node="point_light" nodegroup="light"
           doc="A light shader node of 'point' type.">
    <input name="position" type="vector3" doc="Light source position."/>
    <input name="color" type="color3" doc="Light color."/>
    <input name="intensity" type="float" doc="Light intensity."/>
    <input name="decay_rate" type="float" value="2.0" doc="Light decay exponent. Defaults to 2 for quadratic decay."/>
    <output name="out" type="lightshader"/>
  </nodedef>

  <!--
    Node: <directional_light>
  -->
  <nodedef name="ND_directional_light" node="directional_light" nodegroup="light"
           doc="A light shader node of 'directional' type.">
    <input name="direction" type="vector3" doc="Light source direction."/>
    <input name="color" type="color3" doc="Light color."/>
    <input name="intensity" type="float" doc="Light intensity."/>
    <output name="out" type="lightshader"/>
  </nodedef>

  <!--
    Node: <spot_light>
  -->
  <nodedef name="ND_spot_light" node="spot_light" nodegroup="light"
           doc="A light shader node of 'spot' type.">
    <input name="position" type="vector3" doc="Light source position."/>
    <input name="direction" type="vector3" doc="Light source direction."/>
    <input name="color" type="color3" doc="Light color."/>
    <input name="intensity" type="float" doc="Light intensity."/>
    <input name="decay_rate" type="float" value="2.0" doc="Light decay exponent. Defaults to 2 for quadratic decay."/>
    <input name="inner_angle" type="float" doc="Inner cone angle."/>
    <input name="outer_angle" type="float" doc="Outer cone angle."/>
    <output name="out" type="lightshader"/>
  </nodedef>

</materialx>
void mx_spot_light(LightData light, vec3 position, out lightshader result)
{
    result.direction = light.position - position;
    float distance = length(result.direction) + M_FLOAT_EPS;
    float attenuation = pow(distance + 1.0, light.decay_rate + M_FLOAT_EPS);
    result.intensity = light.color * light.intensity / attenuation;
    result.direction /= distance;
    float low = min(light.inner_angle, light.outer_angle);
    float high = light.inner_angle;
    float cosDir = dot(result.direction, -light.direction);
    float spotAttenuation = smoothstep(low, high, cosDir);
    result.intensity *= spotAttenuation;
}
void mx_point_light(LightData light, vec3 position, out lightshader result)
{
    result.direction = light.position - position;
    float distance = length(result.direction) + M_FLOAT_EPS;
    float attenuation = pow(distance + 1.0, light.decay_rate + M_FLOAT_EPS);
    result.intensity = light.color * light.intensity / attenuation;
    result.direction /= distance;
}
void mx_directional_light(LightData light, vec3 position, out lightshader result)
{
    result.direction = -light.direction;
    result.intensity = light.color * light.intensity;
}
<?xml version="1.0" encoding="UTF-8"?>
<materialx version="1.37">

  <!-- <point_light> -->
  <implementation name="IM_point_light_genglsl" nodedef="ND_point_light" file="lights/genglsl/mx_point_light.glsl" function="mx_point_light" target="genglsl"/>

  <!-- <directional_light> -->
  <implementation name="IM_directional_light_genglsl" nodedef="ND_directional_light" file="lights/genglsl/mx_directional_light.glsl" function="mx_directional_light" target="genglsl"/>

  <!-- <spot_light> -->
  <implementation name="IM_spot_light_genglsl" nodedef="ND_spot_light" file="lights/genglsl/mx_spot_light.glsl" function="mx_spot_light" target="genglsl"/>

</materialx>
